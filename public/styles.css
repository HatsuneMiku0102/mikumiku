document.addEventListener('DOMContentLoaded', function () {
    let constellationsList = [];

    const starCatalog = [
        { name: "Betelgeuse", ra: "05h 55m 10.3053s", dec: "+07° 24′ 25.430″", magnitude: 0.42, spectralType: "M1-M2" },
        { name: "Bellatrix", ra: "05h 25m 07.8632s", dec: "+06° 20′ 59.331″", magnitude: 1.64, spectralType: "B2III" },
        { name: "Saiph", ra: "05h 47m 45.3485s", dec: "-09° 40′ 10.146″", magnitude: 2.07, spectralType: "B0Ia" },
        { name: "Rigel", ra: "05h 14m 32.27210s", dec: "-08° 12′ 05.8981″", magnitude: 0.18, spectralType: "B8I" },
        { name: "Alnilam", ra: "05h 36m 12.8130s", dec: "-01° 12′ 06.9″", magnitude: 1.69, spectralType: "B0Ia" },
        { name: "Alnitak", ra: "05h 40m 45.5277s", dec: "-01° 56′ 33.89″", magnitude: 1.74, spectralType: "O9.5I" },
        { name: "Mintaka", ra: "05h 32m 00.40s", dec: "-00° 17′ 56″", magnitude: 2.23, spectralType: "O9III" }
    ];

    const constellationData = [
        {
            name: "Orion",
            stars: ["Betelgeuse", "Bellatrix", "Saiph", "Rigel", "Alnilam", "Alnitak", "Mintaka"],
            connections: [
                [0, 1], [0, 2], [1, 4], [2, 6],
                [4, 5], [5, 6], [1, 3], [2, 3]
            ]
        }
        // Add additional constellations here as necessary
    ];

    function parseRA(raStr) {
        const raRegex = /(\d+)h\s+(\d+)m\s+([\d.]+)s/;
        const match = raStr.match(raRegex);
        if (!match) return 0;
        const hours = parseInt(match[1], 10);
        const minutes = parseInt(match[2], 10);
        const seconds = parseFloat(match[3]);
        return (hours + minutes / 60 + seconds / 3600) * 15; // Convert RA from hours to degrees
    }

    function parseDec(decStr) {
        const decRegex = /([+-]?)(\d+)°\s+(\d+)′\s+([\d.]+)″/;
        const match = decStr.match(decRegex);
        if (!match) return 0;
        const sign = match[1] === '-' ? -1 : 1;
        const degrees = parseInt(match[2], 10);
        const minutes = parseInt(match[3], 10);
        const seconds = parseFloat(match[4]);
        return sign * (degrees + minutes / 60 + seconds / 3600);
    }

    function raDecToXY(ra, dec, canvasWidth, canvasHeight, scale = 400) {
        const raRad = (ra * Math.PI) / 180;
        const decRad = (dec * Math.PI) / 180;

        const x = canvasWidth / 2 + scale * (Math.cos(decRad) * Math.sin(raRad));
        const y = canvasHeight / 2 - scale * (Math.cos(decRad) * Math.cos(raRad));

        return { x, y };
    }

    function mapMagnitudeToAppearance(magnitude) {
        if (magnitude <= 1) {
            return { radius: 6, baseOpacity: 1 };
        } else if (magnitude <= 2) {
            return { radius: 5, baseOpacity: 0.8 };
        } else if (magnitude <= 3) {
            return { radius: 4, baseOpacity: 0.6 };
        } else if (magnitude <= 4) {
            return { radius: 3, baseOpacity: 0.4 };
        } else {
            return { radius: 2, baseOpacity: 0.2 };
        }
    }

    function mapSpectralTypeToColor(spectralType) {
        if (spectralType.startsWith("O")) {
            return { r: 155, g: 176, b: 255 };
        } else if (spectralType.startsWith("B")) {
            return { r: 170, g: 191, b: 255 };
        } else if (spectralType.startsWith("A")) {
            return { r: 202, g: 215, b: 255 };
        } else if (spectralType.startsWith("F")) {
            return { r: 248, g: 247, b: 255 };
        } else if (spectralType.startsWith("G")) {
            return { r: 255, g: 244, b: 234 };
        } else if (spectralType.startsWith("K")) {
            return { r: 255, g: 210, b: 161 };
        } else if (spectralType.startsWith("M")) {
            return { r: 255, g: 204, b: 111 };
        } else {
            return { r: 255, g: 255, b: 255 };
        }
    }

    class Star {
        constructor(name, x, y, radius, twinkleSpeed, color, baseOpacity) {
            this.name = name;
            this.x = x;
            this.y = y;
            this.radius = radius;
            this.twinkleSpeed = twinkleSpeed;
            this.opacity = baseOpacity;
            this.baseOpacity = baseOpacity;
            this.twinkleDirection = Math.random() > 0.5 ? 1 : -1;
            this.color = color;
        }

        update() {
            this.opacity += this.twinkleSpeed * this.twinkleDirection;
            if (this.opacity <= this.baseOpacity * 0.5) {
                this.opacity = this.baseOpacity * 0.5;
                this.twinkleDirection = 1;
            } else if (this.opacity >= this.baseOpacity) {
                this.opacity = this.baseOpacity;
                this.twinkleDirection = -1;
            }
        }

        draw(ctx) {
            const gradient = ctx.createRadialGradient(this.x, this.y, this.radius, this.x, this.y, this.radius * 4);
            gradient.addColorStop(0, `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${this.opacity})`);
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius * 4, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();

            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${this.opacity})`;
            ctx.fill();
        }
    }

    class Constellation {
        constructor(data, canvasWidth, canvasHeight) {
            this.name = data.name;
            this.stars = [];
            this.connections = data.connections;
            this.canvasWidth = canvasWidth;
            this.canvasHeight = canvasHeight;
            this.scale = Math.random() * 200 + 300;

            this.position = this.getRandomPosition();
            this.generateStars(data.stars);
        }

        getRandomPosition() {
            const padding = this.scale * 2;
            return {
                x: Math.random() * (this.canvasWidth - 2 * padding) + padding,
                y: Math.random() * (this.canvasHeight - 2 * padding) + padding
            };
        }

        generateStars(starNames) {
            starNames.forEach(starName => {
                const starInfo = starCatalog.find(star => star.name === starName);
                if (!starInfo) {
                    console.warn(`Star "${starName}" not found in starCatalog.`);
                    return;
                }

                const ra = parseRA(starInfo.ra);
                const dec = parseDec(starInfo.dec);

                const { x, y } = raDecToXY(ra, dec, this.canvasWidth, this.canvasHeight, this.scale);
                const appearance = mapMagnitudeToAppearance(starInfo.magnitude);
                const color = mapSpectralTypeToColor(starInfo.spectralType);

                this.stars.push(new Star(
                    starInfo.name,
                    x + this.position.x,
                    y + this.position.y,
                    appearance.radius,
                    0.002,
                    color,
                    appearance.baseOpacity
                ));
            });
        }

        update() {
            this.stars.forEach(star => star.update());
        }

        draw(ctx) {
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.lineWidth = 1;
            this.connections.forEach(connection => {
                const [indexA, indexB] = connection;
                const starA = this.stars[indexA];
                const starB = this.stars[indexB];
                if (starA && starB) {
                    ctx.beginPath();
                    ctx.moveTo(starA.x, starA.y);
                    ctx.lineTo(starB.x, starB.y);
                    ctx.stroke();
                }
            });

            this.stars.forEach(star => star.draw(ctx));
        }

        getStarAtPosition(x, y) {
            for (let star of this.stars) {
                const dx = x - star.x;
                const dy = y - star.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance <= star.radius * 4) {
                    return star;
                }
            }
            return null;
        }
    }

    const canvasElement = document.getElementById('techCanvas');
    const ctx = canvasElement.getContext('2d');

    function resizeCanvas() {
        canvasElement.width = window.innerWidth;
        canvasElement.height = window.innerHeight;
        initializeConstellations();
    }

    window.addEventListener('resize', resizeCanvas);

    function initializeConstellations() {
        constellationsList = [];
        constellationData.forEach(def => {
            const constel = new Constellation(def, canvasElement.width, canvasElement.height);
            constellationsList.push(constel);
        });
    }

    resizeCanvas();

    let tooltip = document.getElementById('tooltip');
    if (!tooltip) {
        tooltip = document.createElement('div');
        tooltip.id = 'tooltip';
        tooltip.style.position = 'absolute';
        tooltip.style.background = 'rgba(0, 0, 0, 0.7)';
        tooltip.style.color = '#fff';
        tooltip.style.padding = '5px 10px';
        tooltip.style.borderRadius = '4px';
        tooltip.style.pointerEvents = 'none';
        tooltip.style.visibility = 'hidden';
        tooltip.style.zIndex = '1001';
        tooltip.style.transition = 'opacity 0.3s';
        tooltip.style.fontSize = '12px';
        tooltip.style.maxWidth = '200px';
        document.body.appendChild(tooltip);
    }

    function getMousePos(event) {
        const rect = canvasElement.getBoundingClientRect();
        return {
            x: event.clientX - rect.left,
            y: event.clientY - rect.top
        };
    }

    function handleHover(event) {
        const mousePos = getMousePos(event);
        let found = false;

        for (let constel of constellationsList) {
            const star = constel.getStarAtPosition(mousePos.x, mousePos.y);
            if (star) {
                showTooltip(event.clientX, event.clientY, `⭐ ${star.name}<br>Constellation: ${constel.name}`);
                found = true;
                break;
            }
        }

        if (!found) {
            hideTooltip();
        }
    }

    function showTooltip(x, y, content) {
        tooltip.innerHTML = content;
        tooltip.style.left = `${x + 10}px`;
        tooltip.style.top = `${y + 10}px`;
        tooltip.style.visibility = 'visible';
        tooltip.style.opacity = '1';
    }

    function hideTooltip() {
        tooltip.style.visibility = 'hidden';
        tooltip.style.opacity = '0';
    }

    canvasElement.addEventListener('mousemove', handleHover);
    canvasElement.addEventListener('mouseleave', hideTooltip);

    function animateBackground() {
        requestAnimationFrame(animateBackground);
        ctx.clearRect(0, 0, canvasElement.width, canvasElement.height);

        constellationsList.forEach(constellation => {
            constellation.update();
            constellation.draw(ctx);
        });
    }

    animateBackground();
});
