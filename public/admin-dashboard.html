<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>MikuMiku | Admin Dashboard</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="stylesheet" href="/styles.css">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body { font-family: 'Roboto', sans-serif; background-color: #f5f5f5; color: #333; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; }
    .dashboard-container { background-color: #fff; padding: 40px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); width: 80%; max-width: 800px; margin: auto; }
    h2 { color: #007BFF; text-align: center; margin-bottom: 24px; }
    button { background-color: #007BFF; color: #fff; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer; margin-left: 10px; }
    button:hover { background-color: #0056b3; }
    .real-time-info, .user-list, .toggle-section { margin-top: 20px; }
    .ip-list { margin: 0; padding: 0; list-style: none; max-height: 200px; overflow-y: auto; border: 1px solid #e9e9e9; border-radius: 4px; }
    .ip-item { background-color: #e9e9e9; padding: 10px; margin: 5px 0; border-radius: 4px; display: flex; justify-content: space-between; align-items: center; }
    .chart-container { margin-top: 40px; text-align: center; }
    canvas { margin: 0 auto; display: block; }
    .toggle-section { text-align: center; }
    .toggle-section label { font-size: 1em; margin-right: 8px; }
    .minute-timeline-container { margin-top: 20px; }
    .timeline-header { font-weight: bold; margin-bottom: 10px; text-align: center; }
    .timeline-blocks { display: flex; gap: 4px; justify-content: center; overflow: visible; }
    .timeline-block { width: 4px; height: 20px; border-radius: 2px; position: relative; cursor: pointer; background-color: inherit; transition: transform 0.3s, opacity 0.3s; }
    .timeline-block:hover { transform: scale(1.5); z-index: 2; }
    .timeline-block .tooltip { position: absolute; bottom: 150%; left: 50%; transform: translateX(-50%); background-color: rgba(0,0,0,0.75); color: #fff; padding: 5px 8px; border-radius: 4px; font-size: 0.75rem; white-space: pre; visibility: hidden; opacity: 0; transition: opacity 0.3s; z-index: 10; pointer-events: none; }
    .timeline-block:hover .tooltip { visibility: visible; opacity: 1; }
  </style>
</head>
<body>
  <div class="dashboard-container">
    <h2>Admin Dashboard</h2>
    <button id="logout">Logout</button>
    <div class="toggle-section">
      <label for="lfgToggle">LFG Command Enabled:</label>
      <input type="checkbox" id="lfgToggle">
    </div>
    <div class="real-time-info">
      <h3>Real-time Active Users</h3>
      <p id="active-users-count">Loading active user count...</p>
    </div>
    <div class="user-list">
      <h3>Active Users</h3>
      <ul id="active-ip-list" class="ip-list">Loading...</ul>
    </div>
    <div class="chart-container">
      <h3>Visitors by Country</h3>
      <canvas id="locationChart" width="400" height="200"></canvas>
    </div>
    <div class="minute-timeline-container">
      <div class="timeline-header">Minute-by-Minute Status</div>
      <div class="timeline-blocks" id="minuteTimeline"></div>
    </div>
  </div>
  <script src="/socket.io/socket.io.js"></script>
  <script>
    let timelineData = []
    const MAX_MINUTES = 60
    document.addEventListener('DOMContentLoaded', function() {
      const cookieString = document.cookie
      const token = cookieString.split('; ').find(row => row.startsWith('token='))?.split('=')[1]
      if (!token) {
        window.location.href = '/auth'
        return
      }
      const socket = io()
      socket.on('connect', () => {
        socket.emit('getToggleState')
      })
      socket.on('toggleState', (data) => {
        document.getElementById('lfgToggle').checked = data.commands_enabled
      })
      socket.on('toggleUpdated', (data) => {
        document.getElementById('lfgToggle').checked = data.commands_enabled
      })
      document.getElementById('lfgToggle').addEventListener('change', function() {
        const newState = this.checked
        socket.emit('toggleCommands', { commands_enabled: newState })
      })
      const ctx = document.getElementById('locationChart').getContext('2d')
      const locationChart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: [],
          datasets: [{
            label: 'Visitors by Country',
            data: [],
            backgroundColor: 'rgba(54, 162, 235, 0.6)',
            borderColor: 'rgba(54, 162, 235, 1)',
            borderWidth: 1
          }]
        },
        options: { responsive: true, scales: { y: { beginAtZero: true } } }
      })
      function updateChart(countryData) {
        const countries = countryData.map(item => item._id || 'Unknown')
        const visitCounts = countryData.map(item => item.count)
        locationChart.data.labels = countries
        locationChart.data.datasets[0].data = visitCounts
        locationChart.update()
      }
      fetch('/api/geo-data')
        .then(response => response.json())
        .then(data => updateChart(data))
        .catch(error => console.error('Error fetching geo data:', error))
      socket.on('geoDataUpdate', (data) => {
        updateChart(data)
      })
      socket.on('activeUsersUpdate', (data) => {
        document.getElementById('active-users-count').innerText = `Currently Active Users: ${data.users.length}`
        const activeIpListElement = document.getElementById('active-ip-list')
        activeIpListElement.innerHTML = ''
        data.users.forEach(user => {
          const ipItem = createIpItem(user)
          activeIpListElement.appendChild(ipItem)
        })
      })
      function createIpItem(user) {
        const ipItem = document.createElement('li')
        ipItem.classList.add('ip-item')
        const connectionTypes = Array.from(user.connectionTypes).join(', ')
        ipItem.innerText = `IP: ${user.ip}, Connection Types: ${connectionTypes}`
        const blockButton = document.createElement('button')
        blockButton.innerText = 'Block'
        blockButton.onclick = () => blockUser(user.ip)
        const unblockButton = document.createElement('button')
        unblockButton.innerText = 'Unblock'
        unblockButton.onclick = () => unblockUser(user.ip)
        ipItem.appendChild(blockButton)
        ipItem.appendChild(unblockButton)
        return ipItem
      }
      function blockUser(ip) {
        socket.emit('blockUser', { ip }, (response) => {
          if (response.status === 'success') {
            alert(`User with IP ${ip} has been blocked.`)
          } else {
            alert(`Failed to block user: ${response.message}`)
          }
        })
      }
      function unblockUser(ip) {
        socket.emit('unblockUser', { ip }, (response) => {
          if (response.status === 'success') {
            alert(`User with IP ${ip} has been unblocked.`)
          } else {
            alert(`Failed to unblock user: ${response.message}`)
          }
        })
      }
      document.getElementById('logout').addEventListener('click', () => {
        fetch('/logout', { method: 'POST', credentials: 'include' })
          .then(() => {
            document.cookie = 'token=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;'
            window.location.href = '/auth'
          })
          .catch(error => console.error('Logout failed:', error))
      })
      fetch('/api/timeline')
        .then(response => response.json())
        .then(data => {
          timelineData = data || []
          renderTimeline()
        })
        .catch(error => console.error('Error fetching timeline data:', error))
      function saveTimelineData(entry) {
        fetch('/api/timeline', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(entry)
        })
        .then(response => response.json())
        .then(data => console.log('Timeline entry saved:', data))
        .catch(err => console.error('Error saving timeline entry:', err))
      }
      function renderTimeline() {
        timelineContainer.innerHTML = ''
        timelineData.forEach(data => {
          const block = createTimelineBlock(data)
          timelineContainer.appendChild(block)
        })
      }
      const timelineContainer = document.getElementById('minuteTimeline')
      function createTimelineBlock(data) {
        const block = document.createElement('div')
        block.classList.add('timeline-block')
        if (data.status !== 'online') {
          block.style.backgroundColor = '#dc3545'
        } else if (parseInt(data.latency) > 100) {
          block.style.backgroundColor = '#ffc107'
        } else {
          block.style.backgroundColor = '#28a745'
        }
        const tooltip = document.createElement('div')
        tooltip.classList.add('tooltip')
        tooltip.innerText = `Time: ${data.timestamp}\nBot: ${data.botName}\nUptime: ${data.uptime}\nLatency: ${data.latency}\nMemory: ${data.memoryUsage}`
        block.appendChild(tooltip)
        return block
      }
      function addTimelineBlock(data) {
        const now = Date.now()
        if (timelineData.length >= MAX_MINUTES) {
          timelineData.shift()
        }
        const blockData = { ...data, rawTimestamp: now, timestamp: new Date(now).toLocaleTimeString() }
        timelineData.push(blockData)
        saveTimelineData(blockData)
        renderTimeline()
      }
      socket.on('botStatusUpdate', (data) => {
        addTimelineBlock(data)
      })
    })
  </script>
</body>
</html>
