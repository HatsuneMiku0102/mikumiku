<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MikuMiku | Home</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/styles.css">
</head>

<body>
    <canvas id="techCanvas"></canvas>

    <div class="page-container">
        <!-- Title Bar with Dropdown -->
        <div class="title-bar">
            <div class="container">
                <!-- Left Section: Empty for Spacing -->
                <div class="left-section">
                    <!-- Reserved for future use or keep empty -->
                </div>

                <!-- Center Section: Logo and Title -->
                <div class="center-section">
                    <div class="logo-title-wrapper">
                        <!-- Added loading="lazy" for performance optimization -->
                        <img src="/logo.webp" alt="Logo" class="logo" loading="lazy">
                        <h1 class="site-title" id="dynamicTitle">MikuMiku</h1>
                    </div>
                </div>

                <!-- Right Section: Personality Circle and Dropdown -->
                <div class="right-section">
                    <div class="personality-section">
                        <div id="personalityCircle" class="personality-circle"></div>

                        <!-- Speech Bubble Positioned Under the Circle -->
                        <div id="personalityTextBox" class="personality-text-box">
                            <div id="personalityPhrase" class="personality-text-wrapper"></div>
                        </div>
                    </div>
                    <div class="dropdown">
                        <button class="dropdown-button">Menu</button>
                        <div class="dropdown-content">
                            <a href="/admin-login.html">Admin Login</a>
                            <!-- Add more dropdown links here if needed -->
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Main Content -->
        <div id="main-content" class="main-content">
            <!-- Now Playing Section -->
            <div id="now-playing-container" class="now-playing-container">
                <div id="now-playing" class="now-playing">
                    <div class="now-playing-sidebar">
                        <div class="sidebar-item">
                            <span>Channel:</span> <span id="channelName">Loading...</span>
                        </div>
                        <div class="sidebar-item">
                            <span>Views:</span> <span id="viewCount">Loading...</span>
                        </div>
                        <div class="sidebar-item">
                            <span>Uploaded:</span> <span id="publishedDate">Loading...</span>
                        </div>
                        <!-- Added Video Category -->
                        <div class="sidebar-item video-category">
                            <span>Category:</span> <span id="videoCategory">Loading...</span>
                        </div>
                        <!-- Added Live Stream Indicator -->
                        <div class="sidebar-item live-indicator" id="liveIndicator" style="display: none;">
                            ðŸ”´ Live Now
                        </div>
                    </div>

                    <div class="video-section">
                        <div class="video-title-container">
                            <h2>Currently Playing on YouTube</h2>
                            <p id="videoTitle">Loading...</p>
                        </div>

                        <!-- Additional Visual Enhancements: Video Description -->
                        <div class="video-description-container">
                            <p id="videoDescription">Loading description...</p>
                        </div>

                        <div class="progress-bar-wrapper">
                            <span id="pausedIcon" class="paused-icon" aria-label="Video Paused" title="Video Paused">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                                    <rect x="6" y="5" width="4" height="14"></rect>
                                    <rect x="14" y="5" width="4" height="14"></rect>
                                </svg>
                            </span>

                            <!-- Updated Progress Bar as a Div -->
                            <div id="progress-bar" class="progress-bar"></div>
                        </div>

                        <!-- Added loading="lazy" for performance optimization -->
                        <img id="videoThumbnail" src="" alt="Thumbnail of currently playing video" class="video-thumbnail" loading="lazy">

                        <div class="progress-times-container">
                            <p id="time-elapsed" class="progress-time">Time Elapsed: --:--</p>
                            <p id="total-duration" class="progress-time">Total Duration: --:--</p>
                            <p id="time-remaining" class="progress-time" style="display: none;">Browsing for: --:--</p>
                        </div>

                        <div id="offline-indicator" class="offline-indicator" style="display: none;">
                            Iâ€™m not on YouTube at the moment, soz :(
                        </div>

                        <!-- Added Live Stream Indicator -->
                        <!-- This is already included above in the sidebar -->

                        <!-- Additional Visual Enhancements: Video Category -->
                        <!-- Already added above in the sidebar -->

                        <!-- Additional Visual Enhancements: Video Description -->
                        <!-- Already added above -->

                        <!-- Performance Optimizations: Lazy Loading images are already added -->
                    </div>
                </div>
            </div>

            <!-- Widgets Section -->
            <div class="widgets-container">
                <div class="live-clock box-container">
                    <h3>My Current Time</h3>
                    <div class="clock-container">
                        <div class="clock">
                            <p id="local-time">--:--:--</p>
                            <p id="current-date">24 Sep 2024</p>
                        </div>
                    </div>
                </div>

                <div class="weather-widget box-container">
                    <h3>My Current Weather</h3>
                    <div class="weather-info">
                        <!-- Added loading="lazy" via JavaScript -->
                        <img id="weather-icon" src="" alt="Weather Icon" loading="lazy">
                        <p id="weather-description">Loading...</p>
                        <p id="temperature">--Â°C</p>
                        <p id="humidity">Humidity: --%</p>
                        <p id="wind-speed">Wind: -- m/s</p>
                    </div>
                </div>
            </div>

            <!-- About Section -->
            <div class="content-wrapper">
                <div class="now-playing-about-wrapper">
                    <div class="about box-container" id="aboutMe">
                        <h2>About Me</h2>
                        <p>Hey there, I'm Hystoriya, a 24-year-old developer. This is my personal website that I made for no apparent reason. If you find yourself here randomly, then hi :)</p>
                    </div>
                </div>
            </div>
        </div>

        <footer class="footer">
            <div class="container">
                <p>&copy; 2024 MikuMiku. All rights reserved.</p>
            </div>
        </footer>
    </div>


    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.1/moment.min.js"></script>

    <script src="haru.js"></script>

    <script>
        // Time of Day Dynamic Title
        function getTimeOfDay() {
            const hour = new Date().getHours();
            if (hour < 12) {
                return "Good Morning";
            } else if (hour >= 12 && hour < 18) {
                return "Good Afternoon";
            } else {
                return "Good Evening";
            }
        }

        function setDynamicTitle() {
            const originalTitle = document.title;
            const timeOfDayMessage = getTimeOfDay();

            document.title = timeOfDayMessage;

            const dynamicTitleElement = document.getElementById('dynamicTitle');
            if (dynamicTitleElement) {
                dynamicTitleElement.innerText = timeOfDayMessage;
            }

            setTimeout(() => {
                document.title = originalTitle;
                if (dynamicTitleElement) {
                    dynamicTitleElement.innerText = "MikuMiku";
                }
            }, 5000);
        }

        setDynamicTitle();

        document.addEventListener("visibilitychange", function () {
            if (!document.hidden) {
                setDynamicTitle();
            }
        });
    </script>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            let intervalID = null;
            let videoStartTime = null;
            let videoDuration = 0;
            let isVideoPaused = true;
            let isBrowsing = false;
            const MAX_RECENT_VIDEOS = 3;
            let previousVideoData = null;

            const YOUTUBE_API_URL = '/api/youtube';
            const WEATHER_API_URL = '/api/weather';
            const CITY_NAME = 'Leeds';

            // Mapping of YouTube category IDs to category names
            const categories = {
                "1": "Film & Animation",
                "2": "Autos & Vehicles",
                "10": "Music",
                "15": "Pets & Animals",
                "17": "Sports",
                "18": "Short Movies",
                "19": "Travel & Events",
                "20": "Gaming",
                "21": "Videoblogging",
                "22": "People & Blogs",
                "23": "Comedy",
                "24": "Entertainment",
                "25": "News & Politics",
                "26": "Howto & Style",
                "27": "Education",
                "28": "Science & Technology",
                "29": "Nonprofits & Activism",
                "30": "Movies",
                "31": "Anime/Animation",
                "32": "Action/Adventure",
                "33": "Classics",
                "34": "Comedy",
                "35": "Documentary",
                "36": "Drama",
                "37": "Family",
                "38": "Foreign",
                "39": "Horror",
                "40": "Sci-Fi/Fantasy",
                "41": "Thriller",
                "42": "Shorts",
                "43": "Shows",
                "44": "Trailers"
                // Add more categories as needed
            };

            function formatTime(seconds) {
                const minutes = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${minutes}:${secs < 10 ? '0' : ''}${secs}`;
            }

            function clearExistingInterval() {
                if (intervalID) {
                    clearInterval(intervalID);
                    intervalID = null;
                }
            }

            async function fetchYouTubeVideoDetails(videoID) {
                try {
                    const response = await fetch(`${YOUTUBE_API_URL}?videoId=${videoID}`);
                    const data = await response.json();

                    if (data.error) {
                        console.error(data.error);
                        displayError('Failed to load video details.');
                        return 0;
                    }

                    if (data && data.items && data.items.length > 0) {
                        const video = data.items[0];
                        const snippet = video.snippet;
                        const stats = video.statistics;
                        const durationISO = video.contentDetails.duration;
                        const liveBroadcastContent = snippet.liveBroadcastContent;

                        videoDuration = moment.duration(durationISO).asSeconds();
                        const formattedDuration = formatTime(videoDuration);

                        document.getElementById('videoTitle').innerText = snippet.title || 'No Title Available';
                        document.getElementById('channelName').innerText = snippet.channelTitle || 'Unknown Channel';
                        document.getElementById('publishedDate').innerText = snippet.publishedAt ? new Date(snippet.publishedAt).toLocaleDateString() : 'Unknown Date';

                        const viewsFormatted = stats.viewCount ? Number(stats.viewCount).toLocaleString() : '0';
                        document.getElementById('viewCount').innerText = `${viewsFormatted} views`;

                        // Added loading="lazy" to videoThumbnail
                        const videoThumbnail = document.getElementById('videoThumbnail');
                        videoThumbnail.src = snippet.thumbnails?.high?.url || '/default-thumbnail.jpg';
                        videoThumbnail.alt = snippet.title || 'Video Thumbnail';
                        videoThumbnail.setAttribute('loading', 'lazy');

                        document.getElementById('total-duration').innerText = `Total Duration: ${formattedDuration}`;

                        // Video Description
                        document.getElementById('videoDescription').innerText = snippet.description || 'No Description Available';

                        // Video Category
                        const categoryId = snippet.categoryId;
                        const categoryName = categories[categoryId] || 'Uncategorized';
                        document.getElementById('videoCategory').innerText = categoryName;

                        // Live Stream Indicator
                        const liveIndicator = document.getElementById('liveIndicator');
                        if (liveBroadcastContent === 'live') {
                            liveIndicator.style.display = 'block';
                        } else {
                            liveIndicator.style.display = 'none';
                        }

                        // Channel Avatar
                        const channelAvatar = document.getElementById('channelAvatar');
                        if (channelAvatar) {
                            channelAvatar.src = snippet.thumbnails?.default?.url || '/default-avatar.jpg';
                            channelAvatar.alt = `${snippet.channelTitle} Avatar`;
                            channelAvatar.setAttribute('loading', 'lazy');
                        }

                        return videoDuration;
                    } else {
                        console.error('No video data found for the provided videoId.');
                        displayError('No video data found.');
                        return 0;
                    }
                } catch (error) {
                    console.error('Error fetching video details:', error);
                    displayError('An error occurred while fetching video details.');
                }
                return 0;
            }

            function displayError(message) {
                const videoSection = document.querySelector('.video-section');
                const errorContainer = document.createElement('div');
                errorContainer.className = 'error-message';
                errorContainer.innerText = message;
                videoSection.prepend(errorContainer);
            }

            // Initialize Socket.io
            const socket = io();

            socket.on('connect', () => {
                console.log('Frontend connected to server via Socket.io');
            });

            socket.on('disconnect', () => {
                console.log('Frontend disconnected from server');
            });

            socket.on('nowPlayingUpdate', (data) => {
                const { isOffline, videoUrl, title, currentTime, isPaused, liveBroadcastContent, categoryId } = data;

                const videoTitleElement = document.getElementById('videoTitle');
                const videoThumbnailElement = document.getElementById('videoThumbnail');
                const nowPlayingElement = document.querySelector('.now-playing');
                const offlineIndicator = document.getElementById('offline-indicator');
                const pausedIcon = document.getElementById('pausedIcon');
                const videoCategoryElement = document.getElementById('videoCategory');
                const liveIndicator = document.getElementById('liveIndicator');
                const videoDescriptionElement = document.getElementById('videoDescription');
                const channelNameElement = document.getElementById('channelName');
                const channelAvatarElement = document.getElementById('channelAvatar');

                if (isOffline) {
                    videoTitleElement.innerText = 'YouTube Tab Closed';
                    nowPlayingElement.classList.add('offline');
                    videoThumbnailElement.classList.add('offline-thumbnail');
                    clearExistingInterval();
                    document.getElementById('time-elapsed').innerText = `Time Elapsed: --:--`;
                    document.getElementById('total-duration').innerText = `Total Duration: --:--`;
                    pausedIcon.style.display = 'none';
                    const timeRemaining = document.getElementById('time-remaining');
                    if (timeRemaining) {
                        timeRemaining.style.display = 'none';
                    }
                    offlineIndicator.style.display = 'block';
                } else {
                    nowPlayingElement.classList.remove('offline');
                    videoThumbnailElement.classList.remove('offline-thumbnail');
                    offlineIndicator.style.display = 'none';

                    const videoID = extractYouTubeVideoID(videoUrl);
                    if (!videoID) {
                        return;
                    }

                    previousVideoData = {
                        title: title || 'No video playing',
                        url: videoUrl,
                        thumbnail: `https://img.youtube.com/vi/${videoID}/hqdefault.jpg`
                    };

                    videoTitleElement.innerText = previousVideoData.title;
                    videoThumbnailElement.src = previousVideoData.thumbnail;
                    videoThumbnailElement.alt = previousVideoData.title;

                    // Added loading="lazy" to videoThumbnail
                    videoThumbnailElement.setAttribute('loading', 'lazy');

                    // Update Video Description
                    // Assuming 'description' is part of the data
                    if (data.description) {
                        videoDescriptionElement.innerText = data.description;
                    }

                    // Update Video Category
                    const categoryName = categories[categoryId] || 'Uncategorized';
                    videoCategoryElement.innerText = categoryName;

                    // Update Live Stream Indicator
                    if (liveBroadcastContent === 'live') {
                        liveIndicator.style.display = 'block';
                    } else {
                        liveIndicator.style.display = 'none';
                    }

                    // Update Channel Information
                    if (data.channelName) {
                        channelNameElement.innerText = data.channelName;
                    }
                    if (data.channelAvatarUrl) {
                        channelAvatarElement.src = data.channelAvatarUrl;
                        channelAvatarElement.alt = `${data.channelName} Avatar`;
                        channelAvatarElement.setAttribute('loading', 'lazy');
                    }

                    if (videoUrl.includes("youtube.com/") && !videoUrl.includes("/watch")) {
                        clearExistingInterval();
                        isBrowsing = true;
                        document.getElementById('time-elapsed').innerText = `Time Elapsed: --:--`;
                        document.getElementById('total-duration').innerText = `Total Duration: --:--`;
                        pausedIcon.style.display = 'none';
                        const timeRemaining = document.getElementById('time-remaining');
                        if (timeRemaining) {
                            timeRemaining.style.display = 'none';
                        }
                    } else {
                        isBrowsing = false;
                        fetchYouTubeVideoDetails(videoID).then((duration) => {
                            if (duration) {
                                videoDuration = duration;
                                videoStartTime = Date.now() - (currentTime * 1000);
                                clearExistingInterval();
                                isVideoPaused = isPaused;
                                if (!isVideoPaused) {
                                    intervalID = setInterval(updateProgressBar, 1000);
                                }
                                document.getElementById('total-duration').innerText = `Total Duration: ${formatTime(videoDuration)}`;
                                const timeRemaining = document.getElementById('time-remaining');
                                if (timeRemaining) {
                                    timeRemaining.style.display = 'none';
                                }
                            }
                        });
                    }

                    if (isPaused) {
                        pausedIcon.style.display = 'inline';
                    } else {
                        pausedIcon.style.display = 'none';
                    }
                }
            });

            function extractYouTubeVideoID(url) {
                const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=|youtube\.com\/shorts\/)([^#&?]*).*/;
                const match = url.match(regExp);
                return (match && match[2].length === 11) ? match[2] : null;
            }

            // Live Clock
            function updateClocks() {
                const now = new Date();
                const localTime = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
                document.getElementById('local-time').textContent = localTime;
                const currentDate = now.toLocaleDateString(undefined, { day: '2-digit', month: 'short', year: 'numeric' });
                document.getElementById('current-date').textContent = currentDate;
            }

            setInterval(updateClocks, 1000);
            updateClocks();

            // Weather Fetching
            async function fetchWeather() {
                try {
                    const response = await fetch(`${WEATHER_API_URL}?city=${encodeURIComponent(CITY_NAME)}`);
                    const data = await response.json();

                    if (data.error) {
                        throw new Error(data.error);
                    }

                    displayWeather(data);
                } catch (error) {
                    console.error('Error fetching weather data:', error);
                    document.getElementById('weather-description').innerText = 'Unable to fetch weather data.';
                    document.getElementById('temperature').innerText = '';
                    document.getElementById('humidity').innerText = '';
                    document.getElementById('wind-speed').innerText = '';
                }
            }

            function displayWeather(data) {
                if (!data || !data.weather) {
                    document.getElementById('weather-description').innerText = 'Weather data unavailable.';
                    return;
                }

                const description = data.weather[0].description;
                const temperature = Math.round(data.main.temp);
                const humidity = data.main.humidity;
                const windSpeed = data.wind.speed;
                const iconCode = data.weather[0].icon;
                const iconUrl = `https://openweathermap.org/img/wn/${iconCode}@2x.png`;
                const weatherMain = data.weather[0].main.toLowerCase();

                document.getElementById('weather-description').innerText = `Condition: ${description}`;
                document.getElementById('temperature').innerText = `Temperature: ${temperature}Â°C`;
                document.getElementById('humidity').innerText = `Humidity: ${humidity}%`;
                document.getElementById('wind-speed').innerText = `Wind: ${windSpeed} m/s`;

                let iconElement = document.getElementById('weather-icon');
                if (!iconElement) {
                    iconElement = document.createElement('img');
                    iconElement.id = 'weather-icon';
                    iconElement.alt = 'Weather Icon';
                    iconElement.setAttribute('loading', 'lazy'); // Added for performance optimization
                    document.querySelector('.weather-info').prepend(iconElement);
                }
                iconElement.src = iconUrl;
                iconElement.style.display = 'block';
            }

            fetchWeather();
            setInterval(fetchWeather, 3600000); // Refresh weather every hour

            // Progress Bar Functionality (Using Div)
            function updateProgress(newProgress) {
                const progressBar = document.getElementById('progress-bar');
                const timeElapsed = document.getElementById('time-elapsed');
                const formattedTime = formatTime((newProgress / 100) * videoDuration);

                if (progressBar && timeElapsed) {
                    progressBar.style.width = `${newProgress}%`;
                    timeElapsed.innerText = `Time Elapsed: ${formattedTime}`;
                    console.log(`Updated progress bar. Progress: ${newProgress}%, Time Elapsed: ${formattedTime}`);
                }
            }

            // Animation Loop for Video Progress
            function updateProgressBar() {
                if (!isVideoPaused && !isBrowsing && videoDuration > 0) {
                    const currentTimestamp = Date.now();
                    const elapsedTime = (currentTimestamp - videoStartTime) / 1000;
                    if (elapsedTime >= 0 && elapsedTime <= videoDuration) {
                        const progressPercent = (elapsedTime / videoDuration) * 100;
                        updateProgress(progressPercent);
                    } else {
                        clearExistingInterval();
                        updateProgress(100);
                    }
                }
            }

            // Handle Dynamic Prompts from Server
            socket.on('dynamicPrompt', (data) => {
                const promptContainer = document.getElementById('dynamic-prompt-container');
                const promptText = document.getElementById('dynamic-prompt-text');

                if (!promptContainer || !promptText) {
                    console.warn('Dynamic prompt elements not found.');
                    return;
                }

                promptText.innerText = data.message || "A new prompt has arrived!";
                promptContainer.style.display = 'block';

                setTimeout(() => {
                    promptContainer.style.display = 'none';
                }, 5000);

                const closePromptButton = document.getElementById('close-prompt');
                if (closePromptButton) {
                    closePromptButton.addEventListener('click', () => {
                        promptContainer.style.display = 'none';
                    });
                }
            });

            // Log All Socket Events (Optional for Debugging)
            socket.onAny((event, data) => {
                console.log(`Received event: ${event}, Data:`, data);
            });
        });
    </script>

    <!-- Animated Background Canvas -->
    <script>
        const canvas = document.getElementById("techCanvas");
        const ctx = canvas.getContext("2d");
        let width = window.innerWidth;
        let height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;

        window.addEventListener('resize', () => {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
        });

        // Star and shooting star generation
        class Star {
            constructor(x, y, radius, color) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.color = color;
                this.speed = Math.random() * 0.3;
                this.brightness = Math.random() * 0.5 + 0.5;
                this.twinkleSpeed = Math.random() * 0.05 + 0.01;
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.brightness;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                ctx.fill();
                ctx.restore();
            }

            update() {
                this.x -= this.speed;
                if (this.x < 0) this.x = width;
                this.brightness += this.twinkleSpeed;
                if (this.brightness > 1 || this.brightness < 0.5) {
                    this.twinkleSpeed = -this.twinkleSpeed;
                }
                this.draw();
            }
        }

        class ShootingStar extends Star {
            constructor(x, y, radius, color) {
                super(x, y, radius, color);
                this.length = Math.random() * 150 + 50;
                this.speed = Math.random() * 10 + 5;
            }

            drawShootingStar() {
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 2;
                ctx.shadowBlur = 20;
                ctx.shadowColor = this.color;
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x + this.length, this.y - this.length * 0.5);
                ctx.stroke();
                ctx.restore();
            }

            update() {
                this.x -= this.speed;
                this.y += this.speed * 0.5;
                if (this.x < 0 || this.y > height) {
                    this.x = Math.random() * width;
                    this.y = Math.random() * height * 0.5;
                }
                this.drawShootingStar();
            }
        }

        const stars = [];
        const shootingStars = [];
        const nebulaColors = ['rgba(52, 7, 91, 0.8)', 'rgba(73, 48, 107, 0.7)', 'rgba(118, 24, 120, 0.6)', 'rgba(255, 144, 253, 0.4)', 'rgba(255, 255, 255, 0.1)'];

        // Create Stars
        function createStars(count) {
            for (let i = 0; i < count; i++) {
                const radius = Math.random() * 2;
                const x = Math.random() * width;
                const y = Math.random() * height;
                stars.push(new Star(x, y, radius, 'rgba(255, 255, 255, 0.9)'));
            }
        }

        // Create Shooting Stars
        function createShootingStars(count) {
            for (let i = 0; i < count; i++) {
                const radius = Math.random() * 1.5;
                const x = Math.random() * width;
                const y = Math.random() * height * 0.5;
                shootingStars.push(new ShootingStar(x, y, radius, 'rgba(255, 255, 255, 1)'));
            }
        }

        // Polished Nebula Effect
        function drawNebula() {
            ctx.save();
            ctx.globalCompositeOperation = "lighter";
            const gradient = ctx.createRadialGradient(width / 2, height / 2, 100, width / 2, height / 2, width / 2);

            nebulaColors.forEach((color, index) => {
                gradient.addColorStop(index / (nebulaColors.length - 1), color);
            });

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);
            ctx.restore();
        }

        function animate() {
            ctx.clearRect(0, 0, width, height);
            drawNebula();

            stars.forEach(star => star.update());
            shootingStars.forEach(shootingStar => shootingStar.update());

            requestAnimationFrame(animate);
        }

        createStars(200); // More stars for a polished look
        createShootingStars(5);
        animate();
    </script>

</body>

</html>
