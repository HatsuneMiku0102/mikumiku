<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MikuMiku | Home</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/styles.css">
</head>

<body>
    <!-- Three.js Canvas -->
    <canvas id="techCanvas"></canvas>

    <div class="page-container">
        <div class="title-bar">
            <div class="container">
                <div class="left-section"></div>
                <div class="center-section">
                    <div class="logo-title-wrapper">
                        <img src="/logo.webp" alt="Logo" class="logo" loading="lazy">
                        <h1 class="site-title" id="dynamicTitle">MikuMiku</h1>
                    </div>
                </div>
                <div class="right-section">
                    <div class="personality-section">
                        <div id="personalityCircle" class="personality-circle"></div>
                        <div id="personalityTextBox" class="personality-text-box">
                            <div id="personalityPhrase" class="personality-text-wrapper"></div>
                        </div>
                    </div>
                    <div class="dropdown">
                        <button class="dropdown-button">Menu</button>
                        <div class="dropdown-content">
                            <a href="/admin-login.html">Admin Login</a>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="now-playing-container">
            <div id="nowPlayingBox" class="now-playing">
                <div class="now-playing-sidebar">
                    <div class="sidebar-item">
                        <span>Channel:</span> <span id="channelName">Loading...</span>
                    </div>
                    <div class="sidebar-item">
                        <span>Views:</span> <span id="viewCount">Loading...</span>
                    </div>
                    <div class="sidebar-item">
                        <span>Likes:</span> <span id="likeCount">Loading...</span>
                    </div>
                    <div class="sidebar-item">
                        <span>Uploaded:</span> <span id="publishedDate">Loading...</span>
                    </div>
                    <div class="sidebar-item video-category">
                        <span>Category:</span> <span id="videoCategory">Loading...</span>
                    </div>
                </div>

                <div class="video-section" style="position: relative;">
                    <div class="video-title-container">
                        <h2>Currently Playing</h2>
                        <p id="videoTitle">Loading...</p>
                    </div>

                    <div class="thumbnail-container" style="position: relative;">
                        <video id="videoThumbnail" class="video-thumbnail" preload="metadata" controls style="width: 100%; height: auto; display: none;">
                            Your browser does not support the video tag.
                        </video>
                        <img id="videoThumbnailImage" src="" alt="Thumbnail" class="video-thumbnail" loading="lazy">
                    </div>

                    <div id="offline-indicator" class="offline-indicator">I’m not on YouTube at the moment, soz :(</div>

                    <div class="progress-bar-container">
                        <div id="progressBar" class="progress-bar"></div>
                    </div>

                    <div id="timeElapsedContainer" class="time-elapsed"><span id="timeElapsed">0s</span></div>

                    <button class="toggle-description" id="toggleDescriptionButton">Show Description</button>

                    <div id="loadingSpinner" class="loading-spinner"></div>
                </div>
            </div>
        </div>

        <div id="descriptionModal" class="modal">
            <div class="modal-content">
                <span class="close-button" id="closeDescriptionButton">&times;</span>
                <h2>Description</h2>
                <p id="videoDescription">Loading description...</p>
            </div>
        </div>

        <div class="widgets-container">
            <div class="live-clock box-container">
                <h3>My Current Time</h3>
                <div class="clock-container">
                    <div class="clock">
                        <p id="local-time">--:--:--</p>
                        <p id="current-date">24 Sep 2024</p>
                    </div>
                </div>
            </div>

            <div class="weather-widget box-container">
                <h3>My Current Weather</h3>
                <div class="weather-info">
                    <img id="weather-icon" src="" alt="Weather Icon" loading="lazy" style="display: none;">
                    <p id="weather-description">Loading...</p>
                    <p id="temperature">--°C</p>
                    <p id="humidity">Humidity: --%</p>
                    <p id="wind-speed">Wind: -- m/s</p>
                </div>
            </div>
        </div>

        <div class="content-wrapper">
            <div class="now-playing-about-wrapper">
                <div class="about box-container" id="aboutMe">
                    <h2>About Me</h2>
                    <p>Hey there, I'm Hystoriya, a 24-year-old developer. This is my personal website that I made for no apparent reason. If you find yourself here randomly, then hi :)</p>
                </div>
            </div>
        </div>

        <!-- Footer -->
        <footer class="footer">
            <div class="container">
                <p>&copy; 2024 MikuMiku. All rights reserved.</p>
                <button id="manageConsentFooter" class="manage-consent-button">Manage Cookie Preferences</button>
            </div>
        </footer>

        <div id="chat-box" class="chat-box">
            <div class="chat-header">
                <h3>Haru AI</h3>
                <button id="close-chat" class="close-chat">X</button>
            </div>
            <div id="chat-content" class="chat-content">
                <div class="message bot-message">Hi! I'm Haru, how can I help you today?</div>
            </div>
            <div class="chat-input-container">
                <input type="text" id="chat-input" class="chat-input" placeholder="Type your message..." />
                <button id="send-message" class="send-message">Send</button>
            </div>
        </div>

        <!-- Consent Modal -->
        <div id="consentModal" class="modal" aria-hidden="true" role="dialog" aria-labelledby="consentModalTitle" aria-describedby="consentModalDescription">
            <div class="modal-content">
                <span class="close-button" id="closeConsentModal">&times;</span>
                <h2 id="consentModalTitle">Cookie Consent</h2>
                <p id="consentModalDescription">
                    I use cookies stored in your browser to enhance your experience on my personal website. These cookies are essential for the website's functionality. By clicking "Accept," you consent to their use. You can also manage your cookie preferences in the "<a href="#" id="manageConsentModal" class="manage-consent-button">Manage Cookie Preferences</a>" section.
                </p>
                <div class="consent-buttons">
                    <button id="acceptConsent" class="consent-button">Accept</button>
                    <button id="declineConsent" class="consent-button">Decline</button>
                </div>
            </div>
        </div>

        <!-- Socket.io Client Library -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.1/socket.io.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.1/moment.min.js"></script>


        <!-- Import Haru AI script -->
        <script src="haru.js"></script>
            
        <script>
            // [Cookie Consent Script]
            (function () {
                'use strict';

                const CONFIG = {
                    consentCookieName: 'cookieConsent',
                    consentCookieExpiryDays: 365,
                    consentCookiePath: '/',
                    consentModalId: 'consentModal',
                    acceptButtonId: 'acceptConsent',
                    declineButtonId: 'declineConsent',
                    manageButtonIds: ['manageConsentModal', 'manageConsentFooter'],
                    closeButtonId: 'closeConsentModal',
                    cookieCategories: {
                        necessary: {
                            enabled: true,
                            description: 'Necessary cookies enable core functionalities and security features of the website.'
                        }
                    },
                    focusableSelectors: 'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])',
                };

                const consentModal = document.getElementById(CONFIG.consentModalId);
                const acceptButton = document.getElementById(CONFIG.acceptButtonId);
                const declineButton = document.getElementById(CONFIG.declineButtonId);
                const closeButton = document.getElementById(CONFIG.closeButtonId);
                const manageConsentButtons = CONFIG.manageButtonIds.map(id => document.getElementById(id));

                function setCookie(name, value, days, path = '/') {
                    let expires = "";
                    if (days) {
                        const date = new Date();
                        date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
                        expires = "; expires=" + date.toUTCString();
                    }
                    const secure = location.protocol === 'https:' ? "; Secure" : "";
                    const sameSite = "; SameSite=Lax";
                    document.cookie = name + "=" + (value || "") + expires + "; path=" + path + secure + sameSite;
                }

                function getCookie(name) {
                    const nameEQ = name + "=";
                    const ca = document.cookie.split(';');
                    for (let i = 0; i < ca.length; i++) {
                        let c = ca[i];
                        while (c.charAt(0) === ' ') c = c.substring(1, c.length);
                        if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
                    }
                    return null;
                }

                function eraseCookie(name, path = '/') {
                    document.cookie = name + '=; Max-Age=-99999999; path=' + path + ';';
                }

                function trapFocus(modal) {
                    const focusableElements = modal.querySelectorAll(CONFIG.focusableSelectors);
                    if (focusableElements.length === 0) return;
                    const firstFocusableElement = focusableElements[0];
                    const lastFocusableElement = focusableElements[focusableElements.length - 1];

                    function handleFocus(event) {
                        if (event.key === 'Tab') {
                            if (event.shiftKey) {
                                if (document.activeElement === firstFocusableElement) {
                                    event.preventDefault();
                                    lastFocusableElement.focus();
                                }
                            } else {
                                if (document.activeElement === lastFocusableElement) {
                                    event.preventDefault();
                                    firstFocusableElement.focus();
                                }
                            }
                        }
                        if (event.key === 'Escape') {
                            event.preventDefault();
                        }
                    }

                    modal.addEventListener('keydown', handleFocus);
                }

                function showModal() {
                    consentModal.classList.add('active');
                    document.body.classList.add('modal-active');
                    consentModal.setAttribute('aria-hidden', 'false');

                    const focusableElements = consentModal.querySelectorAll(CONFIG.focusableSelectors);
                    if (focusableElements.length) {
                        focusableElements[0].focus();
                    }

                    trapFocus(consentModal);
                }

                function hideModal() {
                    consentModal.classList.remove('active');
                    document.body.classList.remove('modal-active');
                    consentModal.setAttribute('aria-hidden', 'true');
                }

                function initConsentModal() {
                    const existingConsent = getCookie(CONFIG.consentCookieName);

                    if (!existingConsent) {
                        showModal();
                    } else {
                        applyConsent(existingConsent);
                    }

                    acceptButton.addEventListener('click', function () {
                        setCookie(CONFIG.consentCookieName, JSON.stringify({
                            necessary: true
                        }), CONFIG.consentCookieExpiryDays, CONFIG.consentCookiePath);
                        hideModal();
                        initializeCookies();
                    });

                    declineButton.addEventListener('click', function () {
                        setCookie(CONFIG.consentCookieName, JSON.stringify({
                            necessary: false
                        }), CONFIG.consentCookieExpiryDays, CONFIG.consentCookiePath);
                        hideModal();
                        disableCookies();
                    });

                    manageConsentButtons.forEach(button => {
                        if (button) {
                            button.addEventListener('click', function (event) {
                                event.preventDefault();
                                showModal();
                            });
                        }
                    });

                    closeButton.addEventListener('click', function () {
                        alert('Please make a choice regarding cookie usage.');
                    });

                    window.addEventListener('click', function (event) {
                        if (event.target === consentModal) {
                            alert('Please make a choice regarding cookie usage.');
                        }
                    });
                }

                function applyConsent(consentValue) {
                    try {
                        const consent = JSON.parse(consentValue);
                        if (consent.necessary) {
                            initializeCookies(consent);
                        } else {
                            disableCookies();
                        }
                    } catch (error) {
                        console.error('Error parsing consent cookie:', error);
                        showModal();
                    }
                }

                function initializeCookies(consent) {
                    console.log('Necessary cookies enabled.');
                }

                function disableCookies() {
                    console.log('Necessary cookies disabled.');
                }

                function areCookiesEnabled() {
                    const testCookie = 'test_cookie_consent';
                    setCookie(testCookie, 'test', 1);
                    const result = getCookie(testCookie) === 'test';
                    eraseCookie(testCookie);
                    return result;
                }

                function init() {
                    if (areCookiesEnabled()) {
                        initConsentModal();
                    } else {
                        console.warn('Cookies are disabled in this browser. Consent modal will not be displayed.');
                    }
                }

                document.addEventListener('DOMContentLoaded', init);
            })();
        </script>

        <script>
            // Now Playing Elements and Socket.IO Integration
            const socket = io("https://mikumiku.dev");
            let lastHeartbeatReceived = Date.now();
            let isSessionExpired = false;
            let browsingStartTime = null;
            let browsingInterval = null;

            const nowPlayingBox = document.getElementById("nowPlayingBox");
            const videoTitleElement = document.getElementById("videoTitle");
            const videoThumbnailImage = document.getElementById("videoThumbnailImage");
            const videoThumbnailElement = document.getElementById("videoThumbnail");
            const offlineIndicatorElement = document.getElementById("offline-indicator");
            const progressBarElement = document.getElementById("progressBar");
            const channelNameElement = document.getElementById("channelName");
            const viewCountElement = document.getElementById("viewCount");
            const likeCountElement = document.getElementById("likeCount");
            const publishedDateElement = document.getElementById("publishedDate");
            const videoCategoryElement = document.getElementById("videoCategory");
            const videoDescriptionElement = document.getElementById("videoDescription");
            const timeElapsedElement = document.getElementById("timeElapsed");

            function formatNumber(number) {
                if (typeof number === 'string') {
                    number = number.replace(/,/g, '');
                }
                const num = Number(number);
                return isNaN(num) ? "N/A" : num.toLocaleString();
            }

            function clearDisplay() {
                nowPlayingBox.classList.add("offline");
                offlineIndicatorElement.style.display = "block";
                videoTitleElement.textContent = "I’m not on YouTube at the moment, soz :(";
                videoThumbnailImage.src = "";
                videoThumbnailImage.style.display = "none";
                videoThumbnailElement.src = "";
                videoThumbnailElement.style.display = "none";
                channelNameElement.textContent = "";
                viewCountElement.textContent = "";
                likeCountElement.textContent = "";
                publishedDateElement.textContent = "";
                videoCategoryElement.textContent = "";
                progressBarElement.style.width = "0%";
                videoDescriptionElement.textContent = "";
                timeElapsedElement.style.display = "none";
            }

            function clearVideoPresence() {
                videoTitleElement.textContent = "";
                videoThumbnailImage.src = "";
                videoThumbnailImage.style.display = "none";
                videoThumbnailElement.src = "";
                videoThumbnailElement.style.display = "none";
                channelNameElement.textContent = "";
                viewCountElement.textContent = "";
                likeCountElement.textContent = "";
                publishedDateElement.textContent = "";
                videoCategoryElement.textContent = "";
                progressBarElement.style.width = "0%";
                videoDescriptionElement.textContent = "";
            }

            function reinitializeSession() {
                console.warn("[Client] Reinitializing session due to mismatch or timeout.");
                clearDisplay();
                isSessionExpired = true;
            }

            function formatTimeElapsed(seconds) {
                const hours = Math.floor(seconds / 3600);
                const minutes = Math.floor((seconds % 3600) / 60);
                const remainingSeconds = seconds % 60;

                if (hours > 0) {
                    return `${hours}h ${minutes}m ${remainingSeconds}s`;
                } else if (minutes > 0) {
                    return `${minutes}m ${remainingSeconds}s`;
                } else {
                    return `${remainingSeconds}s`;
                }
            }

            function displayVideoPresence(data) {
                lastHeartbeatReceived = Date.now();
                nowPlayingBox.classList.remove("offline");
                offlineIndicatorElement.style.display = "none";

                videoTitleElement.textContent = data.title || "Unknown Title";

                if (data.thumbnail) {
                    videoThumbnailImage.src = data.thumbnail;
                    videoThumbnailImage.style.display = "block";
                    videoThumbnailElement.style.display = "none";
                } else {
                    videoThumbnailImage.src = "";
                    videoThumbnailElement.style.display = "none";
                }

                channelNameElement.textContent = data.channelTitle || "Unknown Channel";
                viewCountElement.textContent = `Views: ${formatNumber(data.viewCount)}` || "Views: N/A";
                likeCountElement.textContent = `Likes: ${formatNumber(data.likeCount)}` || "Likes: N/A";

                if (data.publishedAt) {
                    const publishedDate = new Date(data.publishedAt);
                    publishedDateElement.textContent = `Published on: ${publishedDate.toLocaleDateString()}` || "Published on: N/A";
                } else {
                    publishedDateElement.textContent = "Published on: N/A";
                }

                videoCategoryElement.textContent = `Category: ${data.category}` || "Category: N/A";
                videoDescriptionElement.textContent = data.description || "No description available.";
                handleRealTimeProgress(data);
                timeElapsedElement.style.display = "none";

                if (data.videoSrc) {
                    videoThumbnailElement.src = data.videoSrc;
                    videoThumbnailElement.style.display = "block";
                    videoThumbnailImage.style.display = "none";
                } else {
                    videoThumbnailElement.style.display = "none";
                    videoThumbnailImage.style.display = "block";
                }
            }

            function handleRealTimeProgress(data) {
                if (data.duration && data.currentTime) {
                    const progressPercentage = (data.currentTime / data.duration) * 100;
                    progressBarElement.style.width = `${progressPercentage}%`;
                } else {
                    progressBarElement.style.width = "0%";
                }
            }

            function displayBrowsingPresence(data) {
                lastHeartbeatReceived = Date.now();
                nowPlayingBox.classList.remove("offline");
                offlineIndicatorElement.style.display = "none";

                clearVideoPresence();

                videoTitleElement.textContent = data.title || "Browsing YouTube";
                videoThumbnailImage.src = data.thumbnail || "https://i.postimg.cc/GpgNPv0R/custom-browsing-thumbnail.png";
                videoThumbnailImage.style.display = "block";
                videoThumbnailElement.style.display = "none";
                channelNameElement.textContent = "Browsing...";
                videoDescriptionElement.textContent = data.description || "Browsing videos on YouTube";
                progressBarElement.style.width = "0%";

                if (data.timeElapsed !== undefined) {
                    timeElapsedElement.textContent = `Time Elapsed: ${formatTimeElapsed(data.timeElapsed)}`;
                    timeElapsedElement.style.display = "block";
                }
            }

            function updateBrowsingPresence() {
                if (browsingStartTime !== null) {
                    const timeElapsed = Math.floor((Date.now() - browsingStartTime) / 1000);
                    timeElapsedElement.textContent = `Time Elapsed: ${formatTimeElapsed(timeElapsed)}`;
                    timeElapsedElement.style.display = "block";

                    const browsingData = {
                        title: 'YouTube',
                        description: 'Browsing videos',
                        thumbnail: 'https://i.postimg.cc/GpgNPv0R/custom-browsing-thumbnail.png',
                        timeElapsed: timeElapsed,
                        presenceType: 'browsing'
                    };
                    socket.emit('updateBrowsingPresence', browsingData);
                }
            }

            function startBrowsingPresence() {
                if (browsingStartTime === null) {
                    browsingStartTime = Date.now();
                }
                if (!browsingInterval) {
                    browsingInterval = setInterval(updateBrowsingPresence, 5000);
                }
            }

            function stopBrowsingPresence() {
                if (browsingInterval) {
                    clearInterval(browsingInterval);
                    browsingInterval = null;
                }
                browsingStartTime = null;
            }

            socket.on("connect", () => {
                console.log("[Socket.IO] Connected to server.");
                isSessionExpired = false;
                socket.emit('requestLatestData');
            });

            socket.on("presenceUpdate", (data) => {
                if (isSessionExpired) {
                    console.warn("[Client] Ignoring presenceUpdate due to expired session.");
                    return;
                }

                console.log("[Socket.IO] Received presenceUpdate:", data);
                lastHeartbeatReceived = Date.now();

                if (data.presenceType === 'video') {
                    stopBrowsingPresence();
                    displayVideoPresence(data);
                } else if (data.presenceType === 'browsing') {
                    displayBrowsingPresence(data);
                    startBrowsingPresence();
                } else {
                    clearDisplay();
                }
            });

            socket.on("reinitializeSession", (data) => {
                console.warn(`[Socket.IO] Received reinitializeSession: ${JSON.stringify(data)}`);
                reinitializeSession();
            });

            socket.on("sessionExpired", (data) => {
                console.warn(`[Socket.IO] Session expired for video ID: ${data.videoId}`);
                reinitializeSession();
            });

            socket.on("disconnect", () => {
                console.warn("[Socket.IO] Disconnected from server.");
                stopBrowsingPresence();
                clearDisplay();
            });

            setInterval(() => {
                if (Date.now() - lastHeartbeatReceived > 60000) {
                    console.warn("[Heartbeat] No heartbeat received in the last 60 seconds. Marking as offline.");
                    clearDisplay();
                }
            }, 5000);

            // Modal Toggle Logic
            const descriptionModal = document.getElementById("descriptionModal");
            const closeDescriptionButton = document.getElementById("closeDescriptionButton");
            const toggleDescriptionButton = document.getElementById("toggleDescriptionButton");

            toggleDescriptionButton.addEventListener("click", function () {
                if (descriptionModal.style.display === "block") {
                    descriptionModal.style.display = "none";
                    toggleDescriptionButton.textContent = "Show Description";
                } else {
                    descriptionModal.style.display = "block";
                    toggleDescriptionButton.textContent = "Hide Description";
                }
            });

            closeDescriptionButton.addEventListener("click", function () {
                descriptionModal.style.display = "none";
                toggleDescriptionButton.textContent = "Show Description";
            });

            window.addEventListener("click", function (event) {
                if (event.target === descriptionModal) {
                    descriptionModal.style.display = "none";
                    toggleDescriptionButton.textContent = "Show Description";
                }
            });

            // Clock Update Script
            function updateClocks() {
                const now = new Date();
                const localTime = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
                const localTimeElement = document.getElementById('local-time');
                if (localTimeElement) localTimeElement.textContent = localTime;
                const currentDate = now.toLocaleDateString(undefined, { day: '2-digit', month: 'short', year: 'numeric' });
                const currentDateElement = document.getElementById('current-date');
                if (currentDateElement) currentDateElement.textContent = currentDate;
            }

            setInterval(updateClocks, 1000);
            updateClocks();

            // Weather Update Script
            const CITY_NAME = 'Leeds';
            async function fetchWeather() {
                try {
                    const response = await fetch(`/api/weather?city=${encodeURIComponent(CITY_NAME)}`);
                    const data = await response.json();

                    if (data.error) {
                        throw new Error(data.error);
                    }

                    displayWeather(data);
                } catch (error) {
                    console.error('Error fetching weather data:', error);
                    const weatherIconElement = document.getElementById('weather-icon');
                    if (weatherIconElement) weatherIconElement.style.display = 'none';
                    document.getElementById('weather-description').innerText = 'Unable to fetch weather data.';
                }
            }

            function displayWeather(data) {
                const description = data.weather[0].description;
                const temperature = Math.round(data.main.temp);
                const humidity = data.main.humidity;
                const windSpeed = data.wind.speed;
                const iconCode = data.weather[0].icon;
                const iconUrl = `https://openweathermap.org/img/wn/${iconCode}@2x.png`;

                document.getElementById('weather-description').innerText = `Condition: ${description}`;
                document.getElementById('temperature').innerText = `Temperature: ${temperature}°C`;
                document.getElementById('humidity').innerText = `Humidity: ${humidity}%`;
                document.getElementById('wind-speed').innerText = `Wind: ${windSpeed} m/s`;

                const weatherIconElement = document.getElementById('weather-icon');
                if (weatherIconElement) {
                    weatherIconElement.src = iconUrl;
                    weatherIconElement.style.display = 'block';
                }
            }

            setInterval(fetchWeather, 3600000); // Update every hour
            fetchWeather();
        </script>
                
    
        <script type="module">
        import * as THREE from '/js/three.module.min.js';
        import { EffectComposer } from '/js/postprocessing/EffectComposer.js';
        import { RenderPass } from '/js/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from '/js/postprocessing/UnrealBloomPass.js';
        import { FXAAShader } from '/js/shaders/FXAAShader.js';
        import { ShaderPass } from '/js/postprocessing/ShaderPass.js';
        
        // Custom Chromatic Aberration Shader
        const ChromaticAberrationShader = {
            uniforms: {
                "tDiffuse": { value: null },
                "offset": { value: new THREE.Vector2(0.00075, 0.00075) } // Reduced offset for subtler effect
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform vec2 offset;
                varying vec2 vUv;
        
                void main() {
                    vec4 color = vec4(0.0);
                    vec2 redOffset = vUv + offset;
                    vec2 greenOffset = vUv;
                    vec2 blueOffset = vUv - offset;
        
                    color.r = texture2D(tDiffuse, redOffset).r;
                    color.g = texture2D(tDiffuse, greenOffset).g;
                    color.b = texture2D(tDiffuse, blueOffset).b;
                    color.a = texture2D(tDiffuse, vUv).a;
        
                    gl_FragColor = color;
                }
            `
        };
        
        const canvas = document.getElementById('techCanvas');
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.5; // Adjusted for a more balanced overall lighting effect
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 20000);
        camera.position.set(0, 0, 3000);
        
        // Load Background Texture with Vignette Effect to Enhance Realism
        const textureLoader = new THREE.TextureLoader();
        textureLoader.load('/textures/pillar.webp', (texture) => {
            texture.colorSpace = THREE.SRGBColorSpace;
            texture.encoding = THREE.sRGBEncoding; // Ensure correct brightness
            scene.background = texture;
        }, undefined, (err) => {
            console.error('Error loading background texture:', err);
            scene.background = new THREE.Color(0x303030);
        });
        
        // Adding Ambient and Hemisphere Light for Overall Illumination
        const ambientLight = new THREE.AmbientLight(0x404040, 1.8);
        scene.add(ambientLight);
        
        const hemisphereLight = new THREE.HemisphereLight(0xddddff, 0x555555, 0.5);
        scene.add(hemisphereLight);
        
        // Set camera to see layers 0 and 1
        camera.layers.enable(0); // Background and main scene
        camera.layers.enable(1); // Comet effects
        
        // Load Star Textures
        const starTextures = [
            textureLoader.load('/textures/stars 001.png'),
            textureLoader.load('/textures/stars 002.png'),
            textureLoader.load('/textures/stars 003.png'),
            textureLoader.load('/textures/stars 004.png'),
            textureLoader.load('/textures/stars 005.png'),
            textureLoader.load('/textures/stars 006.png')
        ];
        
        // Function to add stars to the background seamlessly
        function createStarField() {
            const starCount = 50; // Number of stars in the field
        
            for (let i = 0; i < starCount; i++) {
                const texture = starTextures[Math.floor(Math.random() * starTextures.length)];
                const starMaterial = new THREE.SpriteMaterial({
                    map: texture,
                    blending: THREE.AdditiveBlending,
                    transparent: true,
                    opacity: 0.8  // Adjust opacity to blend into background
                });
        
                const star = new THREE.Sprite(starMaterial);
                star.scale.set(200 + Math.random() * 150, 200 + Math.random() * 150, 1); // Randomize size
                star.position.set(
                    Math.random() * window.innerWidth * 2 - window.innerWidth,  // Spread across X-axis
                    Math.random() * window.innerHeight * 2 - window.innerHeight, // Spread across Y-axis
                    -2000 + Math.random() * 1000                                // Spread behind the main scene
                );
        
                scene.add(star);
            }
        }
        
        // Comet Variables
        const cometTexture = textureLoader.load('/textures/comet1.png');
        const cometCount = 8;
        const comets = [];
        
        // Particle Variables for Cosmic Dust
        const particles = [];
        const particleCount = 200;  // Number of cosmic dust particles
        const particleTexture = textureLoader.load('/textures/particle_clouds.png');
        
        // Function to create a new comet with diverse properties
        function createComet() {
            const cometMaterial = new THREE.SpriteMaterial({
                map: cometTexture,
                blending: THREE.AdditiveBlending,
                transparent: true,
                opacity: 0.9,
                depthWrite: false,
            });
        
            const comet = new THREE.Sprite(cometMaterial);
            const cometSize = 150 + Math.random() * 200;
            comet.scale.set(cometSize, cometSize, 1);
            comet.color = new THREE.Color(0xffffff);
            comet.material.color = comet.color;
        
            // Adding bright light to comet
            const cometLight = new THREE.PointLight(comet.color, 4.0 + Math.random() * 3.0, 4000 + Math.random() * 2000, 2);
            cometLight.position.set(0, 0, 0);
            cometLight.castShadow = true;
            comet.add(cometLight);
        
            comet.light = cometLight;
        
            // Create a spotlight for lighting up the background
            const spotLight = new THREE.SpotLight(0xffffff, 1.0, 5000, Math.PI / 8, 0.5);
            spotLight.castShadow = true;
            spotLight.target = comet;
            scene.add(spotLight);
            comet.spotLight = spotLight;
        
            // Assign comet, light, and spotlight to layer 1
            comet.layers.set(1);
            cometLight.layers.set(1);
            spotLight.layers.set(1);
        
            resetComet(comet);
            comets.push(comet);
            scene.add(comet);
        }
        
        // Function to create cosmic dust particles in a 3D volume
        function createParticle() {
            const particleMaterial = new THREE.SpriteMaterial({
                map: particleTexture,
                blending: THREE.AdditiveBlending,
                transparent: true,
                opacity: 0.5,  // Lower opacity for cosmic dust effect
                depthWrite: false,
            });
        
            const particle = new THREE.Sprite(particleMaterial);
            const particleSize = 5 + Math.random() * 10;  // Smaller size to represent cosmic dust
            particle.scale.set(particleSize, particleSize, 1);
            
            // Position particles in a 3D space surrounding the scene
            particle.position.set(
                Math.random() * window.innerWidth * 2 - window.innerWidth,
                Math.random() * window.innerHeight * 2 - window.innerHeight,
                Math.random() * 3000 - 1500  // Spread particles in a depth range in the scene
            );
        
            // Add a very soft light to the particle for a subtle glowing effect
            const particleLight = new THREE.PointLight(0xffffff, 0.2, 200);
            particleLight.position.set(0, 0, 0);
            particle.add(particleLight);
        
            particle.light = particleLight;
            
            scene.add(particle);
            particles.push(particle);
        }
        
        // Function to reset comet properties
        function resetComet(comet) {
            comet.position.set(
                Math.random() * window.innerWidth * 2 - window.innerWidth, // Spread comets across entire horizontal width
                window.innerHeight + 500,  // Position comets above the visible area
                Math.random() * 1000 - 500  // Add depth variation to the comets
            );
            const velocityX = -500 - Math.random() * 300;
            const velocityY = -1000 - Math.random() * 600;
            comet.velocity = new THREE.Vector3(velocityX, velocityY, 0);
            comet.lifespan = 20.0 + Math.random() * 20.0;
            comet.burningOut = false;
        
            comet.light.intensity = 4.0 + Math.random() * 3.0;
        
            comet.material.opacity = 0.0;
            const cometSize = 150 + Math.random() * 200;
            comet.scale.set(cometSize, cometSize, 1);
            comet.rotation.z = Math.atan2(comet.velocity.y, comet.velocity.x);
        }
        
        // Function to update comet positions and properties
        function updateComets(delta) {
            comets.forEach((comet) => {
                comet.position.add(comet.velocity.clone().multiplyScalar(delta));
        
                // Rotate the comet to align with its direction of travel
                const angle = Math.atan2(comet.velocity.y, comet.velocity.x);
                comet.rotation.z = angle;
        
                // Move the spotlight with the comet to simulate background lighting
                if (comet.spotLight) {
                    comet.spotLight.position.copy(comet.position);
                    comet.spotLight.position.z += 500;
                    comet.spotLight.intensity = 1.0 + Math.sin(clock.getElapsedTime() * 2) * 0.5;
                }
        
                // Update lifespan and adjust light intensity
                comet.lifespan -= delta;
        
                if (comet.lifespan > 15.0) {
                    comet.material.opacity = Math.min(1.0, comet.material.opacity + delta * 0.3);
                } else if (comet.lifespan > 5.0) {
                    comet.light.intensity = 5.0 + Math.sin(clock.getElapsedTime() * 40) * 1.0;
                } else if (!comet.burningOut) {
                    comet.burningOut = true;
                    comet.material.color.set(0xffffff);
                    comet.light.color.set(0xffffff);
                    comet.scale.set(comet.scale.x * 1.2, comet.scale.y * 1.2, 1);
                    comet.light.intensity = 6.0;
                } else {
                    comet.material.opacity = Math.max(0, comet.material.opacity - delta * 0.1);
                    comet.light.intensity = Math.max(0, comet.light.intensity - delta * 1.5);
                    if (comet.material.opacity <= 0) {
                        resetComet(comet);
                    }
                }
        
                // Reset comet if it moves out of bounds
                if (comet.position.x < -window.innerWidth || comet.position.y < -window.innerHeight * 1.5) {
                    resetComet(comet);
                }
            });
        }
        
        // Function to update particle positions for subtle movement and reactive effects
        function updateParticles(delta) {
            particles.forEach((particle) => {
                // Add subtle random movement to each particle to simulate floating
                particle.position.x += (Math.random() - 0.5) * 0.5 * delta;
                particle.position.y += (Math.random() - 0.5) * 0.5 * delta;
                particle.position.z += (Math.random() - 0.5) * 0.2 * delta;
        
                // Add subtle movement based on camera position for parallax effect in 3D space
                particle.position.x += mouseX * 0.02 * delta;
                particle.position.y += mouseY * 0.02 * delta;
            });
        }
        
        // Function to adjust comet light intensity based on proximity to particles
        function updateCometLightIntensity() {
            comets.forEach((comet) => {
                let maxIntensity = 4.0;  // Default comet intensity
                particles.forEach((particle) => {
                    const distance = comet.position.distanceTo(particle.position);
                    if (distance < 500) {  // Threshold for effect
                        maxIntensity = Math.max(maxIntensity, 4.0 + (500 - distance) / 100);  // Increase intensity closer to particle
                    }
                });
        
                // Apply the intensity to the comet's light
                comet.light.intensity = maxIntensity;
            });
        }
        
        // Interactive camera movement based on mouse position
        let mouseX = 0;
        let mouseY = 0;
        document.addEventListener('mousemove', (event) => {
            mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
        });
        
        // Function to update the camera position based on mouse movement
        function updateCamera() {
            camera.position.x += (mouseX * 500 - camera.position.x) * 0.05;
            camera.position.y += (mouseY * 300 - camera.position.y) * 0.05;
        }
        
        // Function to spawn comets one by one with random delay
        function spawnComets() {
            if (comets.length < cometCount) {
                createComet();
                const randomDelay = 1500 + Math.random() * 2000;
                setTimeout(spawnComets, randomDelay);
            }
        }
        
        // Spawn particles and stars at the beginning
        for (let i = 0; i < particleCount; i++) {
            createParticle();
        }
        createStarField();
        
        const clock = new THREE.Clock();
        
        // Animation function
        function animate() {
            requestAnimationFrame(animate);
        
            const delta = clock.getDelta();
        
            // Update comets, particles, and camera
            updateComets(delta);
            updateParticles(delta);
            updateCometLightIntensity();  // Update comet light intensity based on proximity to particles
            updateCamera();
            composer.render();
        }
        
        // Postprocessing setup
        const renderScene = new RenderPass(scene, camera);
        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        
        // Bloom Pass
        const bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            2.0,  // Adjusted strength for more subtle glowing effect
            0.6,  // Bloom radius
            0.9   // Threshold for glow effect
        );
        composer.addPass(bloomPass);
        
        // Chromatic Aberration Pass
        
        const chromaticAberrationPass = new ShaderPass(ChromaticAberrationShader);
        chromaticAberrationPass.uniforms['offset'].value = new THREE.Vector2(0.00075, 0.00075); // Reduced strength of the chromatic aberration
        composer.addPass(chromaticAberrationPass);
        
        
         // FXAA Pass for Anti-Aliasing
        const fxaaPass = new ShaderPass(FXAAShader);
        fxaaPass.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight);
        composer.addPass(fxaaPass);
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            fxaaPass.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight);
        });
        
        // Start comet spawning and animation
        spawnComets();
        animate();
        </script>















    </body>
</html>
