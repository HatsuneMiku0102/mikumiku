<!DOCTYPE html>
<html lang="en">

<head>
    <!-- Meta Tags and Title -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MikuMiku | Home</title>

    <!-- Fonts and Stylesheets -->
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <!-- Include FontAwesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Main Stylesheet -->
    <link rel="stylesheet" href="/styles.css">

    <!-- JavaScript Files -->
    <script src="/clockwork.js" defer></script>

    <!-- Three.js Canvas -->
    <canvas id="techCanvas"></canvas>

    <div class="page-container">
        <!-- Title Bar -->
        <header class="title-bar" id="titleBar">
            <div class="container">
                <!-- Center Section for Logo and Site Title -->
                <div class="logo-title-wrapper">
                    <a href="/" aria-label="Home">
                        <img src="/logo.webp" alt="Logo" class="logo" loading="lazy">
                    </a>
                    <h1 class="site-title" id="dynamicTitle">MikuMiku</h1>
                </div>

                <!-- Right Section for Personality and Menu -->
                <div class="right-section">
                    <div class="personality-section">
                        <button id="personalityCircle" class="personality-circle" aria-label="Personality Info" title="Your Personality">
                            <i class="fas fa-user-circle"></i>
                        </button>
                        <div id="personalityTextBox" class="personality-text-box">
                            <div id="personalityPhrase" class="personality-text-wrapper">Your Personality Trait</div>
                        </div>
                    </div>
                    <!-- Menu Button -->
                    <button class="menu-button" id="menuButton" aria-label="Open Menu">
                        <i class="fas fa-bars"></i>
                    </button>
                </div>
            </div>
        </header>
        <!-- End of Title Bar -->

        <!-- Fullscreen Overlay Menu -->
        <nav class="overlay-menu" id="overlayMenu">
            <button class="close-overlay" id="closeOverlay" aria-label="Close Menu">
                <i class="fas fa-times"></i>
            </button>
            <div class="overlay-content">
                <a href="/admin-login.html" aria-label="Admin Login"><i class="fas fa-user-lock"></i> Admin Login</a>
                <a href="#aboutMe" aria-label="About Me"><i class="fas fa-info-circle"></i> About Me</a>
                <!-- Additional menu items with icons -->
            </div>
        </nav>
        <!-- End of Fullscreen Overlay Menu -->

        <!-- Now Playing Section -->
        <section class="now-playing-container">
            <div id="nowPlayingBox" class="now-playing" style="position: relative;">
                <!-- Channel Info on the Left Side -->
                <aside class="now-playing-sidebar">
                    <div class="sidebar-item">
                        <span><i class="fas fa-tv"></i> Channel:</span> <span id="channelName">Loading...</span>
                    </div>
                    <div class="sidebar-item">
                        <span><i class="fas fa-eye"></i> Views:</span> <span id="viewCount">Loading...</span>
                    </div>
                    <div class="sidebar-item">
                        <span><i class="fas fa-thumbs-up"></i> Likes:</span> <span id="likeCount">Loading...</span>
                    </div>
                    <div class="sidebar-item">
                        <span><i class="fas fa-calendar-day"></i> Uploaded:</span> <span id="publishedDate">Loading...</span>
                    </div>
                    <div class="sidebar-item video-category">
                        <span><i class="fas fa-tag"></i> Category:</span> <span id="videoCategory">Loading...</span>
                    </div>

                    <!-- Divider Between Channel Info and Clock -->
                    <hr class="divider">

                    <!-- Clock Section -->
                    <section class="clock-section">
                        <p id="greeting" class="greeting"><i class="fas fa-sun"></i> Good morning!</p>
                        <div class="clocks-container">
                            <!-- Digital Clock -->
                            <div class="digital-clock">
                                <p id="local-time" class="local-time"><i class="fas fa-clock"></i> --:--:--</p>
                                <p id="current-date" class="current-date"><i class="fas fa-calendar-alt"></i> 24 September 2024</p>
                                <p id="day-of-week" class="day-of-week"><i class="fas fa-calendar-day"></i> Thursday</p>
                                <p id="time-zone" class="time-zone"><i class="fas fa-globe"></i> Time Zone: UTC</p>
                            </div>
                            <!-- Analog Clock -->
                            <div class="analog-clock-container">
                                <canvas id="analog-clock" width="200" height="200" aria-label="Analog Clock"></canvas>
                            </div>
                        </div>
                        <p id="last-visit-message" class="last-visit-message"><i class="fas fa-history"></i> Welcome back!</p>
                    </section>
                </aside>
                <!-- End of Channel Info -->

                <!-- Video Section in the Center -->
                <div class="video-section">
                    <div class="video-title-container">
                        <h2>Currently Playing</h2>
                        <p id="videoTitle">Loading...</p>
                    </div>

                    <div class="thumbnail-container">
                        <video id="videoThumbnail" class="video-thumbnail" preload="metadata" controls aria-label="Currently Playing Video">
                            Your browser does not support the video tag.
                        </video>
                        <img id="videoThumbnailImage" src="" alt="Thumbnail" class="video-thumbnail" loading="lazy">
                    </div>

                    <div id="offline-indicator" class="offline-indicator">
                        <i class="fas fa-signal-slash"></i> I’m currently offline
                    </div>

                    <!-- Live Indicator SVG -->
                    <svg id="liveIcon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="40" height="40" aria-label="Live Stream Indicator">
                        <circle cx="12" cy="12" r="10" fill="#FF0000" opacity="0.8" />
                        <text x="12" y="16" text-anchor="middle" fill="#FFFFFF" font-size="6" font-family="Arial" dy=".3em">LIVE</text>
                    </svg>

                    <div class="progress-bar-container">
                        <div id="progressBar" class="progress-bar"></div>
                    </div>

                    <div id="timeElapsedContainer" class="time-elapsed">
                        <i class="fas fa-clock"></i> <span id="timeElapsed">0s</span>
                    </div>

                    <button class="toggle-description" id="toggleDescriptionButton" aria-label="Toggle Description">
                        <i class="fas fa-info-circle"></i> Show Description
                    </button>

                    <div id="loadingSpinner" class="loading-spinner" aria-label="Loading">
                        <i class="fas fa-spinner fa-spin"></i>
                    </div>
                </div>
                <!-- End of Video Section -->

                <!-- Divider Between Now Playing and Weather -->
                <hr class="divider">

                <!-- Weather Section on the Right Side -->
                <aside class="weather-section">
                    <img id="weather-icon" src="" alt="Weather Icon" class="weather-icon" loading="lazy">
                    <p id="weather-description" class="weather-description"><i class="fas fa-cloud"></i> Loading...</p>
                    <p id="temperature" class="temperature"><i class="fas fa-thermometer-half"></i> --°C</p>
                    <p id="humidity" class="humidity"><i class="fas fa-tint"></i> Humidity: --%</p>
                    <p id="wind-speed" class="wind-speed"><i class="fas fa-wind"></i> Wind: -- m/s</p>
                </aside>
                <!-- End of Weather Section -->
            </div>
        </section>
        <!-- End of Now Playing Section -->

        <!-- About Section -->
        <section class="content-wrapper">
            <div class="now-playing-about-wrapper">
                <div class="about" id="aboutMe">
                    <h2>About Me</h2>
                    <p>Hey there, I'm Hystoriya, a 24-year-old developer. This is my personal website that I made for no apparent reason. If you find yourself here randomly, then hi :)</p>
                </div>
            </div>
        </section>
        <!-- End of About Section -->

        <!-- Footer -->
        <footer class="footer">
            <div class="container">
                <p>&copy; 2024 MikuMiku. All rights reserved.</p>
                <button id="manageConsentFooter" class="manage-consent-button"><i class="fas fa-cookie-bite"></i> Manage Cookie Preferences</button>
            </div>
        </footer>
        <!-- End of Footer -->

        <!-- Chat Box -->
        <div id="chat-box" class="chat-box" role="dialog" aria-labelledby="chatHeader">
            <div class="chat-header">
                <h3 id="chatHeader"><i class="fas fa-robot"></i> Haru AI</h3>
                <button id="close-chat" class="close-chat" aria-label="Close Chat"><i class="fas fa-times"></i></button>
            </div>
            <div id="chat-content" class="chat-content">
                <div class="message bot-message"><i class="fas fa-comments"></i> Hi! I'm Haru, how can I help you today?</div>
            </div>
            <div class="chat-input-container">
                <input type="text" id="chat-input" class="chat-input" placeholder="Type your message..." aria-label="Chat Input">
                <button id="send-message" class="send-message"><i class="fas fa-paper-plane"></i> Send</button>
            </div>
        </div>
        <!-- End of Chat Box -->

        <!-- Description Modal -->
        <div id="descriptionModal" class="modal" aria-hidden="true" role="dialog" aria-labelledby="descriptionModalTitle" aria-describedby="descriptionModalDescription">
            <div class="modal-content">
                <button class="close-button" id="closeDescriptionButton" aria-label="Close Description Modal"><i class="fas fa-times"></i></button>
                <h2 id="descriptionModalTitle">Description</h2>
                <p id="descriptionModalDescription">Loading description...</p>
            </div>
        </div>
        <!-- End of Description Modal -->

        <!-- Consent Modal -->
        <div id="consentModal" class="modal" aria-hidden="true" role="dialog" aria-labelledby="consentModalTitle" aria-describedby="consentModalDescription">
            <div class="modal-content">
                <button class="close-button" id="closeConsentModal" aria-label="Close Consent Modal"><i class="fas fa-times"></i></button>
                <h2 id="consentModalTitle"><i class="fas fa-cookie"></i> Cookie Consent</h2>
                <p id="consentModalDescription">
                    I use cookies stored in your browser to enhance your experience on my personal website. These cookies are essential for the website's functionality. By clicking "Accept," you consent to their use. You can also manage your cookie preferences in the "Manage Cookie Preferences" section.
                </p>
                <div class="consent-buttons">
                    <button id="acceptConsent" class="consent-button"><i class="fas fa-check"></i> Accept</button>
                    <button id="declineConsent" class="consent-button"><i class="fas fa-times"></i> Decline</button>
                </div>
            </div>
        </div>
        <!-- End of Consent Modal -->


        <!-- JavaScript Libraries -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.1/socket.io.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.1/moment.min.js"></script>
        <!-- Import Haru AI script -->
        <script src="haru.js"></script>
        <!-- Custom Scripts -->
        <script>
            // Title Bar Scroll Effect
            const titleBar = document.getElementById('titleBar');
            window.addEventListener('scroll', () => {
                if (window.scrollY > 50) {
                    titleBar.classList.add('scrolled');
                } else {
                    titleBar.classList.remove('scrolled');
                }
            });

            // Overlay Menu Functionality
            const menuButton = document.getElementById('menuButton');
            const overlayMenu = document.getElementById('overlayMenu');
            const closeOverlay = document.getElementById('closeOverlay');

            menuButton.addEventListener('click', () => {
                overlayMenu.classList.add('active');
                document.body.classList.add('overlay-active');
            });

            closeOverlay.addEventListener('click', () => {
                overlayMenu.classList.remove('active');
                document.body.classList.remove('overlay-active');
            });

            // Close menu when clicking outside of it
            window.addEventListener('click', (event) => {
                if (event.target === overlayMenu) {
                    overlayMenu.classList.remove('active');
                    document.body.classList.remove('overlay-active');
                }
            });
        </script>

        <script>
            // [Cookie Consent Script]
            (function () {
                'use strict';

                const CONFIG = {
                    consentCookieName: 'cookieConsent',
                    consentCookieExpiryDays: 365,
                    consentCookiePath: '/',
                    consentModalId: 'consentModal',
                    acceptButtonId: 'acceptConsent',
                    declineButtonId: 'declineConsent',
                    manageButtonIds: ['manageConsentModal', 'manageConsentFooter'],
                    closeButtonId: 'closeConsentModal',
                    cookieCategories: {
                        necessary: {
                            enabled: true,
                            description: 'Necessary cookies enable core functionalities and security features of the website.'
                        }
                    },
                    focusableSelectors: 'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])',
                };

                const consentModal = document.getElementById(CONFIG.consentModalId);
                const acceptButton = document.getElementById(CONFIG.acceptButtonId);
                const declineButton = document.getElementById(CONFIG.declineButtonId);
                const closeButton = document.getElementById(CONFIG.closeButtonId);
                const manageConsentButtons = CONFIG.manageButtonIds.map(id => document.getElementById(id));

                function setCookie(name, value, days, path = '/') {
                    let expires = "";
                    if (days) {
                        const date = new Date();
                        date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
                        expires = "; expires=" + date.toUTCString();
                    }
                    const secure = location.protocol === 'https:' ? "; Secure" : "";
                    const sameSite = "; SameSite=Lax";
                    document.cookie = name + "=" + (value || "") + expires + "; path=" + path + secure + sameSite;
                }

                function getCookie(name) {
                    const nameEQ = name + "=";
                    const ca = document.cookie.split(';');
                    for (let i = 0; i < ca.length; i++) {
                        let c = ca[i];
                        while (c.charAt(0) === ' ') c = c.substring(1, c.length);
                        if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
                    }
                    return null;
                }

                function eraseCookie(name, path = '/') {
                    document.cookie = name + '=; Max-Age=-99999999; path=' + path + ';';
                }

                function trapFocus(modal) {
                    const focusableElements = modal.querySelectorAll(CONFIG.focusableSelectors);
                    if (focusableElements.length === 0) return;
                    const firstFocusableElement = focusableElements[0];
                    const lastFocusableElement = focusableElements[focusableElements.length - 1];

                    function handleFocus(event) {
                        if (event.key === 'Tab') {
                            if (event.shiftKey) {
                                if (document.activeElement === firstFocusableElement) {
                                    event.preventDefault();
                                    lastFocusableElement.focus();
                                }
                            } else {
                                if (document.activeElement === lastFocusableElement) {
                                    event.preventDefault();
                                    firstFocusableElement.focus();
                                }
                            }
                        }
                        if (event.key === 'Escape') {
                            event.preventDefault();
                        }
                    }

                    modal.addEventListener('keydown', handleFocus);
                }

                function showModal() {
                    consentModal.classList.add('active');
                    document.body.classList.add('modal-active');
                    consentModal.setAttribute('aria-hidden', 'false');

                    const focusableElements = consentModal.querySelectorAll(CONFIG.focusableSelectors);
                    if (focusableElements.length) {
                        focusableElements[0].focus();
                    }

                    trapFocus(consentModal);
                }

                function hideModal() {
                    consentModal.classList.remove('active');
                    document.body.classList.remove('modal-active');
                    consentModal.setAttribute('aria-hidden', 'true');
                }

                function initConsentModal() {
                    const existingConsent = getCookie(CONFIG.consentCookieName);

                    if (!existingConsent) {
                        showModal();
                    } else {
                        applyConsent(existingConsent);
                    }

                    acceptButton.addEventListener('click', function () {
                        setCookie(CONFIG.consentCookieName, JSON.stringify({
                            necessary: true
                        }), CONFIG.consentCookieExpiryDays, CONFIG.consentCookiePath);
                        hideModal();
                        initializeCookies();
                    });

                    declineButton.addEventListener('click', function () {
                        setCookie(CONFIG.consentCookieName, JSON.stringify({
                            necessary: false
                        }), CONFIG.consentCookieExpiryDays, CONFIG.consentCookiePath);
                        hideModal();
                        disableCookies();
                    });

                    manageConsentButtons.forEach(button => {
                        if (button) {
                            button.addEventListener('click', function (event) {
                                event.preventDefault();
                                showModal();
                            });
                        }
                    });

                    closeButton.addEventListener('click', function () {
                        alert('Please make a choice regarding cookie usage.');
                    });

                    window.addEventListener('click', function (event) {
                        if (event.target === consentModal) {
                            alert('Please make a choice regarding cookie usage.');
                        }
                    });
                }

                function applyConsent(consentValue) {
                    try {
                        const consent = JSON.parse(consentValue);
                        if (consent.necessary) {
                            initializeCookies(consent);
                        } else {
                            disableCookies();
                        }
                    } catch (error) {
                        console.error('Error parsing consent cookie:', error);
                        showModal();
                    }
                }

                function initializeCookies(consent) {
                    console.log('Necessary cookies enabled.');
                }

                function disableCookies() {
                    console.log('Necessary cookies disabled.');
                }

                function areCookiesEnabled() {
                    const testCookie = 'test_cookie_consent';
                    setCookie(testCookie, 'test', 1);
                    const result = getCookie(testCookie) === 'test';
                    eraseCookie(testCookie);
                    return result;
                }

                function init() {
                    if (areCookiesEnabled()) {
                        initConsentModal();
                    } else {
                        console.warn('Cookies are disabled in this browser. Consent modal will not be displayed.');
                    }
                }

                document.addEventListener('DOMContentLoaded', init);
            })();
        </script>

        <script>
            const socket = io("https://mikumiku.dev");
            let lastHeartbeatReceived = Date.now();
            let isSessionExpired = false;
            let browsingStartTime = null;
            let browsingInterval = null;
            let YOUTUBE_API_KEY = null; // Initialize API key variable
            
            const nowPlayingBox = document.getElementById("nowPlayingBox");
            const videoTitleElement = document.getElementById("videoTitle");
            const videoThumbnailImage = document.getElementById("videoThumbnailImage");
            const videoThumbnailElement = document.getElementById("videoThumbnail");
            const offlineIndicatorElement = document.getElementById("offline-indicator");
            const progressBarElement = document.getElementById("progressBar");
            const channelNameElement = document.getElementById("channelName");
            const viewCountElement = document.getElementById("viewCount");
            const likeCountElement = document.getElementById("likeCount");
            const publishedDateElement = document.getElementById("publishedDate");
            const videoCategoryElement = document.getElementById("videoCategory");
            const videoDescriptionElement = document.getElementById("descriptionModalDescription");
            const timeElapsedElement = document.getElementById("timeElapsed");
            const liveIconElement = document.getElementById("liveIcon"); // Added for Live Indicator
            
            // Fetch API Key from the server-side endpoint
            async function fetchApiKey() {
                try {
                    const response = await fetch('/api/youtube-key');
                    const data = await response.json();
                    YOUTUBE_API_KEY = data.apiKey;
                    fetchLiveStatus(); // Call the live status function after retrieving the API key
                } catch (error) {
                    console.error('Error fetching API key:', error);
                }
            }
            
            // Fetch live status from YouTube API
            async function fetchLiveStatus() {
                if (!YOUTUBE_API_KEY) {
                    console.warn('API key not available');
                    return;
                }
            
                try {
                    // Fetch channel ID
                    const response = await fetch(`https://www.googleapis.com/youtube/v3/channels?part=id&mine=true&key=${YOUTUBE_API_KEY}`);
                    const channelData = await response.json();
            
                    if (!channelData.items || channelData.items.length === 0) {
                        console.warn('No channel found.');
                        clearDisplay();
                        return;
                    }
            
                    const channelId = channelData.items[0].id;
            
                    // Fetch live video data
                    const liveResponse = await fetch(`https://www.googleapis.com/youtube/v3/search?part=snippet&channelId=${channelId}&eventType=live&type=video&key=${YOUTUBE_API_KEY}`);
                    const liveData = await liveResponse.json();
            
                    if (liveData.items && liveData.items.length > 0) {
                        const liveVideo = liveData.items[0];
                        displayVideoPresence({
                            title: liveVideo.snippet.title,
                            channelTitle: liveVideo.snippet.channelTitle,
                            thumbnail: liveVideo.snippet.thumbnails.high.url,
                            isLive: true,
                            videoId: liveVideo.id.videoId
                        });
                    } else {
                        clearDisplay();
                    }
                } catch (error) {
                    console.error('Error fetching live status:', error);
                }
            }
            
            function clearDisplay() {
                nowPlayingBox.classList.add("offline");
                offlineIndicatorElement.style.display = "block";
                videoTitleElement.textContent = "I’m not on YouTube at the moment, soz :(";
                videoThumbnailImage.src = "";
                videoThumbnailImage.style.display = "none";
                videoThumbnailElement.src = "";
                videoThumbnailElement.style.display = "none";
                channelNameElement.textContent = "";
                viewCountElement.textContent = "";
                likeCountElement.textContent = "";
                publishedDateElement.textContent = "";
                videoCategoryElement.textContent = "";
                progressBarElement.style.width = "0%";
                videoDescriptionElement.textContent = "";
                timeElapsedElement.style.display = "none";
                liveIconElement.style.display = "none"; // Hide Live Icon
            }
            
            function displayVideoPresence(data) {
                lastHeartbeatReceived = Date.now();
                nowPlayingBox.classList.remove("offline");
                offlineIndicatorElement.style.display = "none";
            
                videoTitleElement.textContent = data.title || "Unknown Title";
            
                if (data.thumbnail) {
                    videoThumbnailImage.src = data.thumbnail;
                    videoThumbnailImage.style.display = "block";
                    videoThumbnailElement.style.display = "none";
                } else {
                    videoThumbnailImage.src = "";
                    videoThumbnailElement.style.display = "none";
                }
            
                channelNameElement.textContent = data.channelTitle || "Unknown Channel";
            
                // Handle Live Status
                console.log("Live status:", data.isLive);
                if (data.isLive) {
                    liveIconElement.style.display = "block";
                } else {
                    liveIconElement.style.display = "none";
                }
            }
            
            // Fetch API key initially
            fetchApiKey();
            
            // Fetch live status periodically
            setInterval(fetchLiveStatus, 30000); // Check every 30 seconds
            
            // Socket.io and browsing presence handling remain unchanged
            socket.on("connect", () => {
                console.log("[Socket.IO] Connected to server.");
                isSessionExpired = false;
                socket.emit('requestLatestData');
            });
            
            socket.on("disconnect", () => {
                console.warn("[Socket.IO] Disconnected from server.");
                clearDisplay();
            });
            
            setInterval(() => {
                if (Date.now() - lastHeartbeatReceived > 60000) {
                    console.warn("[Heartbeat] No heartbeat received in the last 60 seconds. Marking as offline.");
                    clearDisplay();
                }
            }, 5000);
            

            // Modal Toggle Logic
            const descriptionModal = document.getElementById("descriptionModal");
            const closeDescriptionButton = document.getElementById("closeDescriptionButton");
            const toggleDescriptionButton = document.getElementById("toggleDescriptionButton");

            toggleDescriptionButton.addEventListener("click", function () {
                if (descriptionModal.style.display === "block") {
                    descriptionModal.style.display = "none";
                    toggleDescriptionButton.textContent = "Show Description";
                } else {
                    descriptionModal.style.display = "flex";
                    descriptionModal.classList.add('active');
                    toggleDescriptionButton.textContent = "Hide Description";
                }
            });

            closeDescriptionButton.addEventListener("click", function () {
                descriptionModal.style.display = "none";
                descriptionModal.classList.remove('active');
                toggleDescriptionButton.textContent = "Show Description";
            });

            window.addEventListener("click", function (event) {
                if (event.target === descriptionModal) {
                    descriptionModal.style.display = "none";
                    toggleDescriptionButton.textContent = "Show Description";
                }
            });
            // Clock Update Script
            function updateClocks() {
                const now = new Date();
                const localTime = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
                const localTimeElement = document.getElementById('local-time');
                if (localTimeElement) localTimeElement.textContent = localTime;
                const currentDate = now.toLocaleDateString(undefined, { day: '2-digit', month: 'short', year: 'numeric' });
                const currentDateElement = document.getElementById('current-date');
                if (currentDateElement) currentDateElement.textContent = currentDate;
            }

            setInterval(updateClocks, 1000);
            updateClocks();

            // Weather Update Script
            const CITY_NAME = 'Leeds';
            async function fetchWeather() {
                try {
                    const response = await fetch(`/api/weather?city=${encodeURIComponent(CITY_NAME)}`);
                    const data = await response.json();

                    if (data.error) {
                        throw new Error(data.error);
                    }

                    displayWeather(data);
                } catch (error) {
                    console.error('Error fetching weather data:', error);
                    const weatherIconElement = document.getElementById('weather-icon');
                    if (weatherIconElement) weatherIconElement.style.display = 'none';
                    document.getElementById('weather-description').innerText = 'Unable to fetch weather data.';
                }
            }

            function displayWeather(data) {
                const description = data.weather[0].description;
                const temperature = Math.round(data.main.temp);
                const humidity = data.main.humidity;
                const windSpeed = data.wind.speed;
                const iconCode = data.weather[0].icon;
                const iconUrl = `https://openweathermap.org/img/wn/${iconCode}@2x.png`;

                document.getElementById('weather-description').innerText = `Condition: ${description}`;
                document.getElementById('temperature').innerText = `Temperature: ${temperature}°C`;
                document.getElementById('humidity').innerText = `Humidity: ${humidity}%`;
                document.getElementById('wind-speed').innerText = `Wind: ${windSpeed} m/s`;

                const weatherIconElement = document.getElementById('weather-icon');
                if (weatherIconElement) {
                    weatherIconElement.src = iconUrl;
                    weatherIconElement.style.display = 'block';
                }
            }

            setInterval(fetchWeather, 3600000); // Update every hour
            fetchWeather();
        </script>
        
        <script type="module">
            import * as THREE from '/js/three.module.min.js';
            import { EffectComposer } from '/js/postprocessing/EffectComposer.js';
            import { RenderPass } from '/js/postprocessing/RenderPass.js';
            import { UnrealBloomPass } from '/js/postprocessing/UnrealBloomPass.js';
            import { FXAAShader } from '/js/shaders/FXAAShader.js';
            import { ShaderPass } from '/js/postprocessing/ShaderPass.js';
            
            const ChromaticAberrationShader = {
                uniforms: {
                    "tDiffuse": { value: null },
                    "offset": { value: new THREE.Vector2(0.00055, 0.00055) }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D tDiffuse;
                    uniform vec2 offset;
                    varying vec2 vUv;
                    void main() {
                        vec4 color = vec4(0.0);
                        vec2 redOffset = vUv + offset;
                        vec2 greenOffset = vUv;
                        vec2 blueOffset = vUv - offset;
                        color.r = texture2D(tDiffuse, redOffset).r;
                        color.g = texture2D(tDiffuse, greenOffset).g;
                        color.b = texture2D(tDiffuse, blueOffset).b;
                        color.a = texture2D(tDiffuse, vUv).a;
                        gl_FragColor = color;
                    }
                `
            };
            
            const canvas = document.getElementById('techCanvas');
            const isLowEnd = navigator.hardwareConcurrency && navigator.hardwareConcurrency <= 2;
            const isSmallScreen = window.innerWidth <= 768;
            const renderer = new THREE.WebGLRenderer({ canvas, antialias: !isLowEnd });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(isSmallScreen ? 1 : window.devicePixelRatio);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.5;
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 20000);
            camera.position.set(0, 0, 3000);
            
            const textureLoader = new THREE.TextureLoader();
            textureLoader.load('/textures/pillar.webp', (texture) => {
                texture.colorSpace = THREE.SRGBColorSpace;
                texture.encoding = THREE.sRGBEncoding;
                scene.background = texture;
            }, undefined, () => {
                scene.background = new THREE.Color(0x303030);
            });
            
            const ambientLight = new THREE.AmbientLight(0x404040, 1.8);
            scene.add(ambientLight);
            
            const hemisphereLight = new THREE.HemisphereLight(0xddddff, 0x555555, 0.5);
            scene.add(hemisphereLight);
            
            camera.layers.enable(0);
            camera.layers.enable(1);
            
            const starTextures = [
                textureLoader.load('/textures/stars 001.png'),
                textureLoader.load('/textures/stars 002.png'),
                textureLoader.load('/textures/stars 003.png'),
                textureLoader.load('/textures/stars 004.png'),
                textureLoader.load('/textures/stars 005.png'),
                textureLoader.load('/textures/stars 006.png')
            ];
            
            function createStaticStarField() {
                const starCount = isLowEnd ? 25 : 50;
                for (let i = 0; i < starCount; i++) {
                    const texture = starTextures[Math.floor(Math.random() * starTextures.length)];
                    const starMaterial = new THREE.SpriteMaterial({
                        map: texture,
                        blending: THREE.AdditiveBlending,
                        transparent: true,
                        opacity: 0.8
                    });
                    const star = new THREE.Sprite(starMaterial);
                    star.scale.set(200 + Math.random() * 150, 200 + Math.random() * 150, 1);
                    star.position.set(
                        Math.random() * window.innerWidth * 2 - window.innerWidth,
                        Math.random() * window.innerHeight * 2 - window.innerHeight,
                        -2000 + Math.random() * 1000
                    );
                    scene.add(star);
                }
            }
            
            const dynamicStarCount = isLowEnd ? 500 : 1000;
            const dynamicPositions = [];
            const dynamicSizes = [];
            const dynamicPhases = [];
            
            for (let i = 0; i < dynamicStarCount; i++) {
                const x = Math.random() * window.innerWidth * 2 - window.innerWidth;
                const y = Math.random() * window.innerHeight * 2 - window.innerHeight;
                const z = Math.random() * 3000 - 1500;
                dynamicPositions.push(x, y, z);
                dynamicSizes.push(1 + Math.random() * 2);
                dynamicPhases.push(Math.random() * Math.PI * 2);
            }
            
            const dynamicStarsGeometry = new THREE.BufferGeometry();
            dynamicStarsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(dynamicPositions, 3));
            dynamicStarsGeometry.setAttribute('size', new THREE.Float32BufferAttribute(dynamicSizes, 1));
            dynamicStarsGeometry.setAttribute('phase', new THREE.Float32BufferAttribute(dynamicPhases, 1));
            
            const starVertexShader = `
                uniform float time;
                attribute float size;
                attribute float phase;
                varying float vTwinkle;
                void main() {
                    vTwinkle = abs(sin(time + phase));
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    gl_PointSize = size * (1.0 + vTwinkle * 0.5);
                    gl_Position = projectionMatrix * mvPosition;
                }
            `;
            
            const starFragmentShader = `
                uniform vec3 starColor;
                varying float vTwinkle;
                void main() {
                    float dist = length(gl_PointCoord - vec2(0.5));
                    float alpha = 1.0 - smoothstep(0.4, 0.5, dist);
                    vec3 color = starColor * vTwinkle;
                    gl_FragColor = vec4(color, alpha);
                }
            `;
            
            const dynamicStarUniforms = {
                time: { value: 0.0 },
                starColor: { value: new THREE.Color(0xffffff) }
            };
            
            const dynamicStarsMaterial = new THREE.ShaderMaterial({
                uniforms: dynamicStarUniforms,
                vertexShader: starVertexShader,
                fragmentShader: starFragmentShader,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            const dynamicStars = new THREE.Points(dynamicStarsGeometry, dynamicStarsMaterial);
            scene.add(dynamicStars);
            
            const COMET_ACTIVE_DURATION = 7;
            const COMET_FADE_DURATION = 1;
            const cometTexture = textureLoader.load('/textures/comet1.png');
            const cometCount = isLowEnd ? 4 : 8;
            const comets = [];
            
            const particles = [];
            const particleCount = isLowEnd ? 100 : 200;
            const particleTexture = textureLoader.load('/textures/particle_clouds.png');
            
            const burningParticles = [];
            const burningParticleTexture = textureLoader.load('/textures/particle_clouds.png');
            
            function createComet() {
                const cometMaterial = new THREE.SpriteMaterial({
                    map: cometTexture,
                    blending: THREE.AdditiveBlending,
                    transparent: true,
                    opacity: 0.9,
                    depthWrite: false
                });
                const comet = new THREE.Sprite(cometMaterial);
                const cometSize = 150 + Math.random() * 200;
                comet.scale.set(cometSize, cometSize, 1);
                comet.color = new THREE.Color(0xffffff);
                comet.material.color = comet.color;
                const cometLight = new THREE.PointLight(comet.color, 4.0 + Math.random() * 3.0, 4000 + Math.random() * 2000, 2);
                cometLight.position.set(0, 0, 0);
                cometLight.castShadow = true;
                comet.add(cometLight);
                comet.light = cometLight;
                const spotLight = new THREE.SpotLight(0xffffff, 1.0, 5000, Math.PI / 8, 0.5);
                spotLight.castShadow = true;
                spotLight.target = comet;
                scene.add(spotLight);
                comet.spotLight = spotLight;
                comet.layers.set(1);
                cometLight.layers.set(1);
                spotLight.layers.set(1);
                resetComet(comet);
                comets.push(comet);
                scene.add(comet);
            }
            
            function createParticle() {
                const particleMaterial = new THREE.SpriteMaterial({
                    map: particleTexture,
                    blending: THREE.AdditiveBlending,
                    transparent: true,
                    opacity: 0.5,
                    depthWrite: false
                });
                const particle = new THREE.Sprite(particleMaterial);
                const particleSize = 5 + Math.random() * 10;
                particle.scale.set(particleSize, particleSize, 1);
                particle.position.set(
                    Math.random() * window.innerWidth * 2 - window.innerWidth,
                    Math.random() * window.innerHeight * 2 - window.innerHeight,
                    Math.random() * 3000 - 1500
                );
                const particleLight = new THREE.PointLight(0xffffff, 0.2, 200);
                particleLight.position.set(0, 0, 0);
                particle.add(particleLight);
                scene.add(particle);
                particles.push(particle);
            }
            
            function createBurningParticle(comet) {
                const burningMaterial = new THREE.SpriteMaterial({
                    map: burningParticleTexture,
                    blending: THREE.AdditiveBlending,
                    transparent: true,
                    opacity: 1.0,
                    depthWrite: false,
                    color: new THREE.Color(0xff4500)
                });
                const burningParticle = new THREE.Sprite(burningMaterial);
                const size = 10 + Math.random() * 10;
                burningParticle.scale.set(size, size, 1);
                burningParticle.position.copy(comet.position);
                const angle = Math.random() * Math.PI * 2;
                const speed = 50 + Math.random() * 50;
                burningParticle.velocity = new THREE.Vector3(Math.cos(angle) * speed, Math.sin(angle) * speed, 0);
                burningParticle.lifespan = 2.0 + Math.random() * 1.0;
                burningParticles.push(burningParticle);
                scene.add(burningParticle);
            }
            
            function resetComet(comet) {
                comet.position.set(
                    Math.random() * window.innerWidth * 2 - window.innerWidth,
                    window.innerHeight + 500,
                    Math.random() * 1000 - 500
                );
                const centerAngle = 5 * Math.PI / 4;
                const angleVariation = 5 * Math.PI / 180;
                const angle = centerAngle + (Math.random() * angleVariation * 2 - angleVariation);
                const speed = 1000 + Math.random() * 200;
                const velocityX = Math.cos(angle) * speed;
                const velocityY = Math.sin(angle) * speed;
                comet.velocity = new THREE.Vector3(velocityX, velocityY, 0);
                comet.lifespan = COMET_ACTIVE_DURATION + COMET_FADE_DURATION;
                comet.elapsed = 0;
                comet.burningOut = false;
                comet.light.intensity = 4.0 + Math.random() * 3.0;
                comet.material.opacity = 0.9;
                const cometSize = 150 + Math.random() * 200;
                comet.scale.set(cometSize, cometSize, 1);
                comet.rotation.z = Math.atan2(comet.velocity.y, comet.velocity.x);
                comet.flashPhase = 0;
                comet.flashSpeed = Math.random() * 5 + 5;
                comet.flashAmplitude = 3.0;
            }
            
            function updateComets(delta) {
                comets.forEach((comet, index) => {
                    comet.elapsed += delta;
                    if (comet.elapsed < COMET_ACTIVE_DURATION) {
                        comet.material.opacity = 0.9;
                        comet.light.intensity = 4.0 + Math.random() * 3.0;
                    } else if (comet.elapsed < COMET_ACTIVE_DURATION + COMET_FADE_DURATION) {
                        const fadeProgress = (comet.elapsed - COMET_ACTIVE_DURATION) / COMET_FADE_DURATION;
                        comet.material.opacity = THREE.MathUtils.lerp(0.9, 0.0, fadeProgress);
                        comet.light.intensity = THREE.MathUtils.lerp(comet.light.intensity, 0.0, fadeProgress);
                        if (index === 0) {
                            comet.material.opacity = THREE.MathUtils.lerp(0.9, 0.2, fadeProgress);
                            comet.light.intensity = THREE.MathUtils.lerp(comet.light.intensity, 1.0, fadeProgress);
                        }
                    } else {
                        resetComet(comet);
                    }
                    comet.position.add(comet.velocity.clone().multiplyScalar(delta));
                    const angle = Math.atan2(comet.velocity.y, comet.velocity.x);
                    comet.rotation.z = angle;
                    if (comet.spotLight) {
                        comet.spotLight.position.copy(comet.position);
                        comet.spotLight.position.z += 500;
                        comet.spotLight.intensity = 1.0 + Math.sin(clock.getElapsedTime() * 2) * 0.5;
                    }
                });
            }
            
            function updateParticles(delta) {
                particles.forEach((particle) => {
                    particle.position.x += (Math.random() - 0.5) * 0.5 * delta;
                    particle.position.y += (Math.random() - 0.5) * 0.5 * delta;
                    particle.position.z += (Math.random() - 0.5) * 0.2 * delta;
                });
            }
            
            function updateBurningParticles(delta) {
                for (let i = burningParticles.length - 1; i >= 0; i--) {
                    const particle = burningParticles[i];
                    particle.position.add(particle.velocity.clone().multiplyScalar(delta));
                    particle.lifespan -= delta;
                    if (particle.lifespan <= 0) {
                        scene.remove(particle);
                        burningParticles.splice(i, 1);
                        continue;
                    }
                    particle.material.opacity = Math.max(0, particle.lifespan / 2.0);
                }
            }
            
            function updateCometLightIntensity() {
                comets.forEach((comet) => {
                    let maxIntensity = 4.0;
                    particles.forEach((particle) => {
                        const distance = comet.position.distanceTo(particle.position);
                        if (distance < 500) {
                            maxIntensity = Math.max(maxIntensity, 4.0 + (500 - distance) / 100);
                        }
                    });
                    comet.light.intensity = maxIntensity;
                });
            }
            
            let mouseX = 0;
            let mouseY = 0;
            document.addEventListener('mousemove', (event) => {
                mouseX = (event.clientX / window.innerWidth) * 2 - 1;
                mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
            });
            
            function updateCamera() {
                camera.position.x += (mouseX * 500 - camera.position.x) * 0.05;
                camera.position.y += (mouseY * 300 - camera.position.y) * 0.05;
            }
            
            function spawnComets() {
                if (comets.length < cometCount) {
                    createComet();
                    const randomDelay = 1500 + Math.random() * 2000;
                    setTimeout(spawnComets, randomDelay);
                }
            }
            
            const satelliteTexture = textureLoader.load('/textures/sat1.png', () => {}, undefined, () => {});
            satelliteTexture.minFilter = THREE.LinearFilter;
            satelliteTexture.magFilter = THREE.LinearFilter;
            satelliteTexture.generateMipmaps = false;
            
            const satelliteMaterial = new THREE.SpriteMaterial({
                map: satelliteTexture,
                transparent: true,
                blending: THREE.NormalBlending,
                depthWrite: false,
                opacity: 1.0
            });
            
            const satellite = new THREE.Sprite(satelliteMaterial);
            satellite.scale.set(250, 250, 1);
            satellite.position.set(
                window.innerWidth + 200,
                (Math.random() - 0.5) * window.innerHeight,
                Math.random() * 1000 - 500
            );
            scene.add(satellite);
            
            const satelliteSpeed = 50;
            const satelliteRotationSpeed = 0.5;
            
            function updateSatellite(delta) {
                satellite.position.x -= satelliteSpeed * delta;
                satellite.rotation.z += satelliteRotationSpeed * delta;
                if (satellite.position.x < -window.innerWidth - 200) {
                    satellite.position.x = window.innerWidth + 200;
                    satellite.position.y = (Math.random() - 0.5) * window.innerHeight;
                    satellite.position.z = Math.random() * 1000 - 500;
                }
            }
            
            function updateDynamicStars(delta) {
                dynamicStarUniforms.time.value += delta;
            }
            
            createStaticStarField();
            spawnComets();
            for (let i = 0; i < particleCount; i++) {
                createParticle();
            }
            
            const renderPass = new RenderPass(scene, camera);
            const composer = new EffectComposer(renderer);
            composer.addPass(renderPass);
            
            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                isLowEnd ? 1.5 : 2.0,
                0.6,
                0.9
            );
            composer.addPass(bloomPass);
            
            const chromaticAberrationPass = new ShaderPass(ChromaticAberrationShader);
            chromaticAberrationPass.uniforms['offset'].value = new THREE.Vector2(0.00055, 0.00055);
            if (!isLowEnd) {
                composer.addPass(chromaticAberrationPass);
            }
            
            const fxaaPass = new ShaderPass(FXAAShader);
            fxaaPass.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight);
            composer.addPass(fxaaPass);
            
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    composer.setSize(window.innerWidth, window.innerHeight);
                    fxaaPass.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight);
                }, 200);
            });
            
            const clock = new THREE.Clock();
            
            function animate() {
                requestAnimationFrame(animate);
                const delta = clock.getDelta();
                updateDynamicStars(delta);
                updateComets(delta);
                updateParticles(delta);
                updateBurningParticles(delta);
                updateCometLightIntensity();
                updateCamera();
                updateSatellite(delta);
                composer.render();
            }
            
            animate();

        </script>






        <script src="/clockwork.js"></script>
    </body>
</html>
