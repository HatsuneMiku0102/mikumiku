<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MikuMiku | Home</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/styles.css">
    <!-- Add clockwork.js -->
    <script src="/clockwork.js" defer></script>
</head>

<body>
    <!-- Three.js Canvas -->
    <canvas id="techCanvas"></canvas>

    <div class="page-container">
        <!-- Title Bar -->
        <div class="title-bar">
            <div class="container">
                <div class="left-section"></div>
                <div class="center-section">
                    <div class="logo-title-wrapper">
                        <img src="/logo.webp" alt="Logo" class="logo" loading="lazy">
                        <h1 class="site-title" id="dynamicTitle">MikuMiku</h1>
                    </div>
                </div>
                <div class="right-section">
                    <div class="personality-section">
                        <div id="personalityCircle" class="personality-circle"></div>
                        <div id="personalityTextBox" class="personality-text-box">
                            <div id="personalityPhrase" class="personality-text-wrapper">Your Personality Trait</div>
                        </div>
                    </div>
                    <div class="dropdown">
                        <button class="dropdown-button">Menu</button>
                        <div class="dropdown-content">
                            <a href="/admin-login.html">Admin Login</a>
                            <!-- Add more menu items here if needed -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <!-- End of Title Bar -->

        <!-- Now Playing Section -->
        <div class="now-playing-container">
            <div id="nowPlayingBox" class="now-playing">
                <!-- Channel Info on the Left Side -->
                <div class="now-playing-sidebar">
                    <div class="sidebar-item">
                        <span>Channel:</span> <span id="channelName">Loading...</span>
                    </div>
                    <div class="sidebar-item">
                        <span>Views:</span> <span id="viewCount">Loading...</span>
                    </div>
                    <div class="sidebar-item">
                        <span>Likes:</span> <span id="likeCount">Loading...</span>
                    </div>
                    <div class="sidebar-item">
                        <span>Uploaded:</span> <span id="publishedDate">Loading...</span>
                    </div>
                    <div class="sidebar-item video-category">
                        <span>Category:</span> <span id="videoCategory">Loading...</span>
                    </div>
                </div>
                <!-- End of Channel Info -->

                <!-- Video Section in the Center -->
                <div class="video-section">
                    <div class="video-title-container">
                        <h2>Currently Playing</h2>
                        <p id="videoTitle">Loading...</p>
                    </div>

                    <div class="thumbnail-container">
                        <video id="videoThumbnail" class="video-thumbnail" preload="metadata" controls>
                            Your browser does not support the video tag.
                        </video>
                        <img id="videoThumbnailImage" src="" alt="Thumbnail" class="video-thumbnail" loading="lazy">
                    </div>

                    <div id="offline-indicator" class="offline-indicator">I’m currently offline</div>

                    <div class="progress-bar-container">
                        <div id="progressBar" class="progress-bar"></div>
                    </div>

                    <div id="timeElapsedContainer" class="time-elapsed"><span id="timeElapsed">0s</span></div>

                    <button class="toggle-description" id="toggleDescriptionButton">Show Description</button>

                    <div id="loadingSpinner" class="loading-spinner"></div>
                </div>
                <!-- End of Video Section -->
            </div>
        </div>
        <!-- End of Now Playing Section -->

        <!-- Combined Time and Weather Widget -->
        <div class="widgets-container">
            <div class="time-weather-widget box-container">
                <!-- Clock Section -->
                <div class="clock-section">
                    <!-- Greeting -->
                    <p id="greeting" class="greeting">Good morning!</p>

                    <!-- Digital and Analog Clocks Container -->
                    <div class="clocks-container">
                        <!-- Digital Clock -->
                        <div class="digital-clock">
                            <p id="local-time" class="local-time">--:--:--</p>
                            <p id="current-date" class="current-date">24 September 2024</p>
                            <p id="day-of-week" class="day-of-week">Thursday</p>
                            <p id="time-zone" class="time-zone">Time Zone: UTC</p>
                        </div>

                        <!-- Analog Clock -->
                        <div class="analog-clock-container">
                            <canvas id="analog-clock" width="200" height="200" aria-label="Analog Clock"></canvas>
                        </div>
                    </div>

                    <!-- Last Visit Message -->
                    <p id="last-visit-message" class="last-visit-message">Welcome back!</p>
                </div>
                <!-- End of Clock Section -->

                <!-- Weather Section -->
                <div class="weather-section">
                    <img id="weather-icon" src="" alt="Weather Icon" class="weather-icon" loading="lazy">
                    <p id="weather-description" class="weather-description">Loading...</p>
                    <p id="temperature" class="temperature">--°C</p>
                    <p id="humidity" class="humidity">Humidity: --%</p>
                    <p id="wind-speed" class="wind-speed">Wind: -- m/s</p>
                </div>
                <!-- End of Weather Section -->
            </div>
        </div>
        <!-- End of Combined Time and Weather Widget -->

        <!-- About Section -->
        <div class="content-wrapper">
            <div class="now-playing-about-wrapper">
                <div class="about box-container" id="aboutMe">
                    <h2>About Me</h2>
                    <p>Hey there, I'm Hystoriya, a 24-year-old developer. This is my personal website that I made for no apparent reason. If you find yourself here randomly, then hi :)</p>
                </div>
            </div>
        </div>
        <!-- End of About Section -->

        <!-- Footer -->
        <footer class="footer">
            <div class="container">
                <p>&copy; 2024 MikuMiku. All rights reserved.</p>
                <button id="manageConsentFooter" class="manage-consent-button">Manage Cookie Preferences</button>
            </div>
        </footer>
        <!-- End of Footer -->

        <!-- Chat Box -->
        <div id="chat-box" class="chat-box">
            <div class="chat-header">
                <h3>Haru AI</h3>
                <button id="close-chat" class="close-chat" aria-label="Close Chat">×</button>
            </div>
            <div id="chat-content" class="chat-content">
                <div class="message bot-message">Hi! I'm Haru, how can I help you today?</div>
            </div>
            <div class="chat-input-container">
                <input type="text" id="chat-input" class="chat-input" placeholder="Type your message..." aria-label="Chat Input" />
                <button id="send-message" class="send-message">Send</button>
            </div>
        </div>
        <!-- End of Chat Box -->

        <!-- Description Modal -->
        <div id="descriptionModal" class="modal" aria-hidden="true" role="dialog" aria-labelledby="descriptionModalTitle" aria-describedby="descriptionModalDescription">
            <div class="modal-content">
                <span class="close-button" id="closeDescriptionButton" aria-label="Close Description Modal">&times;</span>
                <h2 id="descriptionModalTitle">Description</h2>
                <p id="descriptionModalDescription">Loading description...</p>
            </div>
        </div>
        <!-- End of Description Modal -->

        <!-- Consent Modal -->
        <div id="consentModal" class="modal" aria-hidden="true" role="dialog" aria-labelledby="consentModalTitle" aria-describedby="consentModalDescription">
            <div class="modal-content">
                <span class="close-button" id="closeConsentModal" aria-label="Close Consent Modal">&times;</span>
                <h2 id="consentModalTitle">Cookie Consent</h2>
                <p id="consentModalDescription">
                    I use cookies stored in your browser to enhance your experience on my personal website. These cookies are essential for the website's functionality. By clicking "Accept," you consent to their use. You can also manage your cookie preferences in the "Manage Cookie Preferences" section.
                </p>
                <div class="consent-buttons">
                    <button id="acceptConsent" class="consent-button">Accept</button>
                    <button id="declineConsent" class="consent-button">Decline</button>
                </div>
            </div>
        </div>

        <!-- Socket.io Client Library -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.1/socket.io.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.1/moment.min.js"></script>


        <!-- Import Haru AI script -->
        <script src="haru.js"></script>
            
        <script>
            // [Cookie Consent Script]
            (function () {
                'use strict';

                const CONFIG = {
                    consentCookieName: 'cookieConsent',
                    consentCookieExpiryDays: 365,
                    consentCookiePath: '/',
                    consentModalId: 'consentModal',
                    acceptButtonId: 'acceptConsent',
                    declineButtonId: 'declineConsent',
                    manageButtonIds: ['manageConsentModal', 'manageConsentFooter'],
                    closeButtonId: 'closeConsentModal',
                    cookieCategories: {
                        necessary: {
                            enabled: true,
                            description: 'Necessary cookies enable core functionalities and security features of the website.'
                        }
                    },
                    focusableSelectors: 'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])',
                };

                const consentModal = document.getElementById(CONFIG.consentModalId);
                const acceptButton = document.getElementById(CONFIG.acceptButtonId);
                const declineButton = document.getElementById(CONFIG.declineButtonId);
                const closeButton = document.getElementById(CONFIG.closeButtonId);
                const manageConsentButtons = CONFIG.manageButtonIds.map(id => document.getElementById(id));

                function setCookie(name, value, days, path = '/') {
                    let expires = "";
                    if (days) {
                        const date = new Date();
                        date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
                        expires = "; expires=" + date.toUTCString();
                    }
                    const secure = location.protocol === 'https:' ? "; Secure" : "";
                    const sameSite = "; SameSite=Lax";
                    document.cookie = name + "=" + (value || "") + expires + "; path=" + path + secure + sameSite;
                }

                function getCookie(name) {
                    const nameEQ = name + "=";
                    const ca = document.cookie.split(';');
                    for (let i = 0; i < ca.length; i++) {
                        let c = ca[i];
                        while (c.charAt(0) === ' ') c = c.substring(1, c.length);
                        if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
                    }
                    return null;
                }

                function eraseCookie(name, path = '/') {
                    document.cookie = name + '=; Max-Age=-99999999; path=' + path + ';';
                }

                function trapFocus(modal) {
                    const focusableElements = modal.querySelectorAll(CONFIG.focusableSelectors);
                    if (focusableElements.length === 0) return;
                    const firstFocusableElement = focusableElements[0];
                    const lastFocusableElement = focusableElements[focusableElements.length - 1];

                    function handleFocus(event) {
                        if (event.key === 'Tab') {
                            if (event.shiftKey) {
                                if (document.activeElement === firstFocusableElement) {
                                    event.preventDefault();
                                    lastFocusableElement.focus();
                                }
                            } else {
                                if (document.activeElement === lastFocusableElement) {
                                    event.preventDefault();
                                    firstFocusableElement.focus();
                                }
                            }
                        }
                        if (event.key === 'Escape') {
                            event.preventDefault();
                        }
                    }

                    modal.addEventListener('keydown', handleFocus);
                }

                function showModal() {
                    consentModal.classList.add('active');
                    document.body.classList.add('modal-active');
                    consentModal.setAttribute('aria-hidden', 'false');

                    const focusableElements = consentModal.querySelectorAll(CONFIG.focusableSelectors);
                    if (focusableElements.length) {
                        focusableElements[0].focus();
                    }

                    trapFocus(consentModal);
                }

                function hideModal() {
                    consentModal.classList.remove('active');
                    document.body.classList.remove('modal-active');
                    consentModal.setAttribute('aria-hidden', 'true');
                }

                function initConsentModal() {
                    const existingConsent = getCookie(CONFIG.consentCookieName);

                    if (!existingConsent) {
                        showModal();
                    } else {
                        applyConsent(existingConsent);
                    }

                    acceptButton.addEventListener('click', function () {
                        setCookie(CONFIG.consentCookieName, JSON.stringify({
                            necessary: true
                        }), CONFIG.consentCookieExpiryDays, CONFIG.consentCookiePath);
                        hideModal();
                        initializeCookies();
                    });

                    declineButton.addEventListener('click', function () {
                        setCookie(CONFIG.consentCookieName, JSON.stringify({
                            necessary: false
                        }), CONFIG.consentCookieExpiryDays, CONFIG.consentCookiePath);
                        hideModal();
                        disableCookies();
                    });

                    manageConsentButtons.forEach(button => {
                        if (button) {
                            button.addEventListener('click', function (event) {
                                event.preventDefault();
                                showModal();
                            });
                        }
                    });

                    closeButton.addEventListener('click', function () {
                        alert('Please make a choice regarding cookie usage.');
                    });

                    window.addEventListener('click', function (event) {
                        if (event.target === consentModal) {
                            alert('Please make a choice regarding cookie usage.');
                        }
                    });
                }

                function applyConsent(consentValue) {
                    try {
                        const consent = JSON.parse(consentValue);
                        if (consent.necessary) {
                            initializeCookies(consent);
                        } else {
                            disableCookies();
                        }
                    } catch (error) {
                        console.error('Error parsing consent cookie:', error);
                        showModal();
                    }
                }

                function initializeCookies(consent) {
                    console.log('Necessary cookies enabled.');
                }

                function disableCookies() {
                    console.log('Necessary cookies disabled.');
                }

                function areCookiesEnabled() {
                    const testCookie = 'test_cookie_consent';
                    setCookie(testCookie, 'test', 1);
                    const result = getCookie(testCookie) === 'test';
                    eraseCookie(testCookie);
                    return result;
                }

                function init() {
                    if (areCookiesEnabled()) {
                        initConsentModal();
                    } else {
                        console.warn('Cookies are disabled in this browser. Consent modal will not be displayed.');
                    }
                }

                document.addEventListener('DOMContentLoaded', init);
            })();
        </script>

        <script>
            // Now Playing Elements and Socket.IO Integration
            const socket = io("https://mikumiku.dev");
            let lastHeartbeatReceived = Date.now();
            let isSessionExpired = false;
            let browsingStartTime = null;
            let browsingInterval = null;

            const nowPlayingBox = document.getElementById("nowPlayingBox");
            const videoTitleElement = document.getElementById("videoTitle");
            const videoThumbnailImage = document.getElementById("videoThumbnailImage");
            const videoThumbnailElement = document.getElementById("videoThumbnail");
            const offlineIndicatorElement = document.getElementById("offline-indicator");
            const progressBarElement = document.getElementById("progressBar");
            const channelNameElement = document.getElementById("channelName");
            const viewCountElement = document.getElementById("viewCount");
            const likeCountElement = document.getElementById("likeCount");
            const publishedDateElement = document.getElementById("publishedDate");
            const videoCategoryElement = document.getElementById("videoCategory");
            const videoDescriptionElement = document.getElementById("descriptionModalDescription");
            const timeElapsedElement = document.getElementById("timeElapsed");

            function formatNumber(number) {
                if (typeof number === 'string') {
                    number = number.replace(/,/g, '');
                }
                const num = Number(number);
                return isNaN(num) ? "N/A" : num.toLocaleString();
            }

            function clearDisplay() {
                nowPlayingBox.classList.add("offline");
                offlineIndicatorElement.style.display = "block";
                videoTitleElement.textContent = "I’m not on YouTube at the moment, soz :(";
                videoThumbnailImage.src = "";
                videoThumbnailImage.style.display = "none";
                videoThumbnailElement.src = "";
                videoThumbnailElement.style.display = "none";
                channelNameElement.textContent = "";
                viewCountElement.textContent = "";
                likeCountElement.textContent = "";
                publishedDateElement.textContent = "";
                videoCategoryElement.textContent = "";
                progressBarElement.style.width = "0%";
                videoDescriptionElement.textContent = "";
                timeElapsedElement.style.display = "none";
            }

            function clearVideoPresence() {
                videoTitleElement.textContent = "";
                videoThumbnailImage.src = "";
                videoThumbnailImage.style.display = "none";
                videoThumbnailElement.src = "";
                videoThumbnailElement.style.display = "none";
                channelNameElement.textContent = "";
                viewCountElement.textContent = "";
                likeCountElement.textContent = "";
                publishedDateElement.textContent = "";
                videoCategoryElement.textContent = "";
                progressBarElement.style.width = "0%";
                videoDescriptionElement.textContent = "";
            }

            function reinitializeSession() {
                console.warn("[Client] Reinitializing session due to mismatch or timeout.");
                clearDisplay();
                isSessionExpired = true;
            }

            function formatTimeElapsed(seconds) {
                const hours = Math.floor(seconds / 3600);
                const minutes = Math.floor((seconds % 3600) / 60);
                const remainingSeconds = seconds % 60;

                if (hours > 0) {
                    return `${hours}h ${minutes}m ${remainingSeconds}s`;
                } else if (minutes > 0) {
                    return `${minutes}m ${remainingSeconds}s`;
                } else {
                    return `${remainingSeconds}s`;
                }
            }

            function displayVideoPresence(data) {
                lastHeartbeatReceived = Date.now();
                nowPlayingBox.classList.remove("offline");
                offlineIndicatorElement.style.display = "none";

                videoTitleElement.textContent = data.title || "Unknown Title";

                if (data.thumbnail) {
                    videoThumbnailImage.src = data.thumbnail;
                    videoThumbnailImage.style.display = "block";
                    videoThumbnailElement.style.display = "none";
                } else {
                    videoThumbnailImage.src = "";
                    videoThumbnailElement.style.display = "none";
                }

                channelNameElement.textContent = data.channelTitle || "Unknown Channel";
                viewCountElement.textContent = `${formatNumber(data.viewCount)}` || "N/A";
                likeCountElement.textContent = `${formatNumber(data.likeCount)}` || "N/A";

                if (data.publishedAt) {
                    const publishedDate = new Date(data.publishedAt);
                    publishedDateElement.textContent = `Published on: ${publishedDate.toLocaleDateString()}` || "Published on: N/A";
                } else {
                    publishedDateElement.textContent = "Published on: N/A";
                }

                videoCategoryElement.textContent = `${data.category}` || "N/A";
                videoDescriptionElement.textContent = data.description || "No description available.";
                handleRealTimeProgress(data);
                timeElapsedElement.style.display = "none";

                if (data.videoSrc) {
                    videoThumbnailElement.src = data.videoSrc;
                    videoThumbnailElement.style.display = "block";
                    videoThumbnailImage.style.display = "none";
                } else {
                    videoThumbnailElement.style.display = "none";
                    videoThumbnailImage.style.display = "block";
                }
            }

            function handleRealTimeProgress(data) {
                if (data.duration && data.currentTime) {
                    const progressPercentage = (data.currentTime / data.duration) * 100;
                    progressBarElement.style.width = `${progressPercentage}%`;
                } else {
                    progressBarElement.style.width = "0%";
                }
            }

            function displayBrowsingPresence(data) {
                lastHeartbeatReceived = Date.now();
                nowPlayingBox.classList.remove("offline");
                offlineIndicatorElement.style.display = "none";

                clearVideoPresence();

                videoTitleElement.textContent = data.title || "Browsing YouTube";
                videoThumbnailImage.src = data.thumbnail || "https://i.postimg.cc/GpgNPv0R/custom-browsing-thumbnail.png";
                videoThumbnailImage.style.display = "block";
                videoThumbnailElement.style.display = "none";
                channelNameElement.textContent = "Browsing...";
                videoDescriptionElement.textContent = data.description || "Browsing videos on YouTube";
                progressBarElement.style.width = "0%";

                if (data.timeElapsed !== undefined) {
                    timeElapsedElement.textContent = `Time Elapsed: ${formatTimeElapsed(data.timeElapsed)}`;
                    timeElapsedElement.style.display = "block";
                }
            }

            function updateBrowsingPresence() {
                if (browsingStartTime !== null) {
                    const timeElapsed = Math.floor((Date.now() - browsingStartTime) / 1000);
                    timeElapsedElement.textContent = `Time Elapsed: ${formatTimeElapsed(timeElapsed)}`;
                    timeElapsedElement.style.display = "block";

                    const browsingData = {
                        title: 'YouTube',
                        description: 'Browsing videos',
                        thumbnail: 'https://i.postimg.cc/GpgNPv0R/custom-browsing-thumbnail.png',
                        timeElapsed: timeElapsed,
                        presenceType: 'browsing'
                    };
                    socket.emit('updateBrowsingPresence', browsingData);
                }
            }

            function startBrowsingPresence() {
                if (browsingStartTime === null) {
                    browsingStartTime = Date.now();
                }
                if (!browsingInterval) {
                    browsingInterval = setInterval(updateBrowsingPresence, 5000);
                }
            }

            function stopBrowsingPresence() {
                if (browsingInterval) {
                    clearInterval(browsingInterval);
                    browsingInterval = null;
                }
                browsingStartTime = null;
            }

            socket.on("connect", () => {
                console.log("[Socket.IO] Connected to server.");
                isSessionExpired = false;
                socket.emit('requestLatestData');
            });

            socket.on("presenceUpdate", (data) => {
                if (isSessionExpired) {
                    console.warn("[Client] Ignoring presenceUpdate due to expired session.");
                    return;
                }

                console.log("[Socket.IO] Received presenceUpdate:", data);
                lastHeartbeatReceived = Date.now();

                if (data.presenceType === 'video') {
                    stopBrowsingPresence();
                    displayVideoPresence(data);
                } else if (data.presenceType === 'browsing') {
                    displayBrowsingPresence(data);
                    startBrowsingPresence();
                } else {
                    clearDisplay();
                }
            });

            socket.on("reinitializeSession", (data) => {
                console.warn(`[Socket.IO] Received reinitializeSession: ${JSON.stringify(data)}`);
                reinitializeSession();
            });

            socket.on("sessionExpired", (data) => {
                console.warn(`[Socket.IO] Session expired for video ID: ${data.videoId}`);
                reinitializeSession();
            });

            socket.on("disconnect", () => {
                console.warn("[Socket.IO] Disconnected from server.");
                stopBrowsingPresence();
                clearDisplay();
            });

            setInterval(() => {
                if (Date.now() - lastHeartbeatReceived > 60000) {
                    console.warn("[Heartbeat] No heartbeat received in the last 60 seconds. Marking as offline.");
                    clearDisplay();
                }
            }, 5000);

            // Modal Toggle Logic
            const descriptionModal = document.getElementById("descriptionModal");
            const closeDescriptionButton = document.getElementById("closeDescriptionButton");
            const toggleDescriptionButton = document.getElementById("toggleDescriptionButton");

            toggleDescriptionButton.addEventListener("click", function () {
                if (descriptionModal.style.display === "block") {
                    descriptionModal.style.display = "none";
                    toggleDescriptionButton.textContent = "Show Description";
                } else {
                    descriptionModal.style.display = "flex"; 
                    descriptionModal.classList.add('active');
                    toggleDescriptionButton.textContent = "Hide Description";
                }
            });
            
            closeDescriptionButton.addEventListener("click", function () {
                descriptionModal.style.display = "none";
                descriptionModal.classList.remove('active');
                toggleDescriptionButton.textContent = "Show Description";
            });

            window.addEventListener("click", function (event) {
                if (event.target === descriptionModal) {
                    descriptionModal.style.display = "none";
                    toggleDescriptionButton.textContent = "Show Description";
                }
            });

            // Clock Update Script
            function updateClocks() {
                const now = new Date();
                const localTime = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
                const localTimeElement = document.getElementById('local-time');
                if (localTimeElement) localTimeElement.textContent = localTime;
                const currentDate = now.toLocaleDateString(undefined, { day: '2-digit', month: 'short', year: 'numeric' });
                const currentDateElement = document.getElementById('current-date');
                if (currentDateElement) currentDateElement.textContent = currentDate;
            }

            setInterval(updateClocks, 1000);
            updateClocks();

            // Weather Update Script
            const CITY_NAME = 'Leeds';
            async function fetchWeather() {
                try {
                    const response = await fetch(`/api/weather?city=${encodeURIComponent(CITY_NAME)}`);
                    const data = await response.json();

                    if (data.error) {
                        throw new Error(data.error);
                    }

                    displayWeather(data);
                } catch (error) {
                    console.error('Error fetching weather data:', error);
                    const weatherIconElement = document.getElementById('weather-icon');
                    if (weatherIconElement) weatherIconElement.style.display = 'none';
                    document.getElementById('weather-description').innerText = 'Unable to fetch weather data.';
                }
            }

            function displayWeather(data) {
                const description = data.weather[0].description;
                const temperature = Math.round(data.main.temp);
                const humidity = data.main.humidity;
                const windSpeed = data.wind.speed;
                const iconCode = data.weather[0].icon;
                const iconUrl = `https://openweathermap.org/img/wn/${iconCode}@2x.png`;

                document.getElementById('weather-description').innerText = `Condition: ${description}`;
                document.getElementById('temperature').innerText = `Temperature: ${temperature}°C`;
                document.getElementById('humidity').innerText = `Humidity: ${humidity}%`;
                document.getElementById('wind-speed').innerText = `Wind: ${windSpeed} m/s`;

                const weatherIconElement = document.getElementById('weather-icon');
                if (weatherIconElement) {
                    weatherIconElement.src = iconUrl;
                    weatherIconElement.style.display = 'block';
                }
            }

            setInterval(fetchWeather, 3600000); // Update every hour
            fetchWeather();
        </script>
        
        <script type="module">
            import * as THREE from '/js/three.module.min.js';
            import { EffectComposer } from '/js/postprocessing/EffectComposer.js';
            import { RenderPass } from '/js/postprocessing/RenderPass.js';
            import { UnrealBloomPass } from '/js/postprocessing/UnrealBloomPass.js';
            import { FXAAShader } from '/js/shaders/FXAAShader.js';
            import { ShaderPass } from '/js/postprocessing/ShaderPass.js';
        
            // Chromatic Aberration Shader
            const ChromaticAberrationShader = {
                uniforms: {
                    "tDiffuse": { value: null },
                    "offset": { value: new THREE.Vector2(0.00055, 0.00055) }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D tDiffuse;
                    uniform vec2 offset;
                    varying vec2 vUv;
                    void main() {
                        vec4 color = vec4(0.0);
                        vec2 redOffset = vUv + offset;
                        vec2 greenOffset = vUv;
                        vec2 blueOffset = vUv - offset;
                        color.r = texture2D(tDiffuse, redOffset).r;
                        color.g = texture2D(tDiffuse, greenOffset).g;
                        color.b = texture2D(tDiffuse, blueOffset).b;
                        color.a = texture2D(tDiffuse, vUv).a;
                        gl_FragColor = color;
                    }
                `
            };
        
            // Renderer Setup
            const canvas = document.getElementById('techCanvas');
            const isLowEnd = navigator.hardwareConcurrency && navigator.hardwareConcurrency <= 2;
            const isSmallScreen = window.innerWidth <= 768;
            const pixelRatio = isSmallScreen ? 1 : Math.min(window.devicePixelRatio, 2);
            const renderer = new THREE.WebGLRenderer({ canvas, antialias: !isLowEnd });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(pixelRatio);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.5;
            renderer.outputColorSpace = THREE.SRGBColorSpace;
        
            // Scene and Camera Setup
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 20000);
            camera.position.set(0, 0, 3000);
        
            const textureLoader = new THREE.TextureLoader();
        
            // Function to Load Textures Asynchronously
            function loadTexture(src, encoding = THREE.sRGBEncoding, fallbackColor = null) {
                return new Promise((resolve) => {
                    textureLoader.load(
                        src,
                        (texture) => {
                            texture.encoding = encoding;
                            resolve(texture);
                        },
                        undefined,
                        () => {
                            if (fallbackColor) {
                                resolve(fallbackColor);
                            } else {
                                resolve(null);
                            }
                        }
                    );
                });
            }
        
            // Preload All Textures
            async function preloadTextures() {
                const texturePaths = {
                    background: '/textures/pillar.webp',
                    stars: [
                        '/textures/stars 001.png',
                        '/textures/stars 002.png',
                        '/textures/stars 003.png',
                        '/textures/stars 004.png',
                        '/textures/stars 005.png',
                        '/textures/stars 006.png'
                    ],
                    comet: '/textures/comet1.png',
                    particleCloud: '/textures/particle_clouds.png',
                    satellite: '/textures/sat1.png'
                };
        
                const textures = {};
        
                textures.background = await loadTexture(texturePaths.background, THREE.sRGBEncoding, new THREE.Color(0x303030));
                textures.stars = await Promise.all(texturePaths.stars.map(src => loadTexture(src, THREE.sRGBEncoding)));
                textures.comet = await loadTexture(texturePaths.comet, THREE.sRGBEncoding);
                textures.particleCloud = await loadTexture(texturePaths.particleCloud, THREE.sRGBEncoding);
                textures.satellite = await loadTexture(texturePaths.satellite, THREE.sRGBEncoding);
        
                return textures;
            }
        
            preloadTextures().then((textures) => {
                // Set Scene Background
                if (textures.background instanceof THREE.Texture) {
                    scene.background = textures.background;
                } else {
                    scene.background = textures.background; // Fallback color
                }
        
                // Add Ambient and Hemisphere Lights
                const ambientLight = new THREE.AmbientLight(0x404040, 1.8);
                scene.add(ambientLight);
        
                const hemisphereLight = new THREE.HemisphereLight(0xddddff, 0x555555, 0.5);
                scene.add(hemisphereLight);
        
                // Static Stars Setup
                const staticStarCount = isLowEnd ? 25 : 50;
                const staticStarPositions = new Float32Array(staticStarCount * 3);
                const staticStarSizes = new Float32Array(staticStarCount);
                const staticStarColors = new Float32Array(staticStarCount * 3); // All white
        
                for (let i = 0; i < staticStarCount; i++) {
                    staticStarPositions[i * 3] = (Math.random() * 2 - 1) * window.innerWidth;
                    staticStarPositions[i * 3 + 1] = (Math.random() * 2 - 1) * window.innerHeight;
                    staticStarPositions[i * 3 + 2] = -2000 + Math.random() * 1000;
                    staticStarSizes[i] = 200 + Math.random() * 150;
                    staticStarColors[i * 3] = 1.0;
                    staticStarColors[i * 3 + 1] = 1.0;
                    staticStarColors[i * 3 + 2] = 1.0;
                }
        
                const staticStarsGeometry = new THREE.BufferGeometry();
                staticStarsGeometry.setAttribute('position', new THREE.BufferAttribute(staticStarPositions, 3));
                staticStarsGeometry.setAttribute('size', new THREE.BufferAttribute(staticStarSizes, 1));
                staticStarsGeometry.setAttribute('color', new THREE.BufferAttribute(staticStarColors, 3));
        
                const staticStarsMaterial = new THREE.PointsMaterial({
                    size: 200,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
        
                const staticStars = new THREE.Points(staticStarsGeometry, staticStarsMaterial);
                scene.add(staticStars);
        
                // Dynamic Stars Setup
                const dynamicStarCount = isLowEnd ? 500 : 1000;
                const dynamicStarPositions = new Float32Array(dynamicStarCount * 3);
                const dynamicStarSizes = new Float32Array(dynamicStarCount);
                const dynamicStarPhases = new Float32Array(dynamicStarCount);
        
                for (let i = 0; i < dynamicStarCount; i++) {
                    dynamicStarPositions[i * 3] = (Math.random() * 2 - 1) * window.innerWidth;
                    dynamicStarPositions[i * 3 + 1] = (Math.random() * 2 - 1) * window.innerHeight;
                    dynamicStarPositions[i * 3 + 2] = Math.random() * 3000 - 1500;
                    dynamicStarSizes[i] = 1 + Math.random() * 2;
                    dynamicStarPhases[i] = Math.random() * Math.PI * 2;
                }
        
                const dynamicStarsGeometry = new THREE.BufferGeometry();
                dynamicStarsGeometry.setAttribute('position', new THREE.BufferAttribute(dynamicStarPositions, 3));
                dynamicStarsGeometry.setAttribute('size', new THREE.BufferAttribute(dynamicStarSizes, 1));
                dynamicStarsGeometry.setAttribute('phase', new THREE.BufferAttribute(dynamicStarPhases, 1));
        
                const dynamicStarUniforms = {
                    time: { value: 0.0 },
                    starColor: { value: new THREE.Color(0xffffff) }
                };
        
                const dynamicStarsMaterial = new THREE.ShaderMaterial({
                    uniforms: dynamicStarUniforms,
                    vertexShader: `
                        uniform float time;
                        attribute float size;
                        attribute float phase;
                        varying float vTwinkle;
                        void main() {
                            vTwinkle = abs(sin(time + phase));
                            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                            gl_PointSize = size * (1.0 + vTwinkle * 0.5);
                            gl_Position = projectionMatrix * mvPosition;
                        }
                    `,
                    fragmentShader: `
                        uniform vec3 starColor;
                        varying float vTwinkle;
                        void main() {
                            float dist = length(gl_PointCoord - vec2(0.5));
                            float alpha = 1.0 - smoothstep(0.4, 0.5, dist);
                            vec3 color = starColor * vTwinkle;
                            gl_FragColor = vec4(color, alpha);
                        }
                    `,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
        
                const dynamicStars = new THREE.Points(dynamicStarsGeometry, dynamicStarsMaterial);
                scene.add(dynamicStars);
        
                // Comets Setup
                const COMET_ACTIVE_DURATION = 7;
                const COMET_FADE_DURATION = 1;
                const cometCount = isLowEnd ? 4 : 8;
                const comets = [];
                const cometTexture = textures.comet;
        
                // Shared Material for Comets
                const cometMaterial = new THREE.SpriteMaterial({
                    map: cometTexture,
                    blending: THREE.AdditiveBlending,
                    transparent: true,
                    opacity: 0.9,
                    depthWrite: false
                });
        
                // Initialize Comets
                for (let i = 0; i < cometCount; i++) {
                    const comet = new THREE.Sprite(cometMaterial);
                    resetComet(comet);
                    comets.push(comet);
                    scene.add(comet);
                }
        
                function resetComet(comet) {
                    comet.position.set(
                        (Math.random() * 2 - 1) * window.innerWidth,
                        window.innerHeight + 500,
                        Math.random() * 1000 - 500
                    );
                    const centerAngle = 225 * (Math.PI / 180); // 5π/4 radians
                    const angleVariation = 5 * (Math.PI / 180);
                    const angle = centerAngle + (Math.random() * angleVariation * 2 - angleVariation);
                    const speed = 1000 + Math.random() * 200;
                    comet.velocity = new THREE.Vector3(
                        Math.cos(angle) * speed,
                        Math.sin(angle) * speed,
                        0
                    );
                    comet.lifespan = COMET_ACTIVE_DURATION + COMET_FADE_DURATION;
                    comet.elapsed = 0;
                    comet.material.opacity = 0.9;
                    const cometSize = 150 + Math.random() * 200;
                    comet.scale.set(cometSize, cometSize, 1);
                    comet.rotation.z = angle;
                }
        
                // Particles Setup
                const particleCount = isLowEnd ? 100 : 200;
                const particleTexture = textures.particleCloud;
                const particlesGeometry = new THREE.BufferGeometry();
                const particlesPositions = new Float32Array(particleCount * 3);
                const particlesVelocities = new Float32Array(particleCount * 3); // For slight movement
        
                for (let i = 0; i < particleCount; i++) {
                    particlesPositions[i * 3] = (Math.random() * 2 - 1) * window.innerWidth;
                    particlesPositions[i * 3 + 1] = (Math.random() * 2 - 1) * window.innerHeight;
                    particlesPositions[i * 3 + 2] = Math.random() * 3000 - 1500;
                    particlesVelocities[i * 3] = (Math.random() - 0.5) * 0.5;
                    particlesVelocities[i * 3 + 1] = (Math.random() - 0.5) * 0.5;
                    particlesVelocities[i * 3 + 2] = (Math.random() - 0.5) * 0.2;
                }
        
                particlesGeometry.setAttribute('position', new THREE.BufferAttribute(particlesPositions, 3));
                particlesGeometry.setAttribute('velocity', new THREE.BufferAttribute(particlesVelocities, 3));
        
                const particlesMaterial = new THREE.PointsMaterial({
                    map: particleTexture,
                    size: 10,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false,
                    opacity: 0.5
                });
        
                const particles = new THREE.Points(particlesGeometry, particlesMaterial);
                scene.add(particles);
        
                // Satellite Setup
                const satelliteTexture = textures.satellite;
                const satelliteMaterial = new THREE.SpriteMaterial({
                    map: satelliteTexture,
                    transparent: true,
                    blending: THREE.NormalBlending,
                    depthWrite: false,
                    opacity: 1.0
                });
        
                const satellite = new THREE.Sprite(satelliteMaterial);
                satellite.scale.set(250, 250, 1);
                resetSatellite();
                scene.add(satellite);
        
                function resetSatellite() {
                    satellite.position.set(
                        window.innerWidth + 200,
                        (Math.random() - 0.5) * window.innerHeight,
                        Math.random() * 1000 - 500
                    );
                    satellite.velocity = new THREE.Vector3(-50, 0, 0);
                    satellite.rotationSpeed = 0.5;
                }
        
                // Postprocessing Setup
                const renderPass = new RenderPass(scene, camera);
                const composer = new EffectComposer(renderer);
                composer.addPass(renderPass);
        
                const bloomParams = {
                    strength: isLowEnd ? 1.5 : 2.0,
                    radius: 0.6,
                    threshold: 0.9
                };
                const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), bloomParams.strength, bloomParams.radius, bloomParams.threshold);
                composer.addPass(bloomPass);
        
                if (!isLowEnd) {
                    const chromaticAberrationPass = new ShaderPass(ChromaticAberrationShader);
                    chromaticAberrationPass.uniforms['offset'].value = new THREE.Vector2(0.00055, 0.00055);
                    composer.addPass(chromaticAberrationPass);
                }
        
                const fxaaPass = new ShaderPass(FXAAShader);
                fxaaPass.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight);
                composer.addPass(fxaaPass);
        
                // Handle Window Resize with Debounce
                let resizeTimeout;
                window.addEventListener('resize', () => {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => {
                        const width = window.innerWidth;
                        const height = window.innerHeight;
                        camera.aspect = width / height;
                        camera.updateProjectionMatrix();
                        renderer.setSize(width, height);
                        composer.setSize(width, height);
                        fxaaPass.uniforms['resolution'].value.set(1 / width, 1 / height);
                    }, 200);
                });
        
                // Mouse Movement for Camera Control
                let mouseX = 0;
                let mouseY = 0;
                document.addEventListener('mousemove', (event) => {
                    mouseX = (event.clientX / window.innerWidth) * 2 - 1;
                    mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
                });
        
                // Animation Loop
                const clock = new THREE.Clock();
        
                function animate() {
                    requestAnimationFrame(animate);
                    const delta = clock.getDelta();
        
                    // Update Dynamic Stars
                    dynamicStarUniforms.time.value += delta;
        
                    // Update Comets
                    comets.forEach(comet => {
                        comet.elapsed += delta;
                        if (comet.elapsed < COMET_ACTIVE_DURATION) {
                            // Active phase: opacity remains high
                        } else if (comet.elapsed < COMET_ACTIVE_DURATION + COMET_FADE_DURATION) {
                            // Fade out phase
                            const fadeProgress = (comet.elapsed - COMET_ACTIVE_DURATION) / COMET_FADE_DURATION;
                            comet.material.opacity = THREE.MathUtils.lerp(0.9, 0.0, fadeProgress);
                        } else {
                            // Reset comet position and properties
                            resetComet(comet);
                        }
                        // Move comet based on velocity
                        comet.position.add(comet.velocity.clone().multiplyScalar(delta));
                    });
        
                    // Update Particles
                    const positions = particles.geometry.attributes.position.array;
                    const velocities = particles.geometry.attributes.velocity.array;
                    for (let i = 0; i < particleCount; i++) {
                        positions[i * 3] += velocities[i * 3] * delta;
                        positions[i * 3 + 1] += velocities[i * 3 + 1] * delta;
                        positions[i * 3 + 2] += velocities[i * 3 + 2] * delta;
        
                        // Wrap around logic to keep particles within bounds
                        if (positions[i * 3] > window.innerWidth) positions[i * 3] = -window.innerWidth;
                        if (positions[i * 3] < -window.innerWidth) positions[i * 3] = window.innerWidth;
                        if (positions[i * 3 + 1] > window.innerHeight) positions[i * 3 + 1] = -window.innerHeight;
                        if (positions[i * 3 + 1] < -window.innerHeight) positions[i * 3 + 1] = window.innerHeight;
                        if (positions[i * 3 + 2] > 1500) positions[i * 3 + 2] = -1500;
                        if (positions[i * 3 + 2] < -1500) positions[i * 3 + 2] = 1500;
                    }
                    particles.geometry.attributes.position.needsUpdate = true;
        
                    // Update Satellite
                    satellite.position.add(satellite.velocity.clone().multiplyScalar(delta));
                    satellite.rotation.z += satellite.rotationSpeed * delta;
                    if (satellite.position.x < -window.innerWidth - 200) {
                        resetSatellite();
                    }
        
                    // Update Camera Position Based on Mouse Movement
                    camera.position.x += (mouseX * 500 - camera.position.x) * 0.05;
                    camera.position.y += (mouseY * 300 - camera.position.y) * 0.05;
        
                    // Render Scene with Postprocessing
                    composer.render();
                }
        
                animate();
            }).catch((error) => {
                console.error('Error loading textures:', error);
                // Set default background if texture loading fails
                scene.background = new THREE.Color(0x303030);
            });
        </script>


        <script src="/clockwork.js"></script>
    </body>
</html>
