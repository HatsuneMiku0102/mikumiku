<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MikuMiku | Home</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/styles.css">
</head>

<body>
    <canvas id="techCanvas"></canvas>

    <div class="page-container">
        <div class="title-bar">
            <div class="container">
                <img src="/logo.webp" alt="Logo" class="logo">
                <h1 class="site-title" id="dynamicTitle">MikuMiku</h1>
            </div>
        </div>

        <div id="main-content" class="main-content">
            <!-- Now Playing Section -->
            <div id="now-playing-container" class="box-container">
                <div id="now-playing" class="now-playing">
                    <div class="now-playing-sidebar">
                        <div class="sidebar-item">
                            <span>Channel:</span> <span id="channelName">Loading...</span>
                        </div>
                        <div class="sidebar-item">
                            <span>Views:</span> <span id="viewCount">Loading...</span>
                        </div>
                        <div class="sidebar-item">
                            <span>Uploaded:</span> <span id="publishedDate">Loading...</span>
                        </div>
                    </div>

                    <div class="video-section">
                        <div class="video-title-container">
                            <h2>Currently Playing on YouTube</h2>
                            <p id="videoTitle">Loading...</p>
                        </div>
                        
                        <div class="progress-bar-container" style="display: flex; align-items: center; gap: 1rem; margin-top: 1rem;">
                            <span id="pausedIcon" style="display: none; width: 24px; height: 24px;" aria-label="Video Paused" title="Video Paused">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                                    <rect x="6" y="5" width="4" height="14"></rect>
                                    <rect x="14" y="5" width="4" height="14"></rect>
                                </svg>
                            </span>

                            <div id="progress-bar-container" style="flex-grow: 1;">
                                <canvas id="liquidProgressBar" width="400" height="50"></canvas>
                            </div>
                        </div>

                        <img id="videoThumbnail" src="" alt="Thumbnail of currently playing video" class="video-thumbnail">
                        
                        <div class="progress-times-container">
                            <p id="time-elapsed" class="progress-time">Time Elapsed: --:--</p>
                            <p id="total-duration" class="progress-time">Total Duration: --:--</p>
                            <p id="time-remaining" class="progress-time" style="display: none;">Browsing for: --:--</p>
                        </div>

                        <div id="offline-indicator" style="display: none; color: red; font-weight: bold; margin-top: 1rem;">
                            I’m not on YouTube at the moment, soz :(
                        </div>
                    </div>
                </div>
            </div>

            <!-- Widgets Section -->
            <div class="widgets-container">
                <div class="live-clock box-container">
                    <h3>My Current Time</h3>
                    <div class="clock-container">
                        <div class="clock">
                            <p id="local-time">--:--:--</p>
                            <p id="current-date">24 Sep 2024</p>
                        </div>
                    </div>
                </div>

                <div class="weather-widget box-container">
                    <h3>My Current Weather</h3>
                    <div class="weather-info">
                        <img id="weather-icon" src="" alt="Weather Icon">
                        <p id="weather-description">Loading...</p>
                        <p id="temperature">--°C</p>
                        <p id="humidity">Humidity: --%</p>
                        <p id="wind-speed">Wind: -- m/s</p>
                    </div>
                </div>
            </div>

            <!-- Recently Watched Videos Section -->
            <div class="content-wrapper">
                <div class="now-playing-about-wrapper">
                    <div class="recent-videos-wrapper box-container">
                        <h3>Recently Watched Videos</h3>
                        <div id="recent-videos-container" class="recent-videos-container"></div>
                    </div>

                    <div class="about box-container" id="aboutMe">
                        <h2>About Me</h2>
                        <p>Hey there, I'm Hystoriya, a 24-year-old developer. This is my personal website that I made for no apparent reason. If you find yourself here randomly, then hi :)</p>
                    </div>
                </div>
            </div>
        </div>

        <div id="dynamic-prompt-container" style="display:none;" class="dynamic-prompt">
            <p id="dynamic-prompt-text"></p>
            <button id="close-prompt" style="cursor:pointer;">Close</button>
        </div>

        <footer class="footer">
            <div class="container">
                <p>&copy; 2024 MikuMiku. All rights reserved.</p>
                <p><a href="/admin-login.html">Admin Login</a></p>
            </div>
        </footer>
    </div>

    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.1/moment.min.js"></script>

    <script>
        // Constellation-Based Canvas Background Animation
        const canvas = document.getElementById('techCanvas');
        const ctx = canvas.getContext('2d');
    
        // Resize Canvas to Full Screen
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
    
        // Star Class
        class Star {
            constructor(x, y, radius, twinkleSpeed, color) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.twinkleSpeed = twinkleSpeed;
                this.opacity = Math.random() * 0.7 + 0.3; // Start with opacity between 0.3 and 1
                this.twinkleDirection = Math.random() > 0.5 ? 1 : -1;
                this.color = color; // { r, g, b }
            }
    
            update() {
                this.opacity += this.twinkleSpeed * this.twinkleDirection;
                if (this.opacity <= 0.3) {
                    this.opacity = 0.3;
                    this.twinkleDirection = 1;
                } else if (this.opacity >= 1) {
                    this.opacity = 1;
                    this.twinkleDirection = -1;
                }
            }
    
            draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${this.opacity})`;
                ctx.fill();
            }
        }
    
        // Constellation Class
        class Constellation {
            constructor(x, y, numStars, spread) {
                this.x = x;
                this.y = y;
                this.numStars = numStars;
                this.spread = spread; // How spread out the stars are
                this.stars = [];
                this.connections = [];
    
                this.generateStars();
                this.generateConnections();
            }
    
            generateStars() {
                for (let i = 0; i < this.numStars; i++) {
                    const angle = Math.random() * 2 * Math.PI;
                    const distance = Math.random() * this.spread;
                    const x = this.x + distance * Math.cos(angle);
                    const y = this.y + distance * Math.sin(angle);
                    const radius = Math.random() * 1.5 + 0.5; // Small stars
                    const twinkleSpeed = Math.random() * 0.005 + 0.002;
                    
                    // Random color assignment (e.g., subtle white to blue hues)
                    const colorOptions = [
                        { r: 255, g: 255, b: 255 }, // White
                        { r: 230, g: 240, b: 255 }, // Light Blue
                        { r: 200, g: 220, b: 255 }  // Sky Blue
                    ];
                    const color = colorOptions[Math.floor(Math.random() * colorOptions.length)];
    
                    this.stars.push(new Star(x, y, radius, twinkleSpeed, color));
                }
            }
    
            generateConnections() {
                // Connect stars based on proximity to form constellations
                for (let i = 0; i < this.stars.length; i++) {
                    for (let j = i + 1; j < this.stars.length; j++) {
                        const dx = this.stars[i].x - this.stars[j].x;
                        const dy = this.stars[i].y - this.stars[j].y;
                        const distance = Math.hypot(dx, dy);
                        if (distance < this.spread * 0.5) { // Adjust the multiplier for connection density
                            this.connections.push([i, j]);
                        }
                    }
                }
            }
    
            update() {
                this.stars.forEach(star => star.update());
            }
    
            draw(ctx) {
                // Draw connections
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.lineWidth = 1;
                this.connections.forEach(connection => {
                    const [i, j] = connection;
                    const starA = this.stars[i];
                    const starB = this.stars[j];
                    ctx.beginPath();
                    ctx.moveTo(starA.x, starA.y);
                    ctx.lineTo(starB.x, starB.y);
                    ctx.stroke();
                });
    
                // Draw stars
                this.stars.forEach(star => star.draw(ctx));
            }
        }
    
        // Shooting Star Class (Optional Enhancement)
        class ShootingStar {
            constructor() {
                this.reset();
            }
    
            reset() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height * 0.5; // Appear in the upper half
                this.length = Math.random() * 80 + 20;
                this.speed = Math.random() * 10 + 10;
                this.angle = Math.PI / 4; // 45 degrees
                this.opacity = 1;
                this.alive = true;
            }
    
            update() {
                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed;
                this.opacity -= 0.02;
                if (this.opacity <= 0) {
                    this.alive = false;
                }
            }
    
            draw(ctx) {
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(
                    this.x - Math.cos(this.angle) * this.length,
                    this.y - Math.sin(this.angle) * this.length
                );
                ctx.strokeStyle = `rgba(255, 255, 255, ${this.opacity})`;
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }
    
        // Generate Random Constellations
        const constellations = [];
        const numberOfConstellations = 10; // Adjust based on preference
    
        for (let i = 0; i < numberOfConstellations; i++) {
            const x = Math.random() * canvas.width;
            const y = Math.random() * canvas.height;
            const numStars = Math.floor(Math.random() * 5) + 3; // Each constellation has between 3 to 7 stars
            const spread = Math.random() * 50 + 30; // Spread between 30 to 80 pixels
            constellations.push(new Constellation(x, y, numStars, spread));
        }
    
        // Shooting Stars Management
        const shootingStars = [];
        const shootingStarProbability = 0.002; // Probability per frame to spawn a shooting star
    
        // Twinkling Stars and Shooting Stars Animation
        function animateBackground() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
    
            // Update and draw constellations
            constellations.forEach(constellation => {
                constellation.update();
                constellation.draw(ctx);
            });
    
            // Randomly add shooting stars
            if (Math.random() < shootingStarProbability) {
                shootingStars.push(new ShootingStar());
            }
    
            // Update and draw shooting stars
            for (let i = shootingStars.length - 1; i >= 0; i--) {
                shootingStars[i].update();
                shootingStars[i].draw(ctx);
                if (!shootingStars[i].alive) {
                    shootingStars.splice(i, 1);
                }
            }
    
            requestAnimationFrame(animateBackground);
        }
    
        animateBackground();
    
        // Optional: Regenerate constellations periodically to keep the background dynamic
        setInterval(() => {
            constellations.length = 0; // Clear existing constellations
            for (let i = 0; i < numberOfConstellations; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const numStars = Math.floor(Math.random() * 5) + 3;
                const spread = Math.random() * 50 + 30;
                constellations.push(new Constellation(x, y, numStars, spread));
            }
        }, 60000); // Regenerate every 60 seconds
    </script>


    <script>
        // Handle dynamic title and greeting message
        function getTimeOfDay() {
            const hour = new Date().getHours();
            if (hour < 12) {
                return "Good Morning";
            } else if (hour >= 12 && hour < 18) {
                return "Good Afternoon";
            } else {
                return "Good Evening";
            }
        }

        function setDynamicTitle() {
            const originalTitle = document.title;
            const timeOfDayMessage = getTimeOfDay();

            document.title = timeOfDayMessage;

            const dynamicTitleElement = document.getElementById('dynamicTitle');
            if (dynamicTitleElement) {
                dynamicTitleElement.innerText = timeOfDayMessage;
            }

            setTimeout(() => {
                document.title = originalTitle;
                if (dynamicTitleElement) {
                    dynamicTitleElement.innerText = "MikuMiku"; 
                }
            }, 5000);
        }

        setDynamicTitle();

        document.addEventListener("visibilitychange", function () {
            if (!document.hidden) {
                setDynamicTitle();
            }
        });
    </script>

    <script>
        // Main logic for video state handling and progress bar
        document.addEventListener('DOMContentLoaded', function () {
            let intervalID = null;
            let videoStartTime = null;
            let videoDuration = 0;
            let isVideoPaused = true;
            let isBrowsing = false;
            const MAX_RECENT_VIDEOS = 3;
            let previousVideoData = null;
            const YOUTUBE_API_KEY = 'AIzaSyBylSvnBlU8ZGSzTe3CVHCyyanFi_fNalY'; 
            const OPENWEATHERMAP_API_KEY = 'ce82286b610208fb4ac780a909455a0e'; 
            const CITY_NAME = 'Leeds';
            
            function formatTime(seconds) {
                const minutes = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${minutes}:${secs < 10 ? '0' : ''}${secs}`;
            }

            function clearExistingInterval() {
                if (intervalID) {
                    clearInterval(intervalID);
                    intervalID = null;
                }
            }

            async function fetchYouTubeVideoDetails(videoID) {
                const apiUrl = `https://www.googleapis.com/youtube/v3/videos?id=${videoID}&part=snippet,contentDetails,statistics&key=${YOUTUBE_API_KEY}`;
                try {
                    const response = await fetch(apiUrl);
                    const data = await response.json();
                    if (data.items.length > 0) {
                        const videoData = data.items[0];
                        const snippet = videoData.snippet;
                        const stats = videoData.statistics;
                        const durationISO = videoData.contentDetails.duration;

                        videoDuration = moment.duration(durationISO).asSeconds();
                        const formattedDuration = formatTime(videoDuration);

                        document.getElementById('videoTitle').innerText = snippet.title;
                        document.getElementById('channelName').innerText = snippet.channelTitle;
                        document.getElementById('publishedDate').innerText = new Date(snippet.publishedAt).toLocaleDateString();

                        const viewsFormatted = Number(stats.viewCount).toLocaleString();
                        document.getElementById('viewCount').innerText = `${viewsFormatted} views`;

                        document.getElementById('videoThumbnail').src = snippet.thumbnails.high.url;
                        document.getElementById('total-duration').innerText = `Total Duration: ${formattedDuration}`;

                        return videoDuration;
                    }
                } catch (error) {
                    console.error('Error fetching video details:', error);
                }
                return 0;
            }

            function updateRecentVideosUI(recentVideos) {
                const recentVideosContainer = document.getElementById('recent-videos-container');
                recentVideosContainer.innerHTML = '';
                recentVideos.forEach((video, index) => {
                    const videoElement = document.createElement('div');
                    videoElement.className = 'recent-video-item advanced-video-card';
                    videoElement.style.animationDelay = `${index * 0.1}s`;
                    videoElement.innerHTML = `
                        <a href="${video.url}" target="_blank">
                            <div class="card-content">
                                <img src="${video.thumbnail}" class="recent-video-thumbnail" alt="Thumbnail of ${video.title}">
                                <p class="recent-video-title">${video.title}</p>
                            </div>
                        </a>`;
                    recentVideosContainer.appendChild(videoElement);
                });
            }

            function addVideoToRecent(title, url, thumbnail) {
                let recentVideos = JSON.parse(localStorage.getItem('recentVideos')) || [];
                if (!recentVideos.find(video => video.url === url)) {
                    recentVideos.unshift({ title, url, thumbnail });
                    if (recentVideos.length > MAX_RECENT_VIDEOS) {
                        recentVideos = recentVideos.slice(0, MAX_RECENT_VIDEOS);
                    }
                    localStorage.setItem('recentVideos', JSON.stringify(recentVideos));
                    updateRecentVideosUI(recentVideos);
                }
            }

            const recentVideos = JSON.parse(localStorage.getItem('recentVideos')) || [];
            updateRecentVideosUI(recentVideos);

            const socket = io('https://mikumiku.dev');

            socket.on('connect', () => {
                console.log('Frontend connected to server via Socket.io');
            });

            socket.on('disconnect', () => {
                console.log('Frontend disconnected from server');
            });

            socket.on('nowPlayingUpdate', (data) => {
                const { isOffline, videoUrl, title, currentTime, isPaused } = data;

                const videoTitleElement = document.getElementById('videoTitle');
                const videoThumbnailElement = document.getElementById('videoThumbnail');
                const nowPlayingElement = document.querySelector('.now-playing');
                const offlineIndicator = document.getElementById('offline-indicator');
                const pausedIcon = document.getElementById('pausedIcon');

                if (isOffline) {
                    videoTitleElement.innerText = 'YouTube Tab Closed';
                    nowPlayingElement.classList.add('offline');
                    videoThumbnailElement.classList.add('offline-thumbnail');
                    clearExistingInterval();
                    updateProgress(0);
                    document.getElementById('time-elapsed').innerText = `Time Elapsed: --:--`;
                    document.getElementById('total-duration').innerText = `Total Duration: --:--`;
                    pausedIcon.style.display = 'none';
                    const timeRemaining = document.getElementById('time-remaining');
                    if (timeRemaining) {
                        timeRemaining.style.display = 'none';
                    }
                    offlineIndicator.style.display = 'block';
                } else {
                    nowPlayingElement.classList.remove('offline');
                    videoThumbnailElement.classList.remove('offline-thumbnail');
                    offlineIndicator.style.display = 'none';

                    const videoID = extractYouTubeVideoID(videoUrl);
                    if (!videoID) {
                        return;
                    }

                    if (previousVideoData && previousVideoData.url !== videoUrl) {
                        addVideoToRecent(previousVideoData.title, previousVideoData.url, previousVideoData.thumbnail);
                    }

                    previousVideoData = {
                        title: title || 'No video playing',
                        url: videoUrl,
                        thumbnail: `https://img.youtube.com/vi/${videoID}/hqdefault.jpg`
                    };

                    videoTitleElement.innerText = previousVideoData.title;
                    videoThumbnailElement.src = previousVideoData.thumbnail;
                    videoThumbnailElement.alt = previousVideoData.title;

                    if (videoUrl.includes("youtube.com/") && !videoUrl.includes("/watch")) {
                        clearExistingInterval();
                        isBrowsing = true;
                        updateProgress(0);
                        document.getElementById('time-elapsed').innerText = `Time Elapsed: --:--`;
                        document.getElementById('total-duration').innerText = `Total Duration: --:--`;
                        pausedIcon.style.display = 'none';
                        const timeRemaining = document.getElementById('time-remaining');
                        if (timeRemaining) {
                            timeRemaining.style.display = 'none';
                        }
                    } else {
                        isBrowsing = false;
                        fetchYouTubeVideoDetails(videoID).then((duration) => {
                            if (duration) {
                                videoDuration = duration;
                                videoStartTime = Date.now() - (currentTime * 1000);
                                clearExistingInterval();
                                isVideoPaused = isPaused;
                                if (!isVideoPaused) {
                                    intervalID = setInterval(updateProgressBar, 1000);
                                }
                                document.getElementById('total-duration').innerText = `Total Duration: ${formatTime(videoDuration)}`;
                                const timeRemaining = document.getElementById('time-remaining');
                                if (timeRemaining) {
                                    timeRemaining.style.display = 'none';
                                }
                            }
                        });
                    }

                    if (isPaused) {
                        pausedIcon.style.display = 'inline';
                    } else {
                        pausedIcon.style.display = 'none';
                    }
                }
            });

            function extractYouTubeVideoID(url) {
                const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=|youtube.com\/shorts\/)([^#&?]*).*/;
                const match = url.match(regExp);
                return (match && match[2].length === 11) ? match[2] : null;
            }

            function updateClocks() {
                const now = new Date();
                const localTime = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
                document.getElementById('local-time').textContent = localTime;
                const currentDate = now.toLocaleDateString(undefined, { day: '2-digit', month: 'short', year: 'numeric' });
                document.getElementById('current-date').textContent = currentDate;
            }

            setInterval(updateClocks, 1000);
            updateClocks();

            async function fetchWeather() {
                const apiKey = OPENWEATHERMAP_API_KEY;
                const city = CITY_NAME;
                const units = 'metric';

                try {
                    const response = await fetch(`https://api.openweathermap.org/data/2.5/weather?q=${city}&units=${units}&appid=${apiKey}`);
                    if (!response.ok) {
                        throw new Error('Weather data not available');
                    }
                    const data = await response.json();
                    displayWeather(data);
                } catch (error) {
                    document.getElementById('weather-description').innerText = 'Unable to fetch weather data.';
                    document.getElementById('temperature').innerText = '';
                    document.getElementById('humidity').innerText = '';
                    document.getElementById('wind-speed').innerText = '';
                }
            }

            function displayWeather(data) {
                if (!data || !data.weather) {
                    document.getElementById('weather-description').innerText = 'Weather data unavailable.';
                    return;
                }

                const description = data.weather[0].description;
                const temperature = Math.round(data.main.temp);
                const humidity = data.main.humidity;
                const windSpeed = data.wind.speed;
                const iconCode = data.weather[0].icon;
                const iconUrl = `https://openweathermap.org/img/wn/${iconCode}@2x.png`;
                const weatherMain = data.weather[0].main.toLowerCase();

                document.getElementById('weather-description').innerText = `Condition: ${description}`;
                document.getElementById('temperature').innerText = `Temperature: ${temperature}°C`;
                document.getElementById('humidity').innerText = `Humidity: ${humidity}%`;
                document.getElementById('wind-speed').innerText = `Wind: ${windSpeed} m/s`;

                const weatherWidget = document.querySelector('.weather-widget');
                weatherWidget.classList.remove('clear', 'rain', 'cloudy', 'snow', 'fog');

                if (weatherMain.includes('clear')) {
                    weatherWidget.classList.add('clear');
                } else if (weatherMain.includes('rain')) {
                    weatherWidget.classList.add('rain');
                } else if (weatherMain.includes('cloud')) {
                    weatherWidget.classList.add('cloudy');
                } else if (weatherMain.includes('snow')) {
                    weatherWidget.classList.add('snow');
                } else if (weatherMain.includes('fog') || weatherMain.includes('mist') || weatherMain.includes('haze')) {
                    weatherWidget.classList.add('fog');
                }

                let iconElement = document.getElementById('weather-icon');
                if (!iconElement) {
                    iconElement = document.createElement('img');
                    iconElement.id = 'weather-icon';
                    iconElement.alt = 'Weather Icon';
                    document.querySelector('.weather-info').prepend(iconElement);
                }
                iconElement.src = iconUrl;
                iconElement.style.display = 'block';
            }

            fetchWeather();
            setInterval(fetchWeather, 3600000);

            const liquidCanvas = document.getElementById('liquidProgressBar');
            const liquidCtx = liquidCanvas.getContext('2d');
            const liquidWidth = liquidCanvas.width;
            const liquidHeight = liquidCanvas.height;

            let progress = 0;

            const wave = {
                amplitude: 10,
                wavelength: 100,
                speed: 0.02,
                phase: 0,
            };

            function updateProgress(newProgress) {
                progress = Math.min(Math.max(newProgress, 0), 100);
                document.getElementById('time-elapsed').innerText = `Time Elapsed: ${formatTime((progress / 100) * videoDuration)}`;
            }

            function drawLiquidFill() {
                liquidCtx.clearRect(0, 0, liquidWidth, liquidHeight);
                const fillLevel = liquidHeight - (progress / 100) * liquidHeight;

                liquidCtx.beginPath();
                liquidCtx.moveTo(0, fillLevel);

                for (let x = 0; x <= liquidWidth; x++) {
                    const y = wave.amplitude * Math.sin((2 * Math.PI / wave.wavelength) * x + wave.phase) + fillLevel;
                    liquidCtx.lineTo(x, y);
                }

                liquidCtx.lineTo(liquidWidth, liquidHeight);
                liquidCtx.lineTo(0, liquidHeight);
                liquidCtx.closePath();

                const gradient = liquidCtx.createLinearGradient(0, fillLevel - wave.amplitude, 0, liquidHeight);
                gradient.addColorStop(0, 'rgba(0, 229, 255, 0.6)');
                gradient.addColorStop(0.5, 'rgba(255, 64, 129, 0.6)');
                gradient.addColorStop(1, 'rgba(255, 64, 129, 0.6)');

                liquidCtx.fillStyle = gradient;
                liquidCtx.fill();

                liquidCtx.lineWidth = 2;
                liquidCtx.strokeStyle = '#00e5ff';
                liquidCtx.stroke();
            }

            function animateLiquidProgressBar() {
                wave.phase += wave.speed;
                drawLiquidFill();
                requestAnimationFrame(animateLiquidProgressBar);
            }

            animateLiquidProgressBar();

            function updateProgressBar() {
                if (!isVideoPaused && !isBrowsing && videoDuration > 0) {
                    const currentTimestamp = Date.now();
                    const elapsedTime = (currentTimestamp - videoStartTime) / 1000;
                    if (elapsedTime >= 0 && elapsedTime <= videoDuration) {
                        const progressPercent = (elapsedTime / videoDuration) * 100;
                        updateProgress(progressPercent);
                    } else {
                        clearExistingInterval();
                        updateProgress(100);
                    }
                }
            }

            socket.on('dynamicPrompt', (data) => {
                const promptContainer = document.getElementById('dynamic-prompt-container');
                const promptText = document.getElementById('dynamic-prompt-text');
        
                promptText.innerText = data.message || "A new prompt has arrived!";
                promptContainer.style.display = 'block';
        
                setTimeout(() => {
                    promptContainer.style.display = 'none';
                }, 5000);
        
                document.getElementById('close-prompt').addEventListener('click', () => {
                    promptContainer.style.display = 'none';
                });
            });

            socket.onAny((event, data) => {
                console.log(`Received event: ${event}, Data:`, data);
            });
        });
    </script>
</body>
</html>
