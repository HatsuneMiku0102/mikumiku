    <!DOCTYPE html>
    <html lang="en">
    
    <head>
        <!-- Meta Tags and Title -->
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>mm.dev | Home</title>
    
        <!-- Fonts and Stylesheets -->
        <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
        <link rel="stylesheet" href="/styles.css">
    </head>
    
    <body>
        <div class="page-container">
            <!-- Title Bar -->
            <header class="title-bar" id="titleBar">
                <div class="container">
                    <!-- Left Section: Empty for Alignment -->
                    <div class="left-section"></div>
    
                    <!-- Center Section: "mm.dev" Logo and Title -->
                    <div class="title-wrapper">
                        <a href="/" aria-label="Home" class="logo-link">
                            <!-- The Music Bar SVG Positioned Behind the Title -->
                            <div class="logo-container">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" width="200" height="200">
                                    <!-- Define a gradient with Miku turquoise and hot pink -->
                                    <defs>
                                        <linearGradient id="mikuGradient" x1="0%" y1="0%" x2="100%" y2="0%">
                                            <stop offset="0%" style="stop-color:#00c6ff;stop-opacity:1" />
                                            <stop offset="100%" style="stop-color:#ff4081;stop-opacity:1" />
                                        </linearGradient>
                                    </defs>
                                    <!-- Use the gradient to fill the music bar shape -->
                                    <rect x="10" y="35" width="180" height="30" rx="15" ry="15" fill="url(#mikuGradient)" />
                                </svg>
                            </div>
                            <!-- Site Title -->
                            <span class="site-title">mm.dev</span>
                        </a>
                    </div>
    
                    <!-- Right Section: Menu Button -->
                    <div class="right-section">
                        <button class="menu-button" id="menuButton" aria-label="Open Menu">
                            <!-- Enhanced Musical-themed Menu Icon -->
                            <i class="fas fa-music"></i>
                        </button>
                    </div>
                </div>
            </header>
            <!-- End of Title Bar -->
    
            <!-- Fullscreen Overlay Menu -->
            <nav class="overlay-menu" id="overlayMenu">
                <button class="close-overlay" id="closeOverlay" aria-label="Close Menu">
                    <i class="fas fa-times"></i>
                </button>
                <div class="overlay-content">
                    <a href="/auth" aria-label="Admin Login"><i class="fas fa-user-lock"></i> Admin Login</a>
                    <a href="#aboutMe" aria-label="About Me"><i class="fas fa-info-circle"></i> About Me</a>
                    <!-- Personality Options -->
                    <div class="personality-options">
                        <button id="personalityOption1" class="personality-button"><i class="fas fa-music"></i> Melody</button>
                        <button id="personalityOption2" class="personality-button"><i class="fas fa-headphones"></i> Harmony</button>
                        <button id="personalityOption3" class="personality-button"><i class="fas fa-microphone"></i> Rhythm</button>
                    </div>
                </div>
            </nav>
            <!-- End of Fullscreen Overlay Menu -->
    
            <!-- Now Playing Section -->
            <section class="now-playing-container">
                <div id="nowPlayingBox" class="now-playing" style="position: relative;">
                    <!-- Channel Info on the Left Side -->
                    <aside class="now-playing-sidebar">
                        <div class="sidebar-item">
                            <span><i class="fas fa-tv"></i> Channel:</span> <span id="channelName">Loading...</span>
                        </div>
                        <div class="sidebar-item">
                            <span><i class="fas fa-eye"></i> Views:</span> <span id="viewCount">Loading...</span>
                        </div>
                        <div class="sidebar-item">
                            <span><i class="fas fa-thumbs-up"></i> Likes:</span> <span id="likeCount">Loading...</span>
                        </div>
                        <div class="sidebar-item">
                            <span><i class="fas fa-calendar-day"></i> Uploaded:</span> <span id="publishedDate">Loading...</span>
                        </div>
                        <div class="sidebar-item video-category">
                            <span><i class="fas fa-tag"></i> Category:</span> <span id="videoCategory">Loading...</span>
                        </div>
    
                        <!-- Divider Between Channel Info and Clock -->
                        <hr class="divider">
    
                        <!-- Clock Section -->
                        <section class="clock-section">
                            <p id="greeting" class="greeting"><i class="fas fa-sun"></i> Good morning!</p>
                            <div class="clocks-container">
                                <!-- Digital Clock -->
                                <div class="digital-clock">
                                    <p id="local-time" class="local-time"><i class="fas fa-clock"></i> --:--:--</p>
                                    <p id="current-date" class="current-date"><i class="fas fa-calendar-alt"></i> 24 September 2024</p>
                                    <p id="day-of-week" class="day-of-week"><i class="fas fa-calendar-day"></i> Thursday</p>
                                    <p id="time-zone" class="time-zone"><i class="fas fa-globe"></i> Time Zone: UTC</p>
                                </div>
                                <!-- Analog Clock -->
                                <div class="analog-clock-container">
                                    <canvas id="analog-clock" width="200" height="200" aria-label="Analog Clock"></canvas>
                                </div>
                            </div>
                            <p id="last-visit-message" class="last-visit-message"><i class="fas fa-history"></i> Welcome back!</p>
                        </section>
                    </aside>

                    <!-- End of Channel Info -->
    
                    <!-- Video Section in the Center -->
                    <div class="video-section">
                        <div class="video-title-container">
                            <h2>Currently Playing</h2>
                            <p id="videoTitle">Loading...</p>
                        </div>
    
                        <div class="thumbnail-container">
                            <video id="videoThumbnail" class="video-thumbnail" preload="metadata" controls aria-label="Currently Playing Video">
                                Your browser does not support the video tag.
                            </video>
                            <img id="videoThumbnailImage" src="" alt="Thumbnail" class="video-thumbnail" loading="lazy">
                        </div>
    
                        <div id="offline-indicator" class="offline-indicator">
                            <i class="fas fa-signal-slash"></i> I’m currently offline
                        </div>
    
                        <!-- Progress Bar Container -->
                        <div class="progress-bar-container">
                            <div id="progressBar" class="progress-bar"></div>
                        </div>
    
                        <!-- LIVE Indicator Positioned Below the Progress Bar -->
                        <div class="live-indicator-container">
                            <!-- Live Indicator SVG -->
                            <svg
                                id="liveIcon"
                                xmlns="http://www.w3.org/2000/svg"
                                viewBox="0 0 100 100"
                                width="60"
                                height="60"
                                aria-label="Live Stream Indicator"
                                class="live-icon"
                                role="img"
                                aria-labelledby="liveTitle"
                            >
                                <title id="liveTitle">Live Stream Indicator</title>
                                <circle cx="50" cy="50" r="40" fill="#FF0000" opacity="0.9" />
                                <text
                                    x="50%"
                                    y="55%"
                                    text-anchor="middle"
                                    fill="#FFFFFF"
                                    font-size="20"
                                    font-family="Arial, sans-serif"
                                    dy=".3em"
                                >
                                    LIVE
                                </text>
                            </svg>
                        </div>
    
                        <!-- Time Elapsed Display -->
                        <div id="timeElapsedContainer" class="time-elapsed">
                            <i class="fas fa-clock"></i> <span id="timeElapsed">0s</span>
                        </div>
    
                        <!-- Show Description Button -->
                        <button class="toggle-description" id="toggleDescriptionButton" aria-label="Toggle Description">
                            <i class="fas fa-info-circle"></i> Show Description
                        </button>
    
                        <!-- Loading Spinner -->
                        <div id="loadingSpinner" class="loading-spinner" aria-label="Loading">
                            <i class="fas fa-spinner fa-spin"></i>
                        </div>
                    </div>
                    <!-- End of Video Section -->
    
                    <!-- Divider Between Now Playing and Weather -->
                    <hr class="divider">
    
                    <!-- Weather Section on the Right Side -->
                    <aside class="weather-section">
                        <img id="weather-icon" src="" alt="Weather Icon" class="weather-icon" loading="lazy">
                        <p id="weather-description" class="weather-description"><i class="fas fa-cloud"></i> Loading...</p>
                        <p id="temperature" class="temperature"><i class="fas fa-thermometer-half"></i> --°C</p>
                        <p id="humidity" class="humidity"><i class="fas fa-tint"></i> Humidity: --%</p>
                        <p id="wind-speed" class="wind-speed"><i class="fas fa-wind"></i> Wind: -- m/s</p>
                    </aside>
                    <!-- End of Weather Section -->
                </div>
            </section>
            <!-- End of Now Playing Section -->
    
            <!-- About Section -->
            <section class="content-wrapper">
                <div class="now-playing-about-wrapper">
                    <div class="about" id="aboutMe">
                        <h2>About Me</h2>
                        <p>Hey there, I'm Hystoriya, a 24-year-old developer. This is my personal website that I made for no apparent reason. If you find yourself here randomly, then hi :)</p>
                    </div>
                </div>
            </section>
            <!-- End of About Section -->
    
            <!-- Footer -->
            <footer class="footer">
                <div class="container">
                    <p>&copy; 2024 MikuMiku. All rights reserved.</p>
                    <button id="manageConsentFooter" class="manage-consent-button"><i class="fas fa-cookie-bite"></i> Manage Cookie Preferences</button>
                </div>
            </footer>
            <!-- End of Footer -->
    
            <!-- Chat Box -->
    
            <div id="chat-box" class="chat-box closed" role="dialog" aria-labelledby="chatHeader" aria-modal="true">
                <div class="chat-header">
                    <!-- SVG Logo -->
                    <div class="chat-logo">
                        <svg width="32" height="32" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                            <!-- Example: A simple chat bubble icon -->
                            <path d="M10 10 H90 V70 H70 L50 90 L30 70 H10 Z" fill="#ffffff" stroke="#007BFF" stroke-width="5"/>
                        </svg>
                    </div>
                    <h3 id="chatHeader">Haru AI</h3>
                    <!-- Close Button with SVG Icon -->
                    <button id="close-chat" class="close-chat" aria-label="Close Chat">
                        <svg width="24" height="24" viewBox="0 0 20 20" fill="#ffffff" xmlns="http://www.w3.org/2000/svg">
                            <path d="M10 8.586L3.536 2.122 2.122 3.536 8.586 10l-6.464 6.464 1.414 1.414L10 11.414l6.464 6.464 1.414-1.414L11.414 10l6.464-6.464-1.414-1.414L10 8.586z"/>
                        </svg>
                    </button>
                </div>
                <div id="chat-content" class="chat-content" role="log" aria-live="polite">
                    <!-- Example Initial Bot Message -->
                    <div class="message bot-message">
                        <div class="message-content">
                            <svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="#007BFF" xmlns="http://www.w3.org/2000/svg">
                                <path d="M12 2C6.486 2 2 6.486 2 12s4.486 10 10 10c2.21 0 4.208-.896 5.656-2.344L20 18.414V20h1.586l-1.414-1.414L18.344 17.656C19.792 16.208 20.688 14.21 20.688 12c0-5.514-4.486-10-10-10zm-1 14H7v-2h4v2zm0-4H7v-2h4v2zm6-4h-8v2h8V8z"/>
                            </svg>
                            Hi! I'm Haru, how can I help you today?
                        </div>
                    </div>
                </div>
                <!-- Loading Spinner -->
                <div id="chat-loading" class="chat-loading" aria-hidden="true">
                    <svg class="spinner" width="24" height="24" viewBox="0 0 50 50">
                        <circle class="path" cx="25" cy="25" r="20" fill="none" stroke="#007BFF" stroke-width="5"></circle>
                    </svg>
                    <span>Thinking...</span>
                </div>
                <div class="chat-input-container">
                    <input type="text" id="chat-input" class="chat-input" placeholder="Type your message..." aria-label="Chat Input">
                    <button id="send-message" class="send-message" aria-label="Send Message">
                        <!-- Send Icon -->
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="#ffffff" xmlns="http://www.w3.org/2000/svg">
                            <path d="M2.01 21L23 12 2.01 3v7l15 2-15 2z"/>
                        </svg>
                    </button>
                </div>
            </div>
            <!-- Floating Chat Button -->
            <button id="open-chat" class="open-chat-button" aria-label="Open Chat">
                <!-- Chat Icon -->
                <svg width="24" height="24" viewBox="0 0 24 24" fill="#ffffff" xmlns="http://www.w3.org/2000/svg">
                    <path d="M20 2H4C2.897 2 2 2.897 2 4v12c0 1.103.897 2 2 2h5l4 4 4-4h5c1.103 0 2-.897 2-2V4c0-1.103-.897-2-2-2zm0 14l-3-3H5V4h15v12z"/>
                </svg>
            </button>
            <!-- End of Floating Chat Button -->
    
            <!-- Description Modal -->
            <div id="descriptionModal" class="modal" aria-hidden="true" role="dialog" aria-labelledby="descriptionModalTitle" aria-describedby="descriptionModalDescription">
                <div class="modal-content">
                    <button class="close-button" id="closeDescriptionButton" aria-label="Close Description Modal"><i class="fas fa-times"></i></button>
                    <h2 id="descriptionModalTitle">Description</h2>
                    <p id="descriptionModalDescription">Loading description...</p>
                </div>
            </div>
            <!-- End of Description Modal -->
    
            <!-- Consent Modal -->
            <div id="consentModal" class="modal" aria-hidden="true" role="dialog" aria-labelledby="consentModalTitle" aria-describedby="consentModalDescription">
                <div class="modal-content">
                    <button class="close-button" id="closeConsentModal" aria-label="Close Consent Modal"><i class="fas fa-times"></i></button>
                    <h2 id="consentModalTitle"><i class="fas fa-cookie"></i> Cookie Consent</h2>
                    <p id="consentModalDescription">
                        I use cookies stored in your browser to enhance your experience on my personal website. These cookies are essential for the website's functionality. By clicking "Accept," you consent to their use. You can also manage your cookie preferences in the "Manage Cookie Preferences" section.
                    </p>
                    <div class="consent-buttons">
                        <button id="acceptConsent" class="consent-button"><i class="fas fa-check"></i> Accept</button>
                        <button id="declineConsent" class="consent-button"><i class="fas fa-times"></i> Decline</button>
                    </div>
                </div>
            </div>
            <!-- End of Consent Modal -->
    
            <!-- JavaScript Libraries -->
            <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.1/socket.io.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
            <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.1/moment.min.js"></script>
            <!-- Import Haru AI script -->
            <script src="haru.js"></script>
            <canvas id="techCanvas"></canvas>
    
            <!-- Tracking Script -->
            <script>
                document.addEventListener('DOMContentLoaded', function () {
    
                    if (window.location.pathname !== '/admin') {
    
                        fetch('/track', {
                            method: 'POST',
                            credentials: 'include'
                        })
                        .then(response => response.json())
                        .then(data => {
                            console.log('Geolocation data sent successfully:', data);
                        })
                        .catch(error => {
                            console.error('Error sending geolocation data:', error);
                        });
                    }
                });
            </script>
            <script>
                document.addEventListener('DOMContentLoaded', function () {
                    // Function to add animation classes with staggered delays
                    function animateElements() {
                        // Title Bar Animation
                        const titleBar = document.getElementById('titleBar');
                        if (titleBar) {
                            setTimeout(() => {
                                titleBar.classList.add('animate-title-bar');
                                console.log('Added animate-title-bar to titleBar');
                            }, 100); // Delay of 100ms
                        } else {
                            console.error('Title Bar element not found!');
                        }
            
                        // Now Playing Section Animation
                        const nowPlaying = document.querySelector('.now-playing-container');
                        if (nowPlaying) {
                            setTimeout(() => {
                                nowPlaying.classList.add('animate-now-playing');
                                console.log('Added animate-now-playing to nowPlaying');
                            }, 400); // Delay of 400ms
                        } else {
                            console.error('Now Playing container not found!');
                        }
            
                        // About Me Section Animation
                        const aboutMe = document.querySelector('.about');
                        if (aboutMe) {
                            setTimeout(() => {
                                aboutMe.classList.add('animate-about');
                                console.log('Added animate-about to aboutMe');
                            }, 700); // Delay of 700ms
                        } else {
                            console.error('About Me section not found!');
                        }
            
                        // Footer Animation
                        const footer = document.querySelector('.footer');
                        if (footer) {
                            setTimeout(() => {
                                footer.classList.add('animate-footer');
                                console.log('Added animate-footer to footer');
                            }, 1000); // Delay of 1000ms
                        } else {
                            console.error('Footer element not found!');
                        }
                    }
            
                    animateElements();
            
                    // Title Bar Scroll Effect
                    const titleBarElement = document.getElementById('titleBar');
                    if (titleBarElement) {
                        window.addEventListener('scroll', () => {
                            if (window.scrollY > 50) {
                                titleBarElement.classList.add('scrolled');
                                console.log('Added scrolled class to titleBar');
                            } else {
                                titleBarElement.classList.remove('scrolled');
                                console.log('Removed scrolled class from titleBar');
                            }
                        });
                    } else {
                        console.error('Title Bar element not found for scroll effect!');
                    }
            
                    // Overlay Menu Functionality
                    const menuButton = document.getElementById('menuButton');
                    const overlayMenu = document.getElementById('overlayMenu');
                    const closeOverlay = document.getElementById('closeOverlay');
            
                    if (menuButton && overlayMenu) {
                        menuButton.addEventListener('click', (e) => {
                            e.stopPropagation(); // Prevent event bubbling
                            overlayMenu.classList.add('active');
                            document.body.classList.add('overlay-active');
                            console.log('Overlay menu activated');
                        });
                    } else {
                        console.error('Menu Button or Overlay Menu element not found!');
                    }
            
                    if (closeOverlay && overlayMenu) {
                        closeOverlay.addEventListener('click', (e) => {
                            e.stopPropagation(); // Prevent event bubbling
                            overlayMenu.classList.remove('active');
                            document.body.classList.remove('overlay-active');
                            console.log('Overlay menu deactivated');
                        });
                    } else {
                        console.error('Close Overlay button or Overlay Menu element not found!');
                    }
            
                    // Close menu when clicking outside of it
                    window.addEventListener('click', (event) => {
                        if (event.target === overlayMenu) {
                            overlayMenu.classList.remove('active');
                            document.body.classList.remove('overlay-active');
                            console.log('Overlay menu closed by clicking outside');
                        }
                    });
            
                    // Personality Options Functionality
                    const personalityButtons = document.querySelectorAll('.personality-button');
                    const siteTitle = document.getElementById('dynamicTitle');
            
                    if (personalityButtons.length > 0 && siteTitle) {
                        personalityButtons.forEach(button => {
                            button.addEventListener('click', () => {
                                const personality = button.textContent.trim();
                                changeTitleStyle(personality);
                                setActivePersonalityButton(button);
                            });
                        });
                    } else {
                        if (personalityButtons.length === 0) {
                            console.error('No personality buttons found!');
                        }
                        if (!siteTitle) {
                            console.error('Dynamic Title element not found!');
                        }
                    }
            
                    function changeTitleStyle(personality) {
                        switch(personality) {
                            case 'Melody':
                                siteTitle.setAttribute('fill', 'url(#melodyGradient)');
                                console.log('Changed title style to Melody');
                                break;
                            case 'Harmony':
                                siteTitle.setAttribute('fill', 'url(#harmonyGradient)');
                                console.log('Changed title style to Harmony');
                                break;
                            case 'Rhythm':
                                siteTitle.setAttribute('fill', 'url(#rhythmGradient)');
                                console.log('Changed title style to Rhythm');
                                break;
                            default:
                                siteTitle.setAttribute('fill', 'url(#logoGradient)');
                                console.log('Reverted title style to default');
                        }
                    }
            
                    function setActivePersonalityButton(activeButton) {
                        personalityButtons.forEach(btn => {
                            btn.classList.remove('active');
                        });
                        activeButton.classList.add('active');
                        console.log(`Active personality button set to ${activeButton.textContent.trim()}`);
                    }
                });
            </script>

            <script>
                // [Cookie Consent Script]
                (function () {
                    'use strict';
    
                    const CONFIG = {
                        consentCookieName: 'cookieConsent',
                        consentCookieExpiryDays: 365,
                        consentCookiePath: '/',
                        consentModalId: 'consentModal',
                        acceptButtonId: 'acceptConsent',
                        declineButtonId: 'declineConsent',
                        manageButtonIds: ['manageConsentModal', 'manageConsentFooter'],
                        closeButtonId: 'closeConsentModal',
                        cookieCategories: {
                            necessary: {
                                enabled: true,
                                description: 'Necessary cookies enable core functionalities and security features of the website.'
                            }
                        },
                        focusableSelectors: 'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])',
                    };
    
                    const consentModal = document.getElementById(CONFIG.consentModalId);
                    const acceptButton = document.getElementById(CONFIG.acceptButtonId);
                    const declineButton = document.getElementById(CONFIG.declineButtonId);
                    const closeButton = document.getElementById(CONFIG.closeButtonId);
                    const manageConsentButtons = CONFIG.manageButtonIds.map(id => document.getElementById(id));
    
                    function setCookie(name, value, days, path = '/') {
                        let expires = "";
                        if (days) {
                            const date = new Date();
                            date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
                            expires = "; expires=" + date.toUTCString();
                        }
                        const secure = location.protocol === 'https:' ? "; Secure" : "";
                        const sameSite = "; SameSite=Lax";
                        document.cookie = name + "=" + (value || "") + expires + "; path=" + path + secure + sameSite;
                    }
    
                    function getCookie(name) {
                        const nameEQ = name + "=";
                        const ca = document.cookie.split(';');
                        for (let i = 0; i < ca.length; i++) {
                            let c = ca[i];
                            while (c.charAt(0) === ' ') c = c.substring(1, c.length);
                            if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
                        }
                        return null;
                    }
    
                    function eraseCookie(name, path = '/') {
                        document.cookie = name + '=; Max-Age=-99999999; path=' + path + ';';
                    }
    
                    function trapFocus(modal) {
                        const focusableElements = modal.querySelectorAll(CONFIG.focusableSelectors);
                        if (focusableElements.length === 0) return;
                        const firstFocusableElement = focusableElements[0];
                        const lastFocusableElement = focusableElements[focusableElements.length - 1];
    
                        function handleFocus(event) {
                            if (event.key === 'Tab') {
                                if (event.shiftKey) {
                                    if (document.activeElement === firstFocusableElement) {
                                        event.preventDefault();
                                        lastFocusableElement.focus();
                                    }
                                } else {
                                    if (document.activeElement === lastFocusableElement) {
                                        event.preventDefault();
                                        firstFocusableElement.focus();
                                    }
                                }
                            }
                            if (event.key === 'Escape') {
                                event.preventDefault();
                            }
                        }
    
                        modal.addEventListener('keydown', handleFocus);
                    }
    
                    function showModal() {
                        consentModal.classList.add('active');
                        document.body.classList.add('modal-active');
                        consentModal.setAttribute('aria-hidden', 'false');
    
                        const focusableElements = consentModal.querySelectorAll(CONFIG.focusableSelectors);
                        if (focusableElements.length) {
                            focusableElements[0].focus();
                        }
    
                        trapFocus(consentModal);
                    }
    
                    function hideModal() {
                        consentModal.classList.remove('active');
                        document.body.classList.remove('modal-active');
                        consentModal.setAttribute('aria-hidden', 'true');
                    }
    
                    function initConsentModal() {
                        const existingConsent = getCookie(CONFIG.consentCookieName);
    
                        if (!existingConsent) {
                            showModal();
                        } else {
                            applyConsent(existingConsent);
                        }
    
                        acceptButton.addEventListener('click', function () {
                            setCookie(CONFIG.consentCookieName, JSON.stringify({
                                necessary: true
                            }), CONFIG.consentCookieExpiryDays, CONFIG.consentCookiePath);
                            hideModal();
                            initializeCookies();
                        });
    
                        declineButton.addEventListener('click', function () {
                            setCookie(CONFIG.consentCookieName, JSON.stringify({
                                necessary: false
                            }), CONFIG.consentCookieExpiryDays, CONFIG.consentCookiePath);
                            hideModal();
                            disableCookies();
                        });
    
                        manageConsentButtons.forEach(button => {
                            if (button) {
                                button.addEventListener('click', function (event) {
                                    event.preventDefault();
                                    showModal();
                                });
                            }
                        });
    
                        closeButton.addEventListener('click', function () {
                            alert('Please make a choice regarding cookie usage.');
                        });
    
                        window.addEventListener('click', function (event) {
                            if (event.target === consentModal) {
                                alert('Please make a choice regarding cookie usage.');
                            }
                        });
                    }
    
                    function applyConsent(consentValue) {
                        try {
                            const consent = JSON.parse(consentValue);
                            if (consent.necessary) {
                                initializeCookies(consent);
                            } else {
                                disableCookies();
                            }
                        } catch (error) {
                            console.error('Error parsing consent cookie:', error);
                            showModal();
                        }
                    }
    
                    function initializeCookies(consent) {
                        console.log('Necessary cookies enabled.');
                    }
    
                    function disableCookies() {
                        console.log('Necessary cookies disabled.');
                    }
    
                    function areCookiesEnabled() {
                        const testCookie = 'test_cookie_consent';
                        setCookie(testCookie, 'test', 1);
                        const result = getCookie(testCookie) === 'test';
                        eraseCookie(testCookie);
                        return result;
                    }
    
                    function init() {
                        if (areCookiesEnabled()) {
                            initConsentModal();
                        } else {
                            console.warn('Cookies are disabled in this browser. Consent modal will not be displayed.');
                        }
                    }
    
                    document.addEventListener('DOMContentLoaded', init);
                })();
            </script>
    
            <script>
                // Now Playing Elements and Socket.IO Integration
                const socket = io("https://mikumiku.dev");
                let lastHeartbeatReceived = Date.now();
                let isSessionExpired = false;
                let browsingStartTime = null;
                let browsingInterval = null;
    
                const nowPlayingBox = document.getElementById("nowPlayingBox");
                const videoTitleElement = document.getElementById("videoTitle");
                const videoThumbnailImage = document.getElementById("videoThumbnailImage");
                const videoThumbnailElement = document.getElementById("videoThumbnail");
                const offlineIndicatorElement = document.getElementById("offline-indicator");
                const progressBarElement = document.getElementById("progressBar");
                const channelNameElement = document.getElementById("channelName");
                const viewCountElement = document.getElementById("viewCount");
                const likeCountElement = document.getElementById("likeCount");
                const publishedDateElement = document.getElementById("publishedDate");
                const videoCategoryElement = document.getElementById("videoCategory");
                const videoDescriptionElement = document.getElementById("descriptionModalDescription");
                const timeElapsedElement = document.getElementById("timeElapsed");
                const liveIconElement = document.getElementById("liveIcon"); // LIVE Indicator
    
                function formatNumber(number) {
                    if (typeof number === 'string') {
                        number = number.replace(/,/g, '');
                    }
                    const num = Number(number);
                    return isNaN(num) ? "N/A" : num.toLocaleString();
                }
    
                function clearDisplay() {
                    nowPlayingBox.classList.add("offline");
                    offlineIndicatorElement.style.display = "block";
                    videoTitleElement.textContent = "I’m not on YouTube at the moment, soz :(";
                    videoThumbnailImage.src = "";
                    videoThumbnailImage.style.display = "none";
                    videoThumbnailElement.src = "";
                    videoThumbnailElement.style.display = "none";
                    channelNameElement.textContent = "";
                    viewCountElement.textContent = "";
                    likeCountElement.textContent = "";
                    publishedDateElement.textContent = "";
                    videoCategoryElement.textContent = "";
                    progressBarElement.style.width = "0%";
                    videoDescriptionElement.textContent = "";
                    timeElapsedElement.style.display = "none";
                    liveIconElement.style.display = "none"; // Hide LIVE Icon
                }
    
                function clearVideoPresence() {
                    videoTitleElement.textContent = "";
                    videoThumbnailImage.src = "";
                    videoThumbnailImage.style.display = "none";
                    videoThumbnailElement.src = "";
                    videoThumbnailElement.style.display = "none";
                    channelNameElement.textContent = "";
                    viewCountElement.textContent = "";
                    likeCountElement.textContent = "";
                    publishedDateElement.textContent = "";
                    videoCategoryElement.textContent = "";
                    progressBarElement.style.width = "0%";
                    videoDescriptionElement.textContent = "";
                    liveIconElement.style.display = "none"; // Hide LIVE Icon
                }
    
                function reinitializeSession() {
                    console.warn("[Client] Reinitializing session due to mismatch or timeout.");
                    clearDisplay();
                    isSessionExpired = true;
                }
    
                function formatTimeElapsed(seconds) {
                    const hours = Math.floor(seconds / 3600);
                    const minutes = Math.floor((seconds % 3600) / 60);
                    const remainingSeconds = seconds % 60;
    
                    if (hours > 0) {
                        return `${hours}h ${minutes}m ${remainingSeconds}s`;
                    } else if (minutes > 0) {
                        return `${minutes}m ${remainingSeconds}s`;
                    } else {
                        return `${remainingSeconds}s`;
                    }
                }
    
                function displayVideoPresence(data) {
                    lastHeartbeatReceived = Date.now();
                    nowPlayingBox.classList.remove("offline");
                    offlineIndicatorElement.style.display = "none";
                
                    videoTitleElement.textContent = data.title || "Unknown Title";
                
                    if (data.thumbnail) {
                        videoThumbnailImage.src = data.thumbnail;
                        videoThumbnailImage.style.display = "block";
                        videoThumbnailElement.style.display = "none";
                    } else {
                        videoThumbnailImage.src = "";
                        videoThumbnailElement.style.display = "none";
                    }
                
                    channelNameElement.textContent = data.channelTitle || "Unknown Channel";
                    viewCountElement.textContent = `${formatNumber(data.viewCount)}` || "N/A";
                    likeCountElement.textContent = `${formatNumber(data.likeCount)}` || "N/A";
                
                    if (data.publishedAt) {
                        const publishedDate = new Date(data.publishedAt);
                        publishedDateElement.textContent = ` ${publishedDate.toLocaleDateString()}` || "Published on: N/A";
                    } else {
                        publishedDateElement.textContent = "Published on: N/A";
                    }
                
                    videoCategoryElement.textContent = `${data.category}` || "N/A";
                    videoDescriptionElement.textContent = data.description || "No description available.";
                    handleRealTimeProgress(data);
                    timeElapsedElement.style.display = "none";
                
                    if (data.videoSrc) {
                        videoThumbnailElement.src = data.videoSrc;
                        videoThumbnailElement.style.display = "block";
                        videoThumbnailImage.style.display = "none";
                    } else {
                        videoThumbnailElement.style.display = "none";
                        videoThumbnailImage.style.display = "block";
                    }
                
                    // Handle Live Status
                    if (data.isLive) {
                        liveIconElement.classList.add('active'); // Add active class to trigger animation
                        liveIconElement.style.display = "flex"; // Use 'flex' to utilize CSS flex properties
                    } else {
                        liveIconElement.classList.remove('active'); // Remove active class
                        liveIconElement.style.display = "none"; // Hide the live icon when not live
                    }
                }
    
    
                function handleRealTimeProgress(data) {
                    if (data.duration && data.currentTime) {
                        const progressPercentage = (data.currentTime / data.duration) * 100;
                        progressBarElement.style.width = `${progressPercentage}%`;
                    } else {
                        progressBarElement.style.width = "0%";
                    }
                }
    
                function displayBrowsingPresence(data) {
                    lastHeartbeatReceived = Date.now();
                    nowPlayingBox.classList.remove("offline");
                    offlineIndicatorElement.style.display = "none";
    
                    clearVideoPresence();
    
                    videoTitleElement.textContent = data.title || "Browsing YouTube";
                    videoThumbnailImage.src = data.thumbnail || "";
                    videoThumbnailImage.style.display = "block";
                    videoThumbnailElement.style.display = "none";
                    channelNameElement.textContent = "Browsing...";
                    videoDescriptionElement.textContent = data.description || "Browsing videos on YouTube";
                    progressBarElement.style.width = "0%";
    
                    if (data.timeElapsed !== undefined) {
                        timeElapsedElement.textContent = `Time Elapsed: ${formatTimeElapsed(data.timeElapsed)}`;
                        timeElapsedElement.style.display = "block";
                    }
                }
    
                function updateBrowsingPresence() {
                    if (browsingStartTime !== null) {
                        const timeElapsed = Math.floor((Date.now() - browsingStartTime) / 1000);
                        timeElapsedElement.textContent = `Time Elapsed: ${formatTimeElapsed(timeElapsed)}`;
                        timeElapsedElement.style.display = "block";
    
                        const browsingData = {
                            title: 'YouTube',
                            description: 'Browsing videos',
                            thumbnail: '',
                            timeElapsed: timeElapsed,
                            presenceType: 'browsing'
                        };
                        socket.emit('updateBrowsingPresence', browsingData);
                    }
                }
    
                function startBrowsingPresence() {
                    if (browsingStartTime === null) {
                        browsingStartTime = Date.now();
                    }
                    if (!browsingInterval) {
                        browsingInterval = setInterval(updateBrowsingPresence, 5000);
                    }
                }
    
                function stopBrowsingPresence() {
                    if (browsingInterval) {
                        clearInterval(browsingInterval);
                        browsingInterval = null;
                    }
                    browsingStartTime = null;
                }
    
                socket.on("connect", () => {
                    console.log("[Socket.IO] Connected to server.");
                    isSessionExpired = false;
                    socket.emit('requestLatestData');
                });
    
                socket.on("presenceUpdate", (data) => {
                    if (isSessionExpired) {
                        console.warn("[Client] Ignoring presenceUpdate due to expired session.");
                        return;
                    }
    
                    console.log("[Socket.IO] Received presenceUpdate:", data);
    
                    if (data.presenceType === 'video') {
                        stopBrowsingPresence();
                        displayVideoPresence(data);
                    } else if (data.presenceType === 'browsing') {
                        displayBrowsingPresence(data);
                        startBrowsingPresence();
                    } else {
                        clearDisplay();
                    }
                });
    
                socket.on("reinitializeSession", (data) => {
                    console.warn(`[Socket.IO] Received reinitializeSession: ${JSON.stringify(data)}`);
                    reinitializeSession();
                });
    
                socket.on("sessionExpired", (data) => {
                    console.warn(`[Socket.IO] Session expired for video ID: ${data.videoId}`);
                    reinitializeSession();
                });
    
                socket.on("disconnect", () => {
                    console.warn("[Socket.IO] Disconnected from server.");
                    stopBrowsingPresence();
                    clearDisplay();
                });
    
                setInterval(() => {
                    if (Date.now() - lastHeartbeatReceived > 60000) {
                        console.warn("[Heartbeat] No heartbeat received in the last 60 seconds. Marking as offline.");
                        clearDisplay();
                    }
                }, 5000);
    
                // Modal Toggle Logic
                const descriptionModal = document.getElementById("descriptionModal");
                const closeDescriptionButton = document.getElementById("closeDescriptionButton");
                const toggleDescriptionButton = document.getElementById("toggleDescriptionButton");
    
                toggleDescriptionButton.addEventListener("click", function () {
                    if (descriptionModal.style.display === "block") {
                        descriptionModal.style.display = "none";
                        toggleDescriptionButton.textContent = "Show Description";
                    } else {
                        descriptionModal.style.display = "flex";
                        descriptionModal.classList.add('active');
                        toggleDescriptionButton.textContent = "Hide Description";
                    }
                });
    
                closeDescriptionButton.addEventListener("click", function () {
                    descriptionModal.style.display = "none";
                    descriptionModal.classList.remove('active');
                    toggleDescriptionButton.textContent = "Show Description";
                });
    
                window.addEventListener("click", function (event) {
                    if (event.target === descriptionModal) {
                        descriptionModal.style.display = "none";
                        toggleDescriptionButton.textContent = "Show Description";
                    }
                });
    
    
                // Clock Update Script
                function updateClocks() {
                    const now = new Date();
                    const localTime = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
                    const localTimeElement = document.getElementById('local-time');
                    if (localTimeElement) localTimeElement.textContent = localTime;
                    const currentDate = now.toLocaleDateString(undefined, { day: '2-digit', month: 'short', year: 'numeric' });
                    const currentDateElement = document.getElementById('current-date');
                    if (currentDateElement) currentDateElement.textContent = currentDate;
                }
    
                setInterval(updateClocks, 1000);
                updateClocks();
    
                // Weather Update Script
                const CITY_NAME = 'Leeds';
                async function fetchWeather() {
                    try {
                        const response = await fetch(`/api/weather?city=${encodeURIComponent(CITY_NAME)}`);
                        const data = await response.json();
    
                        if (data.error) {
                            throw new Error(data.error);
                        }
    
                        displayWeather(data);
                    } catch (error) {
                        console.error('Error fetching weather data:', error);
                        const weatherIconElement = document.getElementById('weather-icon');
                        if (weatherIconElement) weatherIconElement.style.display = 'none';
                        document.getElementById('weather-description').innerText = 'Unable to fetch weather data.';
                    }
                }
    
                function displayWeather(data) {
                    const description = data.weather[0].description;
                    const temperature = Math.round(data.main.temp);
                    const humidity = data.main.humidity;
                    const windSpeed = data.wind.speed;
                    const iconCode = data.weather[0].icon;
                    const iconUrl = `https://openweathermap.org/img/wn/${iconCode}@2x.png`;
    
                    document.getElementById('weather-description').innerText = `Condition: ${description}`;
                    document.getElementById('temperature').innerText = `Temperature: ${temperature}°C`;
                    document.getElementById('humidity').innerText = `Humidity: ${humidity}%`;
                    document.getElementById('wind-speed').innerText = `Wind: ${windSpeed} m/s`;
    
                    const weatherIconElement = document.getElementById('weather-icon');
                    if (weatherIconElement) {
                        weatherIconElement.src = iconUrl;
                        weatherIconElement.style.display = 'block';
                    }
                }
    
                setInterval(fetchWeather, 3600000); // Update every hour
                fetchWeather();
            </script>
            
            <script type="module">
                import * as THREE from '/js/three.module.min.js';
                import { EffectComposer } from '/js/postprocessing/EffectComposer.js';
                import { RenderPass } from '/js/postprocessing/RenderPass.js';
                import { UnrealBloomPass } from '/js/postprocessing/UnrealBloomPass.js';
                import { FXAAShader } from '/js/shaders/FXAAShader.js';
                import { ShaderPass } from '/js/postprocessing/ShaderPass.js';
                
                const ChromaticAberrationShader = {
                    uniforms: {
                        "tDiffuse": { value: null },
                        "offset": { value: new THREE.Vector2(0.00055, 0.00055) }
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform sampler2D tDiffuse;
                        uniform vec2 offset;
                        varying vec2 vUv;
                        void main() {
                            vec4 color = vec4(0.0);
                            vec2 redOffset = vUv + offset;
                            vec2 greenOffset = vUv;
                            vec2 blueOffset = vUv - offset;
                            color.r = texture2D(tDiffuse, redOffset).r;
                            color.g = texture2D(tDiffuse, greenOffset).g;
                            color.b = texture2D(tDiffuse, blueOffset).b;
                            color.a = texture2D(tDiffuse, vUv).a;
                            gl_FragColor = color;
                        }
                    `
                };
                
                const canvas = document.getElementById('techCanvas');
                const isLowEnd = navigator.hardwareConcurrency && navigator.hardwareConcurrency <= 2;
                const isSmallScreen = window.innerWidth <= 768;
                const renderer = new THREE.WebGLRenderer({ canvas, antialias: !isLowEnd });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(isSmallScreen ? 1 : window.devicePixelRatio);
                renderer.toneMapping = THREE.ACESFilmicToneMapping;
                renderer.toneMappingExposure = 1.5;
                renderer.outputColorSpace = THREE.SRGBColorSpace;
                
                const scene = new THREE.Scene();
                const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 20000);
                camera.position.set(0, 0, 3000);
                
                const textureLoader = new THREE.TextureLoader();
                textureLoader.load('/textures/pillar.webp', (texture) => {
                    texture.colorSpace = THREE.SRGBColorSpace;
                    texture.encoding = THREE.sRGBEncoding;
                    scene.background = texture;
                }, undefined, () => {
                    scene.background = new THREE.Color(0x303030);
                });
                
                const ambientLight = new THREE.AmbientLight(0x404040, 1.8);
                scene.add(ambientLight);
                
                const hemisphereLight = new THREE.HemisphereLight(0xddddff, 0x555555, 0.5);
                scene.add(hemisphereLight);
                
                camera.layers.enable(0);
                camera.layers.enable(1);
                
                const starTextures = [
                    textureLoader.load('/textures/stars 001.png'),
                    textureLoader.load('/textures/stars 002.png'),
                    textureLoader.load('/textures/stars 003.png'),
                    textureLoader.load('/textures/stars 004.png'),
                    textureLoader.load('/textures/stars 005.png'),
                    textureLoader.load('/textures/stars 006.png')
                ];
                
                function createStaticStarField() {
                    const starCount = isLowEnd ? 25 : 50;
                    for (let i = 0; i < starCount; i++) {
                        const texture = starTextures[Math.floor(Math.random() * starTextures.length)];
                        const starMaterial = new THREE.SpriteMaterial({
                            map: texture,
                            blending: THREE.AdditiveBlending,
                            transparent: true,
                            opacity: 0.8
                        });
                        const star = new THREE.Sprite(starMaterial);
                        star.scale.set(200 + Math.random() * 150, 200 + Math.random() * 150, 1);
                        star.position.set(
                            Math.random() * window.innerWidth * 2 - window.innerWidth,
                            Math.random() * window.innerHeight * 2 - window.innerHeight,
                            -2000 + Math.random() * 1000
                        );
                        scene.add(star);
                    }
                }
                
                const dynamicStarCount = isLowEnd ? 500 : 1000;
                const dynamicPositions = [];
                const dynamicSizes = [];
                const dynamicPhases = [];
                
                for (let i = 0; i < dynamicStarCount; i++) {
                    const x = Math.random() * window.innerWidth * 2 - window.innerWidth;
                    const y = Math.random() * window.innerHeight * 2 - window.innerHeight;
                    const z = Math.random() * 3000 - 1500;
                    dynamicPositions.push(x, y, z);
                    dynamicSizes.push(1 + Math.random() * 2);
                    dynamicPhases.push(Math.random() * Math.PI * 2);
                }
                
                const dynamicStarsGeometry = new THREE.BufferGeometry();
                dynamicStarsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(dynamicPositions, 3));
                dynamicStarsGeometry.setAttribute('size', new THREE.Float32BufferAttribute(dynamicSizes, 1));
                dynamicStarsGeometry.setAttribute('phase', new THREE.Float32BufferAttribute(dynamicPhases, 1));
                
                const starVertexShader = `
                    uniform float time;
                    attribute float size;
                    attribute float phase;
                    varying float vTwinkle;
                    void main() {
                        vTwinkle = abs(sin(time + phase));
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        gl_PointSize = size * (1.0 + vTwinkle * 0.5);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `;
                
                const starFragmentShader = `
                    uniform vec3 starColor;
                    varying float vTwinkle;
                    void main() {
                        float dist = length(gl_PointCoord - vec2(0.5));
                        float alpha = 1.0 - smoothstep(0.4, 0.5, dist);
                        vec3 color = starColor * vTwinkle;
                        gl_FragColor = vec4(color, alpha);
                    }
                `;
                
                const dynamicStarUniforms = {
                    time: { value: 0.0 },
                    starColor: { value: new THREE.Color(0xffffff) }
                };
                
                const dynamicStarsMaterial = new THREE.ShaderMaterial({
                    uniforms: dynamicStarUniforms,
                    vertexShader: starVertexShader,
                    fragmentShader: starFragmentShader,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                
                const dynamicStars = new THREE.Points(dynamicStarsGeometry, dynamicStarsMaterial);
                scene.add(dynamicStars);
                
                const COMET_ACTIVE_DURATION = 7;
                const COMET_FADE_DURATION = 1;
                const cometTexture = textureLoader.load('/textures/comet1.png');
                const cometCount = isLowEnd ? 4 : 8;
                const comets = [];
                
                const particles = [];
                const particleCount = isLowEnd ? 100 : 200;
                const particleTexture = textureLoader.load('/textures/particle_clouds.png');
                
                const burningParticles = [];
                const burningParticleTexture = textureLoader.load('/textures/particle_clouds.png');
                
                function createComet() {
                    const cometMaterial = new THREE.SpriteMaterial({
                        map: cometTexture,
                        blending: THREE.AdditiveBlending,
                        transparent: true,
                        opacity: 0.9,
                        depthWrite: false
                    });
                    const comet = new THREE.Sprite(cometMaterial);
                    const cometSize = 150 + Math.random() * 200;
                    comet.scale.set(cometSize, cometSize, 1);
                    comet.color = new THREE.Color(0xffffff);
                    comet.material.color = comet.color;
                    const cometLight = new THREE.PointLight(comet.color, 4.0 + Math.random() * 3.0, 4000 + Math.random() * 2000, 2);
                    cometLight.position.set(0, 0, 0);
                    cometLight.castShadow = true;
                    comet.add(cometLight);
                    comet.light = cometLight;
                    const spotLight = new THREE.SpotLight(0xffffff, 1.0, 5000, Math.PI / 8, 0.5);
                    spotLight.castShadow = true;
                    spotLight.target = comet;
                    scene.add(spotLight);
                    comet.spotLight = spotLight;
                    comet.layers.set(1);
                    cometLight.layers.set(1);
                    spotLight.layers.set(1);
                    resetComet(comet);
                    comets.push(comet);
                    scene.add(comet);
                }
                
                function createParticle() {
                    const particleMaterial = new THREE.SpriteMaterial({
                        map: particleTexture,
                        blending: THREE.AdditiveBlending,
                        transparent: true,
                        opacity: 0.5,
                        depthWrite: false
                    });
                    const particle = new THREE.Sprite(particleMaterial);
                    const particleSize = 5 + Math.random() * 10;
                    particle.scale.set(particleSize, particleSize, 1);
                    particle.position.set(
                        Math.random() * window.innerWidth * 2 - window.innerWidth,
                        Math.random() * window.innerHeight * 2 - window.innerHeight,
                        Math.random() * 3000 - 1500
                    );
                    const particleLight = new THREE.PointLight(0xffffff, 0.2, 200);
                    particleLight.position.set(0, 0, 0);
                    particle.add(particleLight);
                    scene.add(particle);
                    particles.push(particle);
                }
                
                function createBurningParticle(comet) {
                    const burningMaterial = new THREE.SpriteMaterial({
                        map: burningParticleTexture,
                        blending: THREE.AdditiveBlending,
                        transparent: true,
                        opacity: 1.0,
                        depthWrite: false,
                        color: new THREE.Color(0xff4500)
                    });
                    const burningParticle = new THREE.Sprite(burningMaterial);
                    const size = 10 + Math.random() * 10;
                    burningParticle.scale.set(size, size, 1);
                    burningParticle.position.copy(comet.position);
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 50 + Math.random() * 50;
                    burningParticle.velocity = new THREE.Vector3(Math.cos(angle) * speed, Math.sin(angle) * speed, 0);
                    burningParticle.lifespan = 2.0 + Math.random() * 1.0;
                    burningParticles.push(burningParticle);
                    scene.add(burningParticle);
                }
                
                function resetComet(comet) {
                    comet.position.set(
                        Math.random() * window.innerWidth * 2 - window.innerWidth,
                        window.innerHeight + 500,
                        Math.random() * 1000 - 500
                    );
                    const centerAngle = 5 * Math.PI / 4;
                    const angleVariation = 5 * Math.PI / 180;
                    const angle = centerAngle + (Math.random() * angleVariation * 2 - angleVariation);
                    const speed = 1000 + Math.random() * 200;
                    const velocityX = Math.cos(angle) * speed;
                    const velocityY = Math.sin(angle) * speed;
                    comet.velocity = new THREE.Vector3(velocityX, velocityY, 0);
                    comet.lifespan = COMET_ACTIVE_DURATION + COMET_FADE_DURATION;
                    comet.elapsed = 0;
                    comet.burningOut = false;
                    comet.light.intensity = 4.0 + Math.random() * 3.0;
                    comet.material.opacity = 0.9;
                    const cometSize = 150 + Math.random() * 200;
                    comet.scale.set(cometSize, cometSize, 1);
                    comet.rotation.z = Math.atan2(comet.velocity.y, comet.velocity.x);
                    comet.flashPhase = 0;
                    comet.flashSpeed = Math.random() * 5 + 5;
                    comet.flashAmplitude = 3.0;
                }
                
                function updateComets(delta) {
                    comets.forEach((comet, index) => {
                        comet.elapsed += delta;
                        if (comet.elapsed < COMET_ACTIVE_DURATION) {
                            comet.material.opacity = 0.9;
                            comet.light.intensity = 4.0 + Math.random() * 3.0;
                        } else if (comet.elapsed < COMET_ACTIVE_DURATION + COMET_FADE_DURATION) {
                            const fadeProgress = (comet.elapsed - COMET_ACTIVE_DURATION) / COMET_FADE_DURATION;
                            comet.material.opacity = THREE.MathUtils.lerp(0.9, 0.0, fadeProgress);
                            comet.light.intensity = THREE.MathUtils.lerp(comet.light.intensity, 0.0, fadeProgress);
                            if (index === 0) {
                                comet.material.opacity = THREE.MathUtils.lerp(0.9, 0.2, fadeProgress);
                                comet.light.intensity = THREE.MathUtils.lerp(comet.light.intensity, 1.0, fadeProgress);
                            }
                        } else {
                            resetComet(comet);
                        }
                        comet.position.add(comet.velocity.clone().multiplyScalar(delta));
                        const angle = Math.atan2(comet.velocity.y, comet.velocity.x);
                        comet.rotation.z = angle;
                        if (comet.spotLight) {
                            comet.spotLight.position.copy(comet.position);
                            comet.spotLight.position.z += 500;
                            comet.spotLight.intensity = 1.0 + Math.sin(clock.getElapsedTime() * 2) * 0.5;
                        }
                    });
                }
                
                function updateParticles(delta) {
                    particles.forEach((particle) => {
                        particle.position.x += (Math.random() - 0.5) * 0.5 * delta;
                        particle.position.y += (Math.random() - 0.5) * 0.5 * delta;
                        particle.position.z += (Math.random() - 0.5) * 0.2 * delta;
                    });
                }
                
                function updateBurningParticles(delta) {
                    for (let i = burningParticles.length - 1; i >= 0; i--) {
                        const particle = burningParticles[i];
                        particle.position.add(particle.velocity.clone().multiplyScalar(delta));
                        particle.lifespan -= delta;
                        if (particle.lifespan <= 0) {
                            scene.remove(particle);
                            burningParticles.splice(i, 1);
                            continue;
                        }
                        particle.material.opacity = Math.max(0, particle.lifespan / 2.0);
                    }
                }
                
                function updateCometLightIntensity() {
                    comets.forEach((comet) => {
                        let maxIntensity = 4.0;
                        particles.forEach((particle) => {
                            const distance = comet.position.distanceTo(particle.position);
                            if (distance < 500) {
                                maxIntensity = Math.max(maxIntensity, 4.0 + (500 - distance) / 100);
                            }
                        });
                        comet.light.intensity = maxIntensity;
                    });
                }
                
                let mouseX = 0;
                let mouseY = 0;
                document.addEventListener('mousemove', (event) => {
                    mouseX = (event.clientX / window.innerWidth) * 2 - 1;
                    mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
                });
                
                function updateCamera() {
                    camera.position.x += (mouseX * 500 - camera.position.x) * 0.05;
                    camera.position.y += (mouseY * 300 - camera.position.y) * 0.05;
                }
                
                function spawnComets() {
                    if (comets.length < cometCount) {
                        createComet();
                        const randomDelay = 1500 + Math.random() * 2000;
                        setTimeout(spawnComets, randomDelay);
                    }
                }
                
                const satelliteTexture = textureLoader.load('/textures/sat1.png', () => {}, undefined, () => {});
                satelliteTexture.minFilter = THREE.LinearFilter;
                satelliteTexture.magFilter = THREE.LinearFilter;
                satelliteTexture.generateMipmaps = false;
                
                const satelliteMaterial = new THREE.SpriteMaterial({
                    map: satelliteTexture,
                    transparent: true,
                    blending: THREE.NormalBlending,
                    depthWrite: false,
                    opacity: 1.0
                });
                
                const satellite = new THREE.Sprite(satelliteMaterial);
                satellite.scale.set(250, 250, 1);
                satellite.position.set(
                    window.innerWidth + 200,
                    (Math.random() - 0.5) * window.innerHeight,
                    Math.random() * 1000 - 500
                );
                scene.add(satellite);
                
                const satelliteSpeed = 50;
                const satelliteRotationSpeed = 0.5;
                
                function updateSatellite(delta) {
                    satellite.position.x -= satelliteSpeed * delta;
                    satellite.rotation.z += satelliteRotationSpeed * delta;
                    if (satellite.position.x < -window.innerWidth - 200) {
                        satellite.position.x = window.innerWidth + 200;
                        satellite.position.y = (Math.random() - 0.5) * window.innerHeight;
                        satellite.position.z = Math.random() * 1000 - 500;
                    }
                }
                
                function updateDynamicStars(delta) {
                    dynamicStarUniforms.time.value += delta;
                }
                
                createStaticStarField();
                spawnComets();
                for (let i = 0; i < particleCount; i++) {
                    createParticle();
                }
                
                const renderPass = new RenderPass(scene, camera);
                const composer = new EffectComposer(renderer);
                composer.addPass(renderPass);
                
                const bloomPass = new UnrealBloomPass(
                    new THREE.Vector2(window.innerWidth, window.innerHeight),
                    isLowEnd ? 1.5 : 2.0,
                    0.6,
                    0.9
                );
                composer.addPass(bloomPass);
                
                const chromaticAberrationPass = new ShaderPass(ChromaticAberrationShader);
                chromaticAberrationPass.uniforms['offset'].value = new THREE.Vector2(0.00055, 0.00055);
                if (!isLowEnd) {
                    composer.addPass(chromaticAberrationPass);
                }
                
                const fxaaPass = new ShaderPass(FXAAShader);
                fxaaPass.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight);
                composer.addPass(fxaaPass);
                
                let resizeTimeout;
                window.addEventListener('resize', () => {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => {
                        camera.aspect = window.innerWidth / window.innerHeight;
                        camera.updateProjectionMatrix();
                        renderer.setSize(window.innerWidth, window.innerHeight);
                        composer.setSize(window.innerWidth, window.innerHeight);
                        fxaaPass.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight);
                    }, 200);
                });
                
                const clock = new THREE.Clock();
                
                function animate() {
                    requestAnimationFrame(animate);
                    const delta = clock.getDelta();
                    updateDynamicStars(delta);
                    updateComets(delta);
                    updateParticles(delta);
                    updateBurningParticles(delta);
                    updateCometLightIntensity();
                    updateCamera();
                    updateSatellite(delta);
                    composer.render();
                }
                
                animate();
    
            </script>
    
    
    
    
    
    
            <script src="/clockwork.js"></script>
        </body>
    </html>
