<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MikuMiku | Home</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/styles.css">
</head>

<body>
    <!-- Three.js Canvas -->
    <canvas id="techCanvas"></canvas>

    <div class="page-container">
        <div class="title-bar">
            <div class="container">
                <div class="left-section"></div>
                <div class="center-section">
                    <div class="logo-title-wrapper">
                        <img src="/logo.webp" alt="Logo" class="logo" loading="lazy">
                        <h1 class="site-title" id="dynamicTitle">MikuMiku</h1>
                    </div>
                </div>
                <div class="right-section">
                    <div class="personality-section">
                        <div id="personalityCircle" class="personality-circle"></div>
                        <div id="personalityTextBox" class="personality-text-box">
                            <div id="personalityPhrase" class="personality-text-wrapper"></div>
                        </div>
                    </div>
                    <div class="dropdown">
                        <button class="dropdown-button">Menu</button>
                        <div class="dropdown-content">
                            <a href="/admin-login.html">Admin Login</a>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="now-playing-container">
            <div id="nowPlayingBox" class="now-playing">
                <div class="now-playing-sidebar">
                    <div class="sidebar-item">
                        <span>Channel:</span> <span id="channelName">Loading...</span>
                    </div>
                    <div class="sidebar-item">
                        <span>Views:</span> <span id="viewCount">Loading...</span>
                    </div>
                    <div class="sidebar-item">
                        <span>Likes:</span> <span id="likeCount">Loading...</span>
                    </div>
                    <div class="sidebar-item">
                        <span>Uploaded:</span> <span id="publishedDate">Loading...</span>
                    </div>
                    <div class="sidebar-item video-category">
                        <span>Category:</span> <span id="videoCategory">Loading...</span>
                    </div>
                </div>

                <div class="video-section" style="position: relative;">
                    <div class="video-title-container">
                        <h2>Currently Playing</h2>
                        <p id="videoTitle">Loading...</p>
                    </div>

                    <div class="thumbnail-container" style="position: relative;">
                        <video id="videoThumbnail" class="video-thumbnail" preload="metadata" controls style="width: 100%; height: auto; display: none;">
                            Your browser does not support the video tag.
                        </video>
                        <img id="videoThumbnailImage" src="" alt="Thumbnail" class="video-thumbnail" loading="lazy">
                    </div>

                    <div id="offline-indicator" class="offline-indicator">I’m not on YouTube at the moment, soz :(</div>

                    <div class="progress-bar-container">
                        <div id="progressBar" class="progress-bar"></div>
                    </div>

                    <div id="timeElapsedContainer" class="time-elapsed"><span id="timeElapsed">0s</span></div>

                    <button class="toggle-description" id="toggleDescriptionButton">Show Description</button>

                    <div id="loadingSpinner" class="loading-spinner"></div>
                </div>
            </div>
        </div>

        <div id="descriptionModal" class="modal">
            <div class="modal-content">
                <span class="close-button" id="closeDescriptionButton">&times;</span>
                <h2>Description</h2>
                <p id="videoDescription">Loading description...</p>
            </div>
        </div>

        <div class="widgets-container">
            <div class="live-clock box-container">
                <h3>My Current Time</h3>
                <div class="clock-container">
                    <div class="clock">
                        <p id="local-time">--:--:--</p>
                        <p id="current-date">24 Sep 2024</p>
                    </div>
                </div>
            </div>

            <div class="weather-widget box-container">
                <h3>My Current Weather</h3>
                <div class="weather-info">
                    <img id="weather-icon" src="" alt="Weather Icon" loading="lazy" style="display: none;">
                    <p id="weather-description">Loading...</p>
                    <p id="temperature">--°C</p>
                    <p id="humidity">Humidity: --%</p>
                    <p id="wind-speed">Wind: -- m/s</p>
                </div>
            </div>
        </div>

        <div class="content-wrapper">
            <div class="now-playing-about-wrapper">
                <div class="about box-container" id="aboutMe">
                    <h2>About Me</h2>
                    <p>Hey there, I'm Hystoriya, a 24-year-old developer. This is my personal website that I made for no apparent reason. If you find yourself here randomly, then hi :)</p>
                </div>
            </div>
        </div>

        <!-- Footer -->
        <footer class="footer">
            <div class="container">
                <p>&copy; 2024 MikuMiku. All rights reserved.</p>
                <button id="manageConsentFooter" class="manage-consent-button">Manage Cookie Preferences</button>
            </div>
        </footer>

        <div id="chat-box" class="chat-box">
            <div class="chat-header">
                <h3>Haru AI</h3>
                <button id="close-chat" class="close-chat">X</button>
            </div>
            <div id="chat-content" class="chat-content">
                <div class="message bot-message">Hi! I'm Haru, how can I help you today?</div>
            </div>
            <div class="chat-input-container">
                <input type="text" id="chat-input" class="chat-input" placeholder="Type your message..." />
                <button id="send-message" class="send-message">Send</button>
            </div>
        </div>

        <!-- Consent Modal -->
        <div id="consentModal" class="modal" aria-hidden="true" role="dialog" aria-labelledby="consentModalTitle" aria-describedby="consentModalDescription">
            <div class="modal-content">
                <span class="close-button" id="closeConsentModal">&times;</span>
                <h2 id="consentModalTitle">Cookie Consent</h2>
                <p id="consentModalDescription">
                    I use cookies stored in your browser to enhance your experience on my personal website. These cookies are essential for the website's functionality. By clicking "Accept," you consent to their use. You can also manage your cookie preferences in the "<a href="#" id="manageConsentModal" class="manage-consent-button">Manage Cookie Preferences</a>" section.
                </p>
                <div class="consent-buttons">
                    <button id="acceptConsent" class="consent-button">Accept</button>
                    <button id="declineConsent" class="consent-button">Decline</button>
                </div>
            </div>
        </div>

        <!-- Socket.io Client Library -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.1/socket.io.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.1/moment.min.js"></script>


        <!-- Import Haru AI script -->
        <script src="haru.js"></script>
            
        <script>
            // [Cookie Consent Script]
            (function () {
                'use strict';

                const CONFIG = {
                    consentCookieName: 'cookieConsent',
                    consentCookieExpiryDays: 365,
                    consentCookiePath: '/',
                    consentModalId: 'consentModal',
                    acceptButtonId: 'acceptConsent',
                    declineButtonId: 'declineConsent',
                    manageButtonIds: ['manageConsentModal', 'manageConsentFooter'],
                    closeButtonId: 'closeConsentModal',
                    cookieCategories: {
                        necessary: {
                            enabled: true,
                            description: 'Necessary cookies enable core functionalities and security features of the website.'
                        }
                    },
                    focusableSelectors: 'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])',
                };

                const consentModal = document.getElementById(CONFIG.consentModalId);
                const acceptButton = document.getElementById(CONFIG.acceptButtonId);
                const declineButton = document.getElementById(CONFIG.declineButtonId);
                const closeButton = document.getElementById(CONFIG.closeButtonId);
                const manageConsentButtons = CONFIG.manageButtonIds.map(id => document.getElementById(id));

                function setCookie(name, value, days, path = '/') {
                    let expires = "";
                    if (days) {
                        const date = new Date();
                        date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
                        expires = "; expires=" + date.toUTCString();
                    }
                    const secure = location.protocol === 'https:' ? "; Secure" : "";
                    const sameSite = "; SameSite=Lax";
                    document.cookie = name + "=" + (value || "") + expires + "; path=" + path + secure + sameSite;
                }

                function getCookie(name) {
                    const nameEQ = name + "=";
                    const ca = document.cookie.split(';');
                    for (let i = 0; i < ca.length; i++) {
                        let c = ca[i];
                        while (c.charAt(0) === ' ') c = c.substring(1, c.length);
                        if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
                    }
                    return null;
                }

                function eraseCookie(name, path = '/') {
                    document.cookie = name + '=; Max-Age=-99999999; path=' + path + ';';
                }

                function trapFocus(modal) {
                    const focusableElements = modal.querySelectorAll(CONFIG.focusableSelectors);
                    if (focusableElements.length === 0) return;
                    const firstFocusableElement = focusableElements[0];
                    const lastFocusableElement = focusableElements[focusableElements.length - 1];

                    function handleFocus(event) {
                        if (event.key === 'Tab') {
                            if (event.shiftKey) {
                                if (document.activeElement === firstFocusableElement) {
                                    event.preventDefault();
                                    lastFocusableElement.focus();
                                }
                            } else {
                                if (document.activeElement === lastFocusableElement) {
                                    event.preventDefault();
                                    firstFocusableElement.focus();
                                }
                            }
                        }
                        if (event.key === 'Escape') {
                            event.preventDefault();
                        }
                    }

                    modal.addEventListener('keydown', handleFocus);
                }

                function showModal() {
                    consentModal.classList.add('active');
                    document.body.classList.add('modal-active');
                    consentModal.setAttribute('aria-hidden', 'false');

                    const focusableElements = consentModal.querySelectorAll(CONFIG.focusableSelectors);
                    if (focusableElements.length) {
                        focusableElements[0].focus();
                    }

                    trapFocus(consentModal);
                }

                function hideModal() {
                    consentModal.classList.remove('active');
                    document.body.classList.remove('modal-active');
                    consentModal.setAttribute('aria-hidden', 'true');
                }

                function initConsentModal() {
                    const existingConsent = getCookie(CONFIG.consentCookieName);

                    if (!existingConsent) {
                        showModal();
                    } else {
                        applyConsent(existingConsent);
                    }

                    acceptButton.addEventListener('click', function () {
                        setCookie(CONFIG.consentCookieName, JSON.stringify({
                            necessary: true
                        }), CONFIG.consentCookieExpiryDays, CONFIG.consentCookiePath);
                        hideModal();
                        initializeCookies();
                    });

                    declineButton.addEventListener('click', function () {
                        setCookie(CONFIG.consentCookieName, JSON.stringify({
                            necessary: false
                        }), CONFIG.consentCookieExpiryDays, CONFIG.consentCookiePath);
                        hideModal();
                        disableCookies();
                    });

                    manageConsentButtons.forEach(button => {
                        if (button) {
                            button.addEventListener('click', function (event) {
                                event.preventDefault();
                                showModal();
                            });
                        }
                    });

                    closeButton.addEventListener('click', function () {
                        alert('Please make a choice regarding cookie usage.');
                    });

                    window.addEventListener('click', function (event) {
                        if (event.target === consentModal) {
                            alert('Please make a choice regarding cookie usage.');
                        }
                    });
                }

                function applyConsent(consentValue) {
                    try {
                        const consent = JSON.parse(consentValue);
                        if (consent.necessary) {
                            initializeCookies(consent);
                        } else {
                            disableCookies();
                        }
                    } catch (error) {
                        console.error('Error parsing consent cookie:', error);
                        showModal();
                    }
                }

                function initializeCookies(consent) {
                    console.log('Necessary cookies enabled.');
                }

                function disableCookies() {
                    console.log('Necessary cookies disabled.');
                }

                function areCookiesEnabled() {
                    const testCookie = 'test_cookie_consent';
                    setCookie(testCookie, 'test', 1);
                    const result = getCookie(testCookie) === 'test';
                    eraseCookie(testCookie);
                    return result;
                }

                function init() {
                    if (areCookiesEnabled()) {
                        initConsentModal();
                    } else {
                        console.warn('Cookies are disabled in this browser. Consent modal will not be displayed.');
                    }
                }

                document.addEventListener('DOMContentLoaded', init);
            })();
        </script>

        <script>
            // Now Playing Elements and Socket.IO Integration
            const socket = io("https://mikumiku.dev");
            let lastHeartbeatReceived = Date.now();
            let isSessionExpired = false;
            let browsingStartTime = null;
            let browsingInterval = null;

            const nowPlayingBox = document.getElementById("nowPlayingBox");
            const videoTitleElement = document.getElementById("videoTitle");
            const videoThumbnailImage = document.getElementById("videoThumbnailImage");
            const videoThumbnailElement = document.getElementById("videoThumbnail");
            const offlineIndicatorElement = document.getElementById("offline-indicator");
            const progressBarElement = document.getElementById("progressBar");
            const channelNameElement = document.getElementById("channelName");
            const viewCountElement = document.getElementById("viewCount");
            const likeCountElement = document.getElementById("likeCount");
            const publishedDateElement = document.getElementById("publishedDate");
            const videoCategoryElement = document.getElementById("videoCategory");
            const videoDescriptionElement = document.getElementById("videoDescription");
            const timeElapsedElement = document.getElementById("timeElapsed");

            function formatNumber(number) {
                if (typeof number === 'string') {
                    number = number.replace(/,/g, '');
                }
                const num = Number(number);
                return isNaN(num) ? "N/A" : num.toLocaleString();
            }

            function clearDisplay() {
                nowPlayingBox.classList.add("offline");
                offlineIndicatorElement.style.display = "block";
                videoTitleElement.textContent = "I’m not on YouTube at the moment, soz :(";
                videoThumbnailImage.src = "";
                videoThumbnailImage.style.display = "none";
                videoThumbnailElement.src = "";
                videoThumbnailElement.style.display = "none";
                channelNameElement.textContent = "";
                viewCountElement.textContent = "";
                likeCountElement.textContent = "";
                publishedDateElement.textContent = "";
                videoCategoryElement.textContent = "";
                progressBarElement.style.width = "0%";
                videoDescriptionElement.textContent = "";
                timeElapsedElement.style.display = "none";
            }

            function clearVideoPresence() {
                videoTitleElement.textContent = "";
                videoThumbnailImage.src = "";
                videoThumbnailImage.style.display = "none";
                videoThumbnailElement.src = "";
                videoThumbnailElement.style.display = "none";
                channelNameElement.textContent = "";
                viewCountElement.textContent = "";
                likeCountElement.textContent = "";
                publishedDateElement.textContent = "";
                videoCategoryElement.textContent = "";
                progressBarElement.style.width = "0%";
                videoDescriptionElement.textContent = "";
            }

            function reinitializeSession() {
                console.warn("[Client] Reinitializing session due to mismatch or timeout.");
                clearDisplay();
                isSessionExpired = true;
            }

            function formatTimeElapsed(seconds) {
                const hours = Math.floor(seconds / 3600);
                const minutes = Math.floor((seconds % 3600) / 60);
                const remainingSeconds = seconds % 60;

                if (hours > 0) {
                    return `${hours}h ${minutes}m ${remainingSeconds}s`;
                } else if (minutes > 0) {
                    return `${minutes}m ${remainingSeconds}s`;
                } else {
                    return `${remainingSeconds}s`;
                }
            }

            function displayVideoPresence(data) {
                lastHeartbeatReceived = Date.now();
                nowPlayingBox.classList.remove("offline");
                offlineIndicatorElement.style.display = "none";

                videoTitleElement.textContent = data.title || "Unknown Title";

                if (data.thumbnail) {
                    videoThumbnailImage.src = data.thumbnail;
                    videoThumbnailImage.style.display = "block";
                    videoThumbnailElement.style.display = "none";
                } else {
                    videoThumbnailImage.src = "";
                    videoThumbnailElement.style.display = "none";
                }

                channelNameElement.textContent = data.channelTitle || "Unknown Channel";
                viewCountElement.textContent = `Views: ${formatNumber(data.viewCount)}` || "Views: N/A";
                likeCountElement.textContent = `Likes: ${formatNumber(data.likeCount)}` || "Likes: N/A";

                if (data.publishedAt) {
                    const publishedDate = new Date(data.publishedAt);
                    publishedDateElement.textContent = `Published on: ${publishedDate.toLocaleDateString()}` || "Published on: N/A";
                } else {
                    publishedDateElement.textContent = "Published on: N/A";
                }

                videoCategoryElement.textContent = `Category: ${data.category}` || "Category: N/A";
                videoDescriptionElement.textContent = data.description || "No description available.";
                handleRealTimeProgress(data);
                timeElapsedElement.style.display = "none";

                if (data.videoSrc) {
                    videoThumbnailElement.src = data.videoSrc;
                    videoThumbnailElement.style.display = "block";
                    videoThumbnailImage.style.display = "none";
                } else {
                    videoThumbnailElement.style.display = "none";
                    videoThumbnailImage.style.display = "block";
                }
            }

            function handleRealTimeProgress(data) {
                if (data.duration && data.currentTime) {
                    const progressPercentage = (data.currentTime / data.duration) * 100;
                    progressBarElement.style.width = `${progressPercentage}%`;
                } else {
                    progressBarElement.style.width = "0%";
                }
            }

            function displayBrowsingPresence(data) {
                lastHeartbeatReceived = Date.now();
                nowPlayingBox.classList.remove("offline");
                offlineIndicatorElement.style.display = "none";

                clearVideoPresence();

                videoTitleElement.textContent = data.title || "Browsing YouTube";
                videoThumbnailImage.src = data.thumbnail || "https://i.postimg.cc/GpgNPv0R/custom-browsing-thumbnail.png";
                videoThumbnailImage.style.display = "block";
                videoThumbnailElement.style.display = "none";
                channelNameElement.textContent = "Browsing...";
                videoDescriptionElement.textContent = data.description || "Browsing videos on YouTube";
                progressBarElement.style.width = "0%";

                if (data.timeElapsed !== undefined) {
                    timeElapsedElement.textContent = `Time Elapsed: ${formatTimeElapsed(data.timeElapsed)}`;
                    timeElapsedElement.style.display = "block";
                }
            }

            function updateBrowsingPresence() {
                if (browsingStartTime !== null) {
                    const timeElapsed = Math.floor((Date.now() - browsingStartTime) / 1000);
                    timeElapsedElement.textContent = `Time Elapsed: ${formatTimeElapsed(timeElapsed)}`;
                    timeElapsedElement.style.display = "block";

                    const browsingData = {
                        title: 'YouTube',
                        description: 'Browsing videos',
                        thumbnail: 'https://i.postimg.cc/GpgNPv0R/custom-browsing-thumbnail.png',
                        timeElapsed: timeElapsed,
                        presenceType: 'browsing'
                    };
                    socket.emit('updateBrowsingPresence', browsingData);
                }
            }

            function startBrowsingPresence() {
                if (browsingStartTime === null) {
                    browsingStartTime = Date.now();
                }
                if (!browsingInterval) {
                    browsingInterval = setInterval(updateBrowsingPresence, 5000);
                }
            }

            function stopBrowsingPresence() {
                if (browsingInterval) {
                    clearInterval(browsingInterval);
                    browsingInterval = null;
                }
                browsingStartTime = null;
            }

            socket.on("connect", () => {
                console.log("[Socket.IO] Connected to server.");
                isSessionExpired = false;
                socket.emit('requestLatestData');
            });

            socket.on("presenceUpdate", (data) => {
                if (isSessionExpired) {
                    console.warn("[Client] Ignoring presenceUpdate due to expired session.");
                    return;
                }

                console.log("[Socket.IO] Received presenceUpdate:", data);
                lastHeartbeatReceived = Date.now();

                if (data.presenceType === 'video') {
                    stopBrowsingPresence();
                    displayVideoPresence(data);
                } else if (data.presenceType === 'browsing') {
                    displayBrowsingPresence(data);
                    startBrowsingPresence();
                } else {
                    clearDisplay();
                }
            });

            socket.on("reinitializeSession", (data) => {
                console.warn(`[Socket.IO] Received reinitializeSession: ${JSON.stringify(data)}`);
                reinitializeSession();
            });

            socket.on("sessionExpired", (data) => {
                console.warn(`[Socket.IO] Session expired for video ID: ${data.videoId}`);
                reinitializeSession();
            });

            socket.on("disconnect", () => {
                console.warn("[Socket.IO] Disconnected from server.");
                stopBrowsingPresence();
                clearDisplay();
            });

            setInterval(() => {
                if (Date.now() - lastHeartbeatReceived > 60000) {
                    console.warn("[Heartbeat] No heartbeat received in the last 60 seconds. Marking as offline.");
                    clearDisplay();
                }
            }, 5000);

            // Modal Toggle Logic
            const descriptionModal = document.getElementById("descriptionModal");
            const closeDescriptionButton = document.getElementById("closeDescriptionButton");
            const toggleDescriptionButton = document.getElementById("toggleDescriptionButton");

            toggleDescriptionButton.addEventListener("click", function () {
                if (descriptionModal.style.display === "block") {
                    descriptionModal.style.display = "none";
                    toggleDescriptionButton.textContent = "Show Description";
                } else {
                    descriptionModal.style.display = "block";
                    toggleDescriptionButton.textContent = "Hide Description";
                }
            });

            closeDescriptionButton.addEventListener("click", function () {
                descriptionModal.style.display = "none";
                toggleDescriptionButton.textContent = "Show Description";
            });

            window.addEventListener("click", function (event) {
                if (event.target === descriptionModal) {
                    descriptionModal.style.display = "none";
                    toggleDescriptionButton.textContent = "Show Description";
                }
            });

            // Clock Update Script
            function updateClocks() {
                const now = new Date();
                const localTime = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
                const localTimeElement = document.getElementById('local-time');
                if (localTimeElement) localTimeElement.textContent = localTime;
                const currentDate = now.toLocaleDateString(undefined, { day: '2-digit', month: 'short', year: 'numeric' });
                const currentDateElement = document.getElementById('current-date');
                if (currentDateElement) currentDateElement.textContent = currentDate;
            }

            setInterval(updateClocks, 1000);
            updateClocks();

            // Weather Update Script
            const CITY_NAME = 'Leeds';
            async function fetchWeather() {
                try {
                    const response = await fetch(`/api/weather?city=${encodeURIComponent(CITY_NAME)}`);
                    const data = await response.json();

                    if (data.error) {
                        throw new Error(data.error);
                    }

                    displayWeather(data);
                } catch (error) {
                    console.error('Error fetching weather data:', error);
                    const weatherIconElement = document.getElementById('weather-icon');
                    if (weatherIconElement) weatherIconElement.style.display = 'none';
                    document.getElementById('weather-description').innerText = 'Unable to fetch weather data.';
                }
            }

            function displayWeather(data) {
                const description = data.weather[0].description;
                const temperature = Math.round(data.main.temp);
                const humidity = data.main.humidity;
                const windSpeed = data.wind.speed;
                const iconCode = data.weather[0].icon;
                const iconUrl = `https://openweathermap.org/img/wn/${iconCode}@2x.png`;

                document.getElementById('weather-description').innerText = `Condition: ${description}`;
                document.getElementById('temperature').innerText = `Temperature: ${temperature}°C`;
                document.getElementById('humidity').innerText = `Humidity: ${humidity}%`;
                document.getElementById('wind-speed').innerText = `Wind: ${windSpeed} m/s`;

                const weatherIconElement = document.getElementById('weather-icon');
                if (weatherIconElement) {
                    weatherIconElement.src = iconUrl;
                    weatherIconElement.style.display = 'block';
                }
            }

            setInterval(fetchWeather, 3600000); // Update every hour
            fetchWeather();
        </script>
                
    
        <script type="module">
            import * as THREE from '/js/three.module.min.js';
            import { EffectComposer } from '/js/postprocessing/EffectComposer.js';
            import { RenderPass } from '/js/postprocessing/RenderPass.js';
            import { UnrealBloomPass } from '/js/postprocessing/UnrealBloomPass.js';
            import { FXAAShader } from '/js/shaders/FXAAShader.js';
            import { ShaderPass } from '/js/postprocessing/ShaderPass.js';
        
            const MAIN_LAYER = 0;      
            const COMET_LAYER = 1;     
            const SATELLITE_LAYER = 2; 
            const BLOOM_SCENE = 1;
        
            const COMET_ACTIVE_DURATION = 7;  
            const COMET_FADE_DURATION = 1;    
            const cometCount = 8; // Total number of comets
            const cometSize = 150; // Base size for comets
        
            const clock = new THREE.Clock();
            const canvas = document.getElementById('techCanvas');
            const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 20000);
            const textureLoader = new THREE.TextureLoader();
            const comets = [];
            const burningParticles = [];
            const particles = [];
        
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.5;
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            renderer.autoClear = false;
        
            camera.position.set(0, 0, 3000);
        
            // Load Background Texture
            textureLoader.load('/textures/pillar.webp', (texture) => {
                texture.colorSpace = THREE.SRGBColorSpace;
                texture.encoding = THREE.sRGBEncoding;
                scene.background = texture;
            }, undefined, (err) => {
                console.error('Error loading background texture:', err);
                scene.background = new THREE.Color(0x303030);
            });
        
            // Lighting Setup
            const ambientLight = new THREE.AmbientLight(0x404040, 1.8);
            ambientLight.layers.set(MAIN_LAYER);
            scene.add(ambientLight);
        
            const hemisphereLight = new THREE.HemisphereLight(0xddddff, 0x555555, 0.5);
            hemisphereLight.layers.set(MAIN_LAYER);
            scene.add(hemisphereLight);
        
            // Create Comet
            function createComet() {
                const cometMaterial = new THREE.SpriteMaterial({
                    map: textureLoader.load('/textures/comet1.png'),
                    blending: THREE.AdditiveBlending,
                    transparent: true,
                    opacity: 0.9,
                    depthWrite: false,
                });
        
                const comet = new THREE.Sprite(cometMaterial);
                comet.scale.set(cometSize + Math.random() * 200, cometSize + Math.random() * 200, 1);
                comet.color = new THREE.Color(0xffffff);
                comet.material.color = comet.color;
        
                const cometLight = new THREE.PointLight(comet.color, 4.0 + Math.random() * 3.0, 4000 + Math.random() * 2000, 2);
                cometLight.position.set(0, 0, 0);
                cometLight.castShadow = true;
                comet.add(cometLight);
                comet.light = cometLight;
        
                const spotLight = new THREE.SpotLight(0xffffff, 1.0, 5000, Math.PI / 8, 0.5);
                spotLight.castShadow = true;
                spotLight.target = comet;
                scene.add(spotLight);
                comet.spotLight = spotLight;
        
                comet.layers.set(COMET_LAYER);
                cometLight.layers.set(COMET_LAYER);
                spotLight.layers.set(COMET_LAYER);
        
                resetComet(comet);
                comets.push(comet);
                scene.add(comet);
            }
        
            // Reset Comet
            function resetComet(comet) {
                comet.position.set(
                    Math.random() * window.innerWidth * 2 - window.innerWidth,
                    window.innerHeight + 500,
                    Math.random() * 1000 - 500
                );
        
                const centerAngle = 5 * Math.PI / 4;
                const angleVariation = 5 * Math.PI / 180;
                const angle = centerAngle + (Math.random() * angleVariation * 2 - angleVariation);
        
                const speed = 1000 + Math.random() * 200;
                const velocityX = Math.cos(angle) * speed;
                const velocityY = Math.sin(angle) * speed;
        
                comet.velocity = new THREE.Vector3(velocityX, velocityY, 0);
                comet.lifespan = COMET_ACTIVE_DURATION + COMET_FADE_DURATION;
                comet.elapsed = 0;
                comet.burningOut = false;
                comet.light.intensity = 4.0 + Math.random() * 3.0;
                comet.material.opacity = 0.9;
                comet.rotation.z = Math.atan2(comet.velocity.y, comet.velocity.x);
            }
        
            // Comet Spawning
            let isSpawning = true;
            let spawnTimeout = null;
        
            function spawnCometWithDelay() {
                if (!isSpawning) return;
        
                if (comets.length < cometCount) {
                    createComet();
                    const randomDelay = 1500 + Math.random() * 2000;
                    spawnTimeout = setTimeout(spawnCometWithDelay, randomDelay);
                }
            }
        
            function startSpawningComets() {
                if (isSpawning && !spawnTimeout) {
                    spawnCometWithDelay();
                }
            }
        
            function stopSpawningComets() {
                isSpawning = false;
                if (spawnTimeout) {
                    clearTimeout(spawnTimeout);
                    spawnTimeout = null;
                }
            }
        
            document.addEventListener('visibilitychange', () => {
                if (document.hidden) {
                    stopSpawningComets();
                } else {
                    if (comets.length < cometCount) {
                        isSpawning = true;
                        spawnCometWithDelay();
                    }
                }
            });
        
            // Satellite Setup
            const satelliteTexture = textureLoader.load('/textures/voyager_1.png');
            satelliteTexture.minFilter = THREE.LinearFilter;
            satelliteTexture.magFilter = THREE.LinearFilter;
            satelliteTexture.generateMipmaps = false;
        
            const satelliteMaterial = new THREE.SpriteMaterial({
                map: satelliteTexture,
                transparent: true,
                blending: THREE.NormalBlending,
                depthWrite: false,
                opacity: 0.95
            });
        
            const satellite = new THREE.Sprite(satelliteMaterial);
            satellite.scale.set(150, 150, 1);
            satellite.position.set(window.innerWidth + 200, (Math.random() - 0.5) * window.innerHeight, Math.random() * 1000 - 500);
            satellite.layers.set(SATELLITE_LAYER);
            scene.add(satellite);
        
            // Cosmic Dust Particles
            const particleCount = 200;  
            const particleTexture = textureLoader.load('/textures/particle_clouds.png');
        
            function createParticle() {
                const particleMaterial = new THREE.SpriteMaterial({
                    map: particleTexture,
                    blending: THREE.AdditiveBlending,
                    transparent: true,
                    opacity: 0.5,
                    depthWrite: false,
                });
        
                const particle = new THREE.Sprite(particleMaterial);
                const particleSize = 5 + Math.random() * 10;
                particle.scale.set(particleSize, particleSize, 1);
        
                particle.position.set(
                    Math.random() * window.innerWidth * 2 - window.innerWidth,
                    Math.random() * window.innerHeight * 2 - window.innerHeight,
                    Math.random() * 3000 - 1500
                );
        
                const particleLight = new THREE.PointLight(0xffffff, 0.2, 200);
                particleLight.position.set(0, 0, 0);
                particle.add(particleLight);
                particle.light = particleLight;
        
                particle.layers.set(COMET_LAYER);
                scene.add(particle);
                particles.push(particle);
            }
        
            // Burning Particles for Comet Fire Trail
            function createBurningParticle(comet) {
                const burningMaterial = new THREE.SpriteMaterial({
                    map: textureLoader.load('/textures/particle_clouds.png'),
                    blending: THREE.AdditiveBlending,
                    transparent: true,
                    opacity: 1.0,
                    depthWrite: false,
                    color: new THREE.Color(0xff4500)
                });
        
                const burningParticle = new THREE.Sprite(burningMaterial);
                const size = 10 + Math.random() * 10;
                burningParticle.scale.set(size, size, 1);
        
                burningParticle.position.copy(comet.position);
        
                const angle = Math.random() * Math.PI * 2;
                const speed = 50 + Math.random() * 50;
                burningParticle.velocity = new THREE.Vector3(Math.cos(angle) * speed, Math.sin(angle) * speed, 0);
                burningParticle.lifespan = 2.0 + Math.random() * 1.0;
        
                burningParticle.layers.set(COMET_LAYER);
                burningParticles.push(burningParticle);
                scene.add(burningParticle);
            }
        
            // Camera Movement
            let mouseX = 0;
            let mouseY = 0;
        
            document.addEventListener('mousemove', (event) => {
                mouseX = (event.clientX / window.innerWidth) * 2 - 1;
                mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
            });
        
            function updateCameraPosition(delta) {
                camera.position.x += (mouseX * 500 - camera.position.x) * 0.05;
                camera.position.y += (mouseY * 300 - camera.position.y) * 0.05;
            }
        
            // Update Comets
            function updateComets(delta) {
                comets.forEach((comet, index) => {
                    comet.position.add(comet.velocity.clone().multiplyScalar(delta));
                    comet.elapsed += delta;
        
                    if (comet.elapsed > comet.lifespan) {
                        scene.remove(comet);
                        comets.splice(index, 1);
                    }
                });
            }
        
            // Postprocessing Setup
            const bloomComposer = new EffectComposer(renderer);
            bloomComposer.renderToScreen = false;
            bloomComposer.addPass(new RenderPass(scene, camera));
        
            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                1.5,
                0.4,
                0.85
            );
            bloomComposer.addPass(bloomPass);
        
            const finalComposer = new EffectComposer(renderer);
            finalComposer.addPass(new RenderPass(scene, camera));
        
            const finalPass = new ShaderPass(new THREE.ShaderMaterial({
                uniforms: {
                    baseTexture: { value: null },
                    bloomTexture: { value: null }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D baseTexture;
                    uniform sampler2D bloomTexture;
                    varying vec2 vUv;
                    void main() {
                        vec4 base = texture2D(baseTexture, vUv);
                        vec4 bloom = texture2D(bloomTexture, vUv);
                        gl_FragColor = base + bloom;
                    }
                `
            }), 'baseTexture');
            finalPass.needsSwap = true;
            finalComposer.addPass(finalPass);
        
            // Window Resize Handling
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                bloomComposer.setSize(window.innerWidth, window.innerHeight);
                finalComposer.setSize(window.innerWidth, window.innerHeight);
            });
        
            function darkenNonBloomed(obj) {
                if (obj.isMesh || obj.isSprite) {
                    if (obj.layers.test(BLOOM_SCENE) === false) {
                        materials[obj.uuid] = obj.material;
                        obj.material = darkMaterial;
                    }
                }
            }
        
            function restoreMaterial(obj) {
                if (materials[obj.uuid]) {
                    obj.material = materials[obj.uuid];
                    delete materials[obj.uuid];
                }
            }
        
            // Animation Loop
            function animate() {
                requestAnimationFrame(animate);
                const delta = clock.getDelta();
        
                dynamicStarUniforms.time.value += delta;
                updateComets(delta);
        
                particles.forEach((particle) => {
                    particle.position.x += (Math.random() - 0.5) * 0.5 * delta;
                    particle.position.y += (Math.random() - 0.5) * 0.5 * delta;
                    particle.position.z += (Math.random() - 0.5) * 0.2 * delta;
        
                    particle.position.x += mouseX * 0.02 * delta;
                    particle.position.y += mouseY * 0.02 * delta;
                });
        
                for (let i = burningParticles.length - 1; i >= 0; i--) {
                    const particle = burningParticles[i];
                    particle.position.add(particle.velocity.clone().multiplyScalar(delta));
                    particle.lifespan -= delta;
        
                    if (particle.lifespan <= 0) {
                        scene.remove(particle);
                        burningParticles.splice(i, 1);
                        continue;
                    }
        
                    particle.material.opacity = Math.max(0, particle.lifespan / 2.0);
                }
        
                updateCometLightIntensity();
                updateCameraPosition(delta);
        
                satellite.position.x -= 50 * delta;
                satellite.rotation.z += 0.5 * delta;
        
                if (satellite.position.x < -window.innerWidth - 200) {
                    satellite.position.x = window.innerWidth + 200;
                    satellite.position.y = (Math.random() - 0.5) * window.innerHeight;
                    satellite.position.z = Math.random() * 1000 - 500;
                }
        
                scene.traverse(darkenNonBloomed);
                bloomComposer.render(delta);
                scene.traverse(restoreMaterial);
        
                finalPass.uniforms['bloomTexture'].value = bloomComposer.readBuffer.texture;
                finalComposer.render(delta);
        
                renderer.autoClear = false;
                camera.layers.set(SATELLITE_LAYER);
                renderer.render(scene, camera);
                renderer.autoClear = true;
            }
        
            createStaticStarField();
            spawnCometWithDelay();
            for (let i = 0; i < 200; i++) {
                createParticle();
            }
        
            animate();
        </script>






    </body>
</html>
