<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MikuMiku | Home</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/styles.css">
</head>

<body>
    <!-- Three.js Canvas -->
    <canvas id="techCanvas"></canvas>

    <div class="page-container">

        <!-- Title Bar -->
        <div class="title-bar">
            <div class="container">
                <div class="left-section"></div>
                <div class="center-section">
                    <div class="logo-title-wrapper">
                        <img src="/logo.webp" alt="Logo" class="logo" loading="lazy">
                        <h1 class="site-title" id="dynamicTitle">MikuMiku</h1>
                    </div>
                </div>
                <div class="right-section">
                    <div class="personality-section">
                        <div id="personalityCircle" class="personality-circle"></div>
                        <div id="personalityTextBox" class="personality-text-box">
                            <div id="personalityPhrase" class="personality-text-wrapper"></div>
                        </div>
                    </div>
                    <div class="dropdown">
                        <button class="dropdown-button">Menu</button>
                        <div class="dropdown-content">
                            <a href="/admin-login.html">Admin Login</a>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Now Playing Container -->
        <div class="now-playing-container">
            <div id="nowPlayingBox" class="now-playing">
                <div class="now-playing-sidebar">
                    <div class="sidebar-item">
                        <span>Channel:</span> <span id="channelName">Loading...</span>
                    </div>
                    <div class="sidebar-item">
                        <span>Views:</span> <span id="viewCount">Loading...</span>
                    </div>
                    <div class="sidebar-item">
                        <span>Likes:</span> <span id="likeCount">Loading...</span>
                    </div>
                    <div class="sidebar-item">
                        <span>Uploaded:</span> <span id="publishedDate">Loading...</span>
                    </div>
                    <div class="sidebar-item video-category">
                        <span>Category:</span> <span id="videoCategory">Loading...</span>
                    </div>
                </div>

                <div class="video-section">
                    <div class="video-title-container">
                        <h2>Currently Playing</h2>
                        <p id="videoTitle">Loading...</p>
                    </div>

                    <div class="thumbnail-container">
                        <video id="videoThumbnail" class="video-thumbnail" preload="metadata" controls>
                            Your browser does not support the video tag.
                        </video>
                        <img id="videoThumbnailImage" src="" alt="Thumbnail" class="video-thumbnail" loading="lazy">
                    </div>

                    <div id="offline-indicator" class="offline-indicator">I’m not on YouTube at the moment, soz :(</div>

                    <div class="progress-bar-container">
                        <div id="progressBar" class="progress-bar"></div>
                    </div>

                    <div id="timeElapsedContainer" class="time-elapsed"><span id="timeElapsed">0s</span></div>

                    <button class="toggle-description" id="toggleDescriptionButton">Show Description</button>

                    <div id="loadingSpinner" class="loading-spinner"></div>
                </div>
            </div>
        </div>

        <!-- Description Modal -->
        <div id="descriptionModal" class="modal" aria-hidden="true" role="dialog" aria-labelledby="descriptionModalTitle" aria-describedby="descriptionModalDescription">
            <div class="modal-content">
                <span class="close-button" id="closeDescriptionButton">&times;</span>
                <h2 id="descriptionModalTitle">Description</h2>
                <p id="descriptionModalDescription">Loading description...</p>
            </div>
        </div>

        <!-- Consent Modal -->
        <div id="consentModal" class="modal consent-modal" aria-hidden="true" role="dialog" aria-labelledby="consentModalTitle" aria-describedby="consentModalDescription">
            <div class="modal-content">
                <span class="close-button" id="closeConsentModal">&times;</span>
                <h2 id="consentModalTitle">Cookie Consent</h2>
                <p id="consentModalDescription">
                    I use cookies stored in your browser to enhance your experience on my personal website. These cookies are essential for the website's functionality. By clicking "Accept," you consent to their use.
                </p>
                <div class="consent-buttons">
                    <button id="acceptConsent" class="consent-button">Accept</button>
                    <button id="declineConsent" class="consent-button">Decline</button>
                </div>
            </div>
        </div>

        <!-- Widgets Container -->
        <div class="widgets-container">
            <!-- Live Clock Widget -->
            <div class="live-clock box-container">
                <h3 class="widget-title current-time-title">My Current Time</h3>
                <div class="clock-container">
                    <div class="clock">
                        <p id="local-time">--:--:--</p>
                        <p id="current-date">24 Sep 2024</p>
                    </div>
                </div>
            </div>

            <!-- Weather Widget -->
            <div class="weather-widget box-container">
                <h3 class="widget-title current-weather-title">My Current Weather</h3>
                <div class="weather-info">
                    <img id="weather-icon" src="" alt="Weather Icon" loading="lazy">
                    <p id="weather-description">Loading...</p>
                    <p id="temperature">--°C</p>
                    <p id="humidity">Humidity: --%</p>
                    <p id="wind-speed">Wind: -- m/s</p>
                </div>
            </div>
        </div>

        <!-- About Section -->
        <div class="content-wrapper">
            <div class="now-playing-about-wrapper">
                <div class="about box-container" id="aboutMe">
                    <h2>About Me</h2>
                    <p>Hey there, I'm Hystoriya, a 24-year-old developer. This is my personal website that I made for no apparent reason. If you find yourself here randomly, then hi :)</p>
                </div>
            </div>
        </div>

        <!-- Footer -->
        <footer class="footer">
            <div class="container">
                <p>&copy; 2024 MikuMiku. All rights reserved.</p>
                <!-- The "Manage Cookie Preferences" button has been removed as per your request -->
            </div>
        </footer>

        <!-- Chat Box -->
        <div id="chat-box" class="chat-box">
            <div class="chat-header">
                <h3>Haru AI</h3>
                <button id="close-chat" class="close-chat">X</button>
            </div>
            <div id="chat-content" class="chat-content">
                <div class="message bot-message">Hi! I'm Haru, how can I help you today?</div>
            </div>
            <div class="chat-input-container">
                <input type="text" id="chat-input" class="chat-input" placeholder="Type your message..." />
                <button id="send-message" class="send-message">Send</button>
            </div>
        </div>
    </div>

        <!-- Socket.io Client Library -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.1/socket.io.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.1/moment.min.js"></script>


        <!-- Import Haru AI script -->
        <script src="haru.js"></script>
            
        <script>
            // [Cookie Consent Script]
            (function () {
                'use strict';
        
                const CONFIG = {
                    consentCookieName: 'cookieConsent',
                    consentCookieExpiryDays: 365,
                    consentCookiePath: '/',
                    consentModalId: 'consentModal',
                    acceptButtonId: 'acceptConsent',
                    declineButtonId: 'declineConsent',
                    closeButtonId: 'closeConsentModal',
                    // Removed manageButtonIds as they no longer exist in HTML
                    cookieCategories: {
                        necessary: {
                            enabled: true,
                            description: 'Necessary cookies enable core functionalities and security features of the website.'
                        }
                    },
                    focusableSelectors: 'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])',
                };
        
                const consentModal = document.getElementById(CONFIG.consentModalId);
                const acceptButton = document.getElementById(CONFIG.acceptButtonId);
                const declineButton = document.getElementById(CONFIG.declineButtonId);
                const closeButton = document.getElementById(CONFIG.closeButtonId);
                // Removed manageConsentButtons as they are no longer in HTML
        
                function setCookie(name, value, days, path = '/') {
                    let expires = "";
                    if (days) {
                        const date = new Date();
                        date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
                        expires = "; expires=" + date.toUTCString();
                    }
                    const secure = location.protocol === 'https:' ? "; Secure" : "";
                    const sameSite = "; SameSite=Lax";
                    document.cookie = name + "=" + (value || "") + expires + "; path=" + path + secure + sameSite;
                }
        
                function getCookie(name) {
                    const nameEQ = name + "=";
                    const ca = document.cookie.split(';');
                    for (let i = 0; i < ca.length; i++) {
                        let c = ca[i];
                        while (c.charAt(0) === ' ') c = c.substring(1, c.length);
                        if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
                    }
                    return null;
                }
        
                function eraseCookie(name, path = '/') {
                    document.cookie = name + '=; Max-Age=-99999999; path=' + path + ';';
                }
        
                function trapFocus(modal) {
                    const focusableElements = modal.querySelectorAll(CONFIG.focusableSelectors);
                    if (focusableElements.length === 0) return;
                    const firstFocusableElement = focusableElements[0];
                    const lastFocusableElement = focusableElements[focusableElements.length - 1];
        
                    function handleFocus(event) {
                        if (event.key === 'Tab') {
                            if (event.shiftKey) {
                                if (document.activeElement === firstFocusableElement) {
                                    event.preventDefault();
                                    lastFocusableElement.focus();
                                }
                            } else {
                                if (document.activeElement === lastFocusableElement) {
                                    event.preventDefault();
                                    firstFocusableElement.focus();
                                }
                            }
                        }
                        if (event.key === 'Escape') {
                            event.preventDefault();
                        }
                    }
        
                    modal.addEventListener('keydown', handleFocus);
                }
        
                function showModal() {
                    consentModal.classList.add('active');
                    document.body.classList.add('modal-active');
                    consentModal.setAttribute('aria-hidden', 'false');
        
                    const focusableElements = consentModal.querySelectorAll(CONFIG.focusableSelectors);
                    if (focusableElements.length) {
                        focusableElements[0].focus();
                    }
        
                    trapFocus(consentModal);
                }
        
                function hideModal() {
                    consentModal.classList.remove('active');
                    document.body.classList.remove('modal-active');
                    consentModal.setAttribute('aria-hidden', 'true');
                }
        
                function initConsentModal() {
                    const existingConsent = getCookie(CONFIG.consentCookieName);
        
                    if (!existingConsent) {
                        showModal();
                    } else {
                        applyConsent(existingConsent);
                    }
        
                    acceptButton.addEventListener('click', function () {
                        setCookie(CONFIG.consentCookieName, JSON.stringify({
                            necessary: true
                        }), CONFIG.consentCookieExpiryDays, CONFIG.consentCookiePath);
                        hideModal();
                        initializeCookies();
                    });
        
                    declineButton.addEventListener('click', function () {
                        setCookie(CONFIG.consentCookieName, JSON.stringify({
                            necessary: false
                        }), CONFIG.consentCookieExpiryDays, CONFIG.consentCookiePath);
                        hideModal();
                        disableCookies();
                    });
        
                    closeButton.addEventListener('click', function () {
                        alert('Please make a choice regarding cookie usage.');
                        closeButton.focus(); // Return focus to the close button
                    });
        
                    window.addEventListener('click', function (event) {
                        if (event.target === consentModal) {
                            alert('Please make a choice regarding cookie usage.');
                        }
                    });
                }
        
                function applyConsent(consentValue) {
                    try {
                        const consent = JSON.parse(consentValue);
                        if (consent.necessary) {
                            initializeCookies(consent);
                        } else {
                            disableCookies();
                        }
                    } catch (error) {
                        console.error('Error parsing consent cookie:', error);
                        showModal();
                    }
                }
        
                function initializeCookies(consent) {
                    console.log('Necessary cookies enabled.');
                    // Initialize necessary cookies or functionalities here
                }
        
                function disableCookies() {
                    console.log('Necessary cookies disabled.');
                    // Disable cookies or functionalities here
                }
        
                function areCookiesEnabled() {
                    const testCookie = 'test_cookie_consent';
                    setCookie(testCookie, 'test', 1);
                    const result = getCookie(testCookie) === 'test';
                    eraseCookie(testCookie);
                    return result;
                }
        
                function init() {
                    if (areCookiesEnabled()) {
                        initConsentModal();
                    } else {
                        console.warn('Cookies are disabled in this browser. Consent modal will not be displayed.');
                    }
                }
        
                document.addEventListener('DOMContentLoaded', init);
            })();
        </script>


        <script>
            const socket = io("https://mikumiku.dev");
            let lastHeartbeatReceived = Date.now();
            let isSessionExpired = false;
            let browsingStartTime = null;
            let browsingInterval = null;
            
            const nowPlayingBox = document.getElementById("nowPlayingBox");
            const videoTitleElement = document.getElementById("videoTitle");
            const videoThumbnailImage = document.getElementById("videoThumbnailImage");
            const videoThumbnailElement = document.getElementById("videoThumbnail");
            const offlineIndicatorElement = document.getElementById("offline-indicator");
            const progressBarElement = document.getElementById("progressBar");
            const channelNameElement = document.getElementById("channelName");
            const viewCountElement = document.getElementById("viewCount");
            const likeCountElement = document.getElementById("likeCount");
            const publishedDateElement = document.getElementById("publishedDate");
            const videoCategoryElement = document.getElementById("videoCategory");
            const videoDescriptionElement = document.getElementById("descriptionModalDescription"); // Updated line
            const timeElapsedElement = document.getElementById("timeElapsed");

            function formatNumber(number) {
                if (typeof number === 'string') {
                    number = number.replace(/,/g, '');
                }
                const num = Number(number);
                return isNaN(num) ? "N/A" : num.toLocaleString();
            }

            function clearDisplay() {
                nowPlayingBox.classList.add("offline");
                offlineIndicatorElement.style.display = "block";
                videoTitleElement.textContent = "I’m not on YouTube at the moment, soz :(";
                videoThumbnailImage.src = "";
                videoThumbnailImage.style.display = "none";
                videoThumbnailElement.src = "";
                videoThumbnailElement.style.display = "none";
                channelNameElement.textContent = "";
                viewCountElement.textContent = "";
                likeCountElement.textContent = "";
                publishedDateElement.textContent = "";
                videoCategoryElement.textContent = "";
                progressBarElement.style.width = "0%";
                videoDescriptionElement.textContent = "";
                timeElapsedElement.style.display = "none";
            }

            function clearVideoPresence() {
                videoTitleElement.textContent = "";
                videoThumbnailImage.src = "";
                videoThumbnailImage.style.display = "none";
                videoThumbnailElement.src = "";
                videoThumbnailElement.style.display = "none";
                channelNameElement.textContent = "";
                viewCountElement.textContent = "";
                likeCountElement.textContent = "";
                publishedDateElement.textContent = "";
                videoCategoryElement.textContent = "";
                progressBarElement.style.width = "0%";
                videoDescriptionElement.textContent = "";
            }

            function reinitializeSession() {
                console.warn("[Client] Reinitializing session due to mismatch or timeout.");
                clearDisplay();
                isSessionExpired = true;
            }

            function formatTimeElapsed(seconds) {
                const hours = Math.floor(seconds / 3600);
                const minutes = Math.floor((seconds % 3600) / 60);
                const remainingSeconds = seconds % 60;

                if (hours > 0) {
                    return `${hours}h ${minutes}m ${remainingSeconds}s`;
                } else if (minutes > 0) {
                    return `${minutes}m ${remainingSeconds}s`;
                } else {
                    return `${remainingSeconds}s`;
                }
            }

            function displayVideoPresence(data) {
                lastHeartbeatReceived = Date.now();
                nowPlayingBox.classList.remove("offline");
                offlineIndicatorElement.style.display = "none";

                videoTitleElement.textContent = data.title || "Unknown Title";

                if (data.thumbnail) {
                    videoThumbnailImage.src = data.thumbnail;
                    videoThumbnailImage.style.display = "block";
                    videoThumbnailElement.style.display = "none";
                } else {
                    videoThumbnailImage.src = "";
                    videoThumbnailElement.style.display = "none";
                }

                channelNameElement.textContent = data.channelTitle || "Unknown Channel";
                viewCountElement.textContent = formatNumber(data.viewCount) || "N/A";
                likeCountElement.textContent = formatNumber(data.likeCount) || "N/A";

                if (data.publishedAt) {
                    const publishedDate = new Date(data.publishedAt);
                    publishedDateElement.textContent = `Published on: ${publishedDate.toLocaleDateString()}` || "Published on: N/A";
                } else {
                    publishedDateElement.textContent = "Published on: N/A";
                }

                videoCategoryElement.textContent = data.category || "N/A";
                videoDescriptionElement.textContent = data.description || "No description available.";
                handleRealTimeProgress(data);
                timeElapsedElement.style.display = "none";

                if (data.videoSrc) {
                    videoThumbnailElement.src = data.videoSrc;
                    videoThumbnailElement.style.display = "block";
                    videoThumbnailImage.style.display = "none";
                } else {
                    videoThumbnailElement.style.display = "none";
                    videoThumbnailImage.style.display = "block";
                }
            }

            function handleRealTimeProgress(data) {
                if (data.duration && data.currentTime) {
                    const progressPercentage = (data.currentTime / data.duration) * 100;
                    progressBarElement.style.width = `${progressPercentage}%`;
                } else {
                    progressBarElement.style.width = "0%";
                }
            }

            function displayBrowsingPresence(data) {
                lastHeartbeatReceived = Date.now();
                nowPlayingBox.classList.remove("offline");
                offlineIndicatorElement.style.display = "none";

                clearVideoPresence();

                videoTitleElement.textContent = data.title || "Browsing YouTube";
                videoThumbnailImage.src = data.thumbnail || "https://i.postimg.cc/GpgNPv0R/custom-browsing-thumbnail.png";
                videoThumbnailImage.style.display = "block";
                videoThumbnailElement.style.display = "none";
                channelNameElement.textContent = "Browsing...";
                videoDescriptionElement.textContent = data.description || "Browsing videos on YouTube";
                progressBarElement.style.width = "0%";

                if (data.timeElapsed !== undefined) {
                    timeElapsedElement.textContent = `Time Elapsed: ${formatTimeElapsed(data.timeElapsed)}`;
                    timeElapsedElement.style.display = "block";
                }
            }

            function updateBrowsingPresence() {
                if (browsingStartTime !== null) {
                    const timeElapsed = Math.floor((Date.now() - browsingStartTime) / 1000);
                    timeElapsedElement.textContent = `Time Elapsed: ${formatTimeElapsed(timeElapsed)}`;
                    timeElapsedElement.style.display = "block";

                    const browsingData = {
                        title: 'YouTube',
                        description: 'Browsing videos',
                        thumbnail: 'https://i.postimg.cc/GpgNPv0R/custom-browsing-thumbnail.png',
                        timeElapsed: timeElapsed,
                        presenceType: 'browsing'
                    };
                    socket.emit('updateBrowsingPresence', browsingData);
                }
            }

            function startBrowsingPresence() {
                if (browsingStartTime === null) {
                    browsingStartTime = Date.now();
                }
                if (!browsingInterval) {
                    browsingInterval = setInterval(updateBrowsingPresence, 5000);
                }
            }

            function stopBrowsingPresence() {
                if (browsingInterval) {
                    clearInterval(browsingInterval);
                    browsingInterval = null;
                }
                browsingStartTime = null;
            }

            socket.on("connect", () => {
                console.log("[Socket.IO] Connected to server.");
                isSessionExpired = false;
                socket.emit('requestLatestData');
            });

            socket.on("presenceUpdate", (data) => {
                if (isSessionExpired) {
                    console.warn("[Client] Ignoring presenceUpdate due to expired session.");
                    return;
                }

                console.log("[Socket.IO] Received presenceUpdate:", data);
                lastHeartbeatReceived = Date.now();

                if (data.presenceType === 'video') {
                    stopBrowsingPresence();
                    displayVideoPresence(data);
                } else if (data.presenceType === 'browsing') {
                    displayBrowsingPresence(data);
                    startBrowsingPresence();
                } else {
                    clearDisplay();
                }
            });

            socket.on("reinitializeSession", (data) => {
                console.warn(`[Socket.IO] Received reinitializeSession: ${JSON.stringify(data)}`);
                reinitializeSession();
            });

            socket.on("sessionExpired", (data) => {
                console.warn(`[Socket.IO] Session expired for video ID: ${data.videoId}`);
                reinitializeSession();
            });

            socket.on("disconnect", () => {
                console.warn("[Socket.IO] Disconnected from server.");
                stopBrowsingPresence();
                clearDisplay();
            });

            setInterval(() => {
                if (Date.now() - lastHeartbeatReceived > 60000) {
                    console.warn("[Heartbeat] No heartbeat received in the last 60 seconds. Marking as offline.");
                    clearDisplay();
                }
            }, 5000);

            // Modal Toggle Logic
            const descriptionModal = document.getElementById("descriptionModal");
            const closeDescriptionButton = document.getElementById("closeDescriptionButton");
            const toggleDescriptionButton = document.getElementById("toggleDescriptionButton");

            toggleDescriptionButton.addEventListener("click", function () {
                if (descriptionModal.style.display === "block") {
                    descriptionModal.style.display = "none";
                    toggleDescriptionButton.textContent = "Show Description";
                } else {
                    descriptionModal.style.display = "block";
                    toggleDescriptionButton.textContent = "Hide Description";
                }
            });

            closeDescriptionButton.addEventListener("click", function () {
                descriptionModal.style.display = "none";
                toggleDescriptionButton.textContent = "Show Description";
            });

            window.addEventListener("click", function (event) {
                if (event.target === descriptionModal) {
                    descriptionModal.style.display = "none";
                    toggleDescriptionButton.textContent = "Show Description";
                }
            });

            // Clock Update Script
            function updateClocks() {
                const now = new Date();
                const localTime = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
                const localTimeElement = document.getElementById('local-time');
                if (localTimeElement) localTimeElement.textContent = localTime;
                const currentDate = now.toLocaleDateString(undefined, { day: '2-digit', month: 'short', year: 'numeric' });
                const currentDateElement = document.getElementById('current-date');
                if (currentDateElement) currentDateElement.textContent = currentDate;
            }

            setInterval(updateClocks, 1000);
            updateClocks();

            // Weather Update Script
            const CITY_NAME = 'Leeds';
            async function fetchWeather() {
                try {
                    const response = await fetch(`/api/weather?city=${encodeURIComponent(CITY_NAME)}`);
                    const data = await response.json();

                    if (data.error) {
                        throw new Error(data.error);
                    }

                    displayWeather(data);
                } catch (error) {
                    console.error('Error fetching weather data:', error);
                    const weatherIconElement = document.getElementById('weather-icon');
                    if (weatherIconElement) weatherIconElement.style.display = 'none';
                    document.getElementById('weather-description').innerText = 'Unable to fetch weather data.';
                }
            }

            function displayWeather(data) {
                const description = data.weather[0].description;
                const temperature = Math.round(data.main.temp);
                const humidity = data.main.humidity;
                const windSpeed = data.wind.speed;
                const iconCode = data.weather[0].icon;
                const iconUrl = `https://openweathermap.org/img/wn/${iconCode}@2x.png`;

                document.getElementById('weather-description').innerText = `Condition: ${description}`;
                document.getElementById('temperature').innerText = `Temperature: ${temperature}°C`;
                document.getElementById('humidity').innerText = `Humidity: ${humidity}%`;
                document.getElementById('wind-speed').innerText = `Wind: ${windSpeed} m/s`;

                const weatherIconElement = document.getElementById('weather-icon');
                if (weatherIconElement) {
                    weatherIconElement.src = iconUrl;
                    weatherIconElement.style.display = 'block';
                }
            }

            setInterval(fetchWeather, 3600000); // Update every hour
            fetchWeather();
        </script>

        <script type="module">
            import * as THREE from '/js/three.module.min.js';
            import { EffectComposer } from '/js/postprocessing/EffectComposer.js';
            import { RenderPass } from '/js/postprocessing/RenderPass.js';
            import { UnrealBloomPass } from '/js/postprocessing/UnrealBloomPass.js';
            import { FXAAShader } from '/js/shaders/FXAAShader.js';
            import { ShaderPass } from '/js/postprocessing/ShaderPass.js';
            
            const ChromaticAberrationShader = {
                uniforms: {
                    "tDiffuse": { value: null },
                    "offset": { value: new THREE.Vector2(0.00055, 0.00055) }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D tDiffuse;
                    uniform vec2 offset;
                    varying vec2 vUv;
                    void main() {
                        vec4 color = vec4(0.0);
                        vec2 redOffset = vUv + offset;
                        vec2 greenOffset = vUv;
                        vec2 blueOffset = vUv - offset;
                        color.r = texture2D(tDiffuse, redOffset).r;
                        color.g = texture2D(tDiffuse, greenOffset).g;
                        color.b = texture2D(tDiffuse, blueOffset).b;
                        color.a = texture2D(tDiffuse, vUv).a;
                        gl_FragColor = color;
                    }
                `
            };
            
            const canvas = document.getElementById('techCanvas');
            const isLowEnd = navigator.hardwareConcurrency && navigator.hardwareConcurrency <= 2;
            const isSmallScreen = window.innerWidth <= 768;
            const renderer = new THREE.WebGLRenderer({ canvas, antialias: !isLowEnd });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(isSmallScreen ? 1 : window.devicePixelRatio);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.5;
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 20000);
            camera.position.set(0, 0, 3000);
            
            const textureLoader = new THREE.TextureLoader();
            textureLoader.load('/textures/pillar.webp', (texture) => {
                texture.colorSpace = THREE.SRGBColorSpace;
                texture.encoding = THREE.sRGBEncoding;
                scene.background = texture;
            }, undefined, () => {
                scene.background = new THREE.Color(0x303030);
            });
            
            const ambientLight = new THREE.AmbientLight(0x404040, 1.8);
            scene.add(ambientLight);
            
            const hemisphereLight = new THREE.HemisphereLight(0xddddff, 0x555555, 0.5);
            scene.add(hemisphereLight);
            
            camera.layers.enable(0);
            camera.layers.enable(1);
            
            const starTextures = [
                textureLoader.load('/textures/stars 001.png'),
                textureLoader.load('/textures/stars 002.png'),
                textureLoader.load('/textures/stars 003.png'),
                textureLoader.load('/textures/stars 004.png'),
                textureLoader.load('/textures/stars 005.png'),
                textureLoader.load('/textures/stars 006.png')
            ];
            
            function createStaticStarField() {
                const starCount = isLowEnd ? 25 : 50;
                for (let i = 0; i < starCount; i++) {
                    const texture = starTextures[Math.floor(Math.random() * starTextures.length)];
                    const starMaterial = new THREE.SpriteMaterial({
                        map: texture,
                        blending: THREE.AdditiveBlending,
                        transparent: true,
                        opacity: 0.8
                    });
                    const star = new THREE.Sprite(starMaterial);
                    star.scale.set(200 + Math.random() * 150, 200 + Math.random() * 150, 1);
                    star.position.set(
                        Math.random() * window.innerWidth * 2 - window.innerWidth,
                        Math.random() * window.innerHeight * 2 - window.innerHeight,
                        -2000 + Math.random() * 1000
                    );
                    scene.add(star);
                }
            }
            
            const dynamicStarCount = isLowEnd ? 500 : 1000;
            const dynamicPositions = [];
            const dynamicSizes = [];
            const dynamicPhases = [];
            
            for (let i = 0; i < dynamicStarCount; i++) {
                const x = Math.random() * window.innerWidth * 2 - window.innerWidth;
                const y = Math.random() * window.innerHeight * 2 - window.innerHeight;
                const z = Math.random() * 3000 - 1500;
                dynamicPositions.push(x, y, z);
                dynamicSizes.push(1 + Math.random() * 2);
                dynamicPhases.push(Math.random() * Math.PI * 2);
            }
            
            const dynamicStarsGeometry = new THREE.BufferGeometry();
            dynamicStarsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(dynamicPositions, 3));
            dynamicStarsGeometry.setAttribute('size', new THREE.Float32BufferAttribute(dynamicSizes, 1));
            dynamicStarsGeometry.setAttribute('phase', new THREE.Float32BufferAttribute(dynamicPhases, 1));
            
            const starVertexShader = `
                uniform float time;
                attribute float size;
                attribute float phase;
                varying float vTwinkle;
                void main() {
                    vTwinkle = abs(sin(time + phase));
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    gl_PointSize = size * (1.0 + vTwinkle * 0.5);
                    gl_Position = projectionMatrix * mvPosition;
                }
            `;
            
            const starFragmentShader = `
                uniform vec3 starColor;
                varying float vTwinkle;
                void main() {
                    float dist = length(gl_PointCoord - vec2(0.5));
                    float alpha = 1.0 - smoothstep(0.4, 0.5, dist);
                    vec3 color = starColor * vTwinkle;
                    gl_FragColor = vec4(color, alpha);
                }
            `;
            
            const dynamicStarUniforms = {
                time: { value: 0.0 },
                starColor: { value: new THREE.Color(0xffffff) }
            };
            
            const dynamicStarsMaterial = new THREE.ShaderMaterial({
                uniforms: dynamicStarUniforms,
                vertexShader: starVertexShader,
                fragmentShader: starFragmentShader,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            const dynamicStars = new THREE.Points(dynamicStarsGeometry, dynamicStarsMaterial);
            scene.add(dynamicStars);
            
            const COMET_ACTIVE_DURATION = 7;
            const COMET_FADE_DURATION = 1;
            const cometTexture = textureLoader.load('/textures/comet1.png');
            const cometCount = isLowEnd ? 4 : 8;
            const comets = [];
            
            const particles = [];
            const particleCount = isLowEnd ? 100 : 200;
            const particleTexture = textureLoader.load('/textures/particle_clouds.png');
            
            const burningParticles = [];
            const burningParticleTexture = textureLoader.load('/textures/particle_clouds.png');
            
            function createComet() {
                const cometMaterial = new THREE.SpriteMaterial({
                    map: cometTexture,
                    blending: THREE.AdditiveBlending,
                    transparent: true,
                    opacity: 0.9,
                    depthWrite: false
                });
                const comet = new THREE.Sprite(cometMaterial);
                const cometSize = 150 + Math.random() * 200;
                comet.scale.set(cometSize, cometSize, 1);
                comet.color = new THREE.Color(0xffffff);
                comet.material.color = comet.color;
                const cometLight = new THREE.PointLight(comet.color, 4.0 + Math.random() * 3.0, 4000 + Math.random() * 2000, 2);
                cometLight.position.set(0, 0, 0);
                cometLight.castShadow = true;
                comet.add(cometLight);
                comet.light = cometLight;
                const spotLight = new THREE.SpotLight(0xffffff, 1.0, 5000, Math.PI / 8, 0.5);
                spotLight.castShadow = true;
                spotLight.target = comet;
                scene.add(spotLight);
                comet.spotLight = spotLight;
                comet.layers.set(1);
                cometLight.layers.set(1);
                spotLight.layers.set(1);
                resetComet(comet);
                comets.push(comet);
                scene.add(comet);
            }
            
            function createParticle() {
                const particleMaterial = new THREE.SpriteMaterial({
                    map: particleTexture,
                    blending: THREE.AdditiveBlending,
                    transparent: true,
                    opacity: 0.5,
                    depthWrite: false
                });
                const particle = new THREE.Sprite(particleMaterial);
                const particleSize = 5 + Math.random() * 10;
                particle.scale.set(particleSize, particleSize, 1);
                particle.position.set(
                    Math.random() * window.innerWidth * 2 - window.innerWidth,
                    Math.random() * window.innerHeight * 2 - window.innerHeight,
                    Math.random() * 3000 - 1500
                );
                const particleLight = new THREE.PointLight(0xffffff, 0.2, 200);
                particleLight.position.set(0, 0, 0);
                particle.add(particleLight);
                scene.add(particle);
                particles.push(particle);
            }
            
            function createBurningParticle(comet) {
                const burningMaterial = new THREE.SpriteMaterial({
                    map: burningParticleTexture,
                    blending: THREE.AdditiveBlending,
                    transparent: true,
                    opacity: 1.0,
                    depthWrite: false,
                    color: new THREE.Color(0xff4500)
                });
                const burningParticle = new THREE.Sprite(burningMaterial);
                const size = 10 + Math.random() * 10;
                burningParticle.scale.set(size, size, 1);
                burningParticle.position.copy(comet.position);
                const angle = Math.random() * Math.PI * 2;
                const speed = 50 + Math.random() * 50;
                burningParticle.velocity = new THREE.Vector3(Math.cos(angle) * speed, Math.sin(angle) * speed, 0);
                burningParticle.lifespan = 2.0 + Math.random() * 1.0;
                burningParticles.push(burningParticle);
                scene.add(burningParticle);
            }
            
            function resetComet(comet) {
                comet.position.set(
                    Math.random() * window.innerWidth * 2 - window.innerWidth,
                    window.innerHeight + 500,
                    Math.random() * 1000 - 500
                );
                const centerAngle = 5 * Math.PI / 4;
                const angleVariation = 5 * Math.PI / 180;
                const angle = centerAngle + (Math.random() * angleVariation * 2 - angleVariation);
                const speed = 1000 + Math.random() * 200;
                const velocityX = Math.cos(angle) * speed;
                const velocityY = Math.sin(angle) * speed;
                comet.velocity = new THREE.Vector3(velocityX, velocityY, 0);
                comet.lifespan = COMET_ACTIVE_DURATION + COMET_FADE_DURATION;
                comet.elapsed = 0;
                comet.burningOut = false;
                comet.light.intensity = 4.0 + Math.random() * 3.0;
                comet.material.opacity = 0.9;
                const cometSize = 150 + Math.random() * 200;
                comet.scale.set(cometSize, cometSize, 1);
                comet.rotation.z = Math.atan2(comet.velocity.y, comet.velocity.x);
                comet.flashPhase = 0;
                comet.flashSpeed = Math.random() * 5 + 5;
                comet.flashAmplitude = 3.0;
            }
            
            function updateComets(delta) {
                comets.forEach((comet, index) => {
                    comet.elapsed += delta;
                    if (comet.elapsed < COMET_ACTIVE_DURATION) {
                        comet.material.opacity = 0.9;
                        comet.light.intensity = 4.0 + Math.random() * 3.0;
                    } else if (comet.elapsed < COMET_ACTIVE_DURATION + COMET_FADE_DURATION) {
                        const fadeProgress = (comet.elapsed - COMET_ACTIVE_DURATION) / COMET_FADE_DURATION;
                        comet.material.opacity = THREE.MathUtils.lerp(0.9, 0.0, fadeProgress);
                        comet.light.intensity = THREE.MathUtils.lerp(comet.light.intensity, 0.0, fadeProgress);
                        if (index === 0) {
                            comet.material.opacity = THREE.MathUtils.lerp(0.9, 0.2, fadeProgress);
                            comet.light.intensity = THREE.MathUtils.lerp(comet.light.intensity, 1.0, fadeProgress);
                        }
                    } else {
                        resetComet(comet);
                    }
                    comet.position.add(comet.velocity.clone().multiplyScalar(delta));
                    const angle = Math.atan2(comet.velocity.y, comet.velocity.x);
                    comet.rotation.z = angle;
                    if (comet.spotLight) {
                        comet.spotLight.position.copy(comet.position);
                        comet.spotLight.position.z += 500;
                        comet.spotLight.intensity = 1.0 + Math.sin(clock.getElapsedTime() * 2) * 0.5;
                    }
                });
            }
            
            function updateParticles(delta) {
                particles.forEach((particle) => {
                    particle.position.x += (Math.random() - 0.5) * 0.5 * delta;
                    particle.position.y += (Math.random() - 0.5) * 0.5 * delta;
                    particle.position.z += (Math.random() - 0.5) * 0.2 * delta;
                });
            }
            
            function updateBurningParticles(delta) {
                for (let i = burningParticles.length - 1; i >= 0; i--) {
                    const particle = burningParticles[i];
                    particle.position.add(particle.velocity.clone().multiplyScalar(delta));
                    particle.lifespan -= delta;
                    if (particle.lifespan <= 0) {
                        scene.remove(particle);
                        burningParticles.splice(i, 1);
                        continue;
                    }
                    particle.material.opacity = Math.max(0, particle.lifespan / 2.0);
                }
            }
            
            function updateCometLightIntensity() {
                comets.forEach((comet) => {
                    let maxIntensity = 4.0;
                    particles.forEach((particle) => {
                        const distance = comet.position.distanceTo(particle.position);
                        if (distance < 500) {
                            maxIntensity = Math.max(maxIntensity, 4.0 + (500 - distance) / 100);
                        }
                    });
                    comet.light.intensity = maxIntensity;
                });
            }
            
            let mouseX = 0;
            let mouseY = 0;
            document.addEventListener('mousemove', (event) => {
                mouseX = (event.clientX / window.innerWidth) * 2 - 1;
                mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
            });
            
            function updateCamera() {
                camera.position.x += (mouseX * 500 - camera.position.x) * 0.05;
                camera.position.y += (mouseY * 300 - camera.position.y) * 0.05;
            }
            
            function spawnComets() {
                if (comets.length < cometCount) {
                    createComet();
                    const randomDelay = 1500 + Math.random() * 2000;
                    setTimeout(spawnComets, randomDelay);
                }
            }
            
            const satelliteTexture = textureLoader.load('/textures/sat1.png', () => {}, undefined, () => {});
            satelliteTexture.minFilter = THREE.LinearFilter;
            satelliteTexture.magFilter = THREE.LinearFilter;
            satelliteTexture.generateMipmaps = false;
            
            const satelliteMaterial = new THREE.SpriteMaterial({
                map: satelliteTexture,
                transparent: true,
                blending: THREE.NormalBlending,
                depthWrite: false,
                opacity: 1.0
            });
            
            const satellite = new THREE.Sprite(satelliteMaterial);
            satellite.scale.set(250, 250, 1);
            satellite.position.set(
                window.innerWidth + 200,
                (Math.random() - 0.5) * window.innerHeight,
                Math.random() * 1000 - 500
            );
            scene.add(satellite);
            
            const satelliteSpeed = 50;
            const satelliteRotationSpeed = 0.5;
            
            function updateSatellite(delta) {
                satellite.position.x -= satelliteSpeed * delta;
                satellite.rotation.z += satelliteRotationSpeed * delta;
                if (satellite.position.x < -window.innerWidth - 200) {
                    satellite.position.x = window.innerWidth + 200;
                    satellite.position.y = (Math.random() - 0.5) * window.innerHeight;
                    satellite.position.z = Math.random() * 1000 - 500;
                }
            }
            
            function updateDynamicStars(delta) {
                dynamicStarUniforms.time.value += delta;
            }
            
            createStaticStarField();
            spawnComets();
            for (let i = 0; i < particleCount; i++) {
                createParticle();
            }
            
            const renderPass = new RenderPass(scene, camera);
            const composer = new EffectComposer(renderer);
            composer.addPass(renderPass);
            
            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                isLowEnd ? 1.5 : 2.0,
                0.6,
                0.9
            );
            composer.addPass(bloomPass);
            
            const chromaticAberrationPass = new ShaderPass(ChromaticAberrationShader);
            chromaticAberrationPass.uniforms['offset'].value = new THREE.Vector2(0.00055, 0.00055);
            if (!isLowEnd) {
                composer.addPass(chromaticAberrationPass);
            }
            
            const fxaaPass = new ShaderPass(FXAAShader);
            fxaaPass.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight);
            composer.addPass(fxaaPass);
            
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    composer.setSize(window.innerWidth, window.innerHeight);
                    fxaaPass.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight);
                }, 200);
            });
            
            const clock = new THREE.Clock();
            
            function animate() {
                requestAnimationFrame(animate);
                const delta = clock.getDelta();
                updateDynamicStars(delta);
                updateComets(delta);
                updateParticles(delta);
                updateBurningParticles(delta);
                updateCometLightIntensity();
                updateCamera();
                updateSatellite(delta);
                composer.render();
            }
            
            animate();

        </script>

    </body>
</html>

