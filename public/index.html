<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MikuMiku | Home</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/styles.css">
</head>

<body>
    <!-- Three.js Canvas -->
    <canvas id="techCanvas"></canvas>

    <div class="page-container">
        <div class="title-bar">
            <div class="container">
                <div class="left-section"></div>
                <div class="center-section">
                    <div class="logo-title-wrapper">
                        <img src="/logo.webp" alt="Logo" class="logo" loading="lazy">
                        <h1 class="site-title" id="dynamicTitle">MikuMiku</h1>
                    </div>
                </div>
                <div class="right-section">
                    <div class="personality-section">
                        <div id="personalityCircle" class="personality-circle"></div>
                        <div id="personalityTextBox" class="personality-text-box">
                            <div id="personalityPhrase" class="personality-text-wrapper"></div>
                        </div>
                    </div>
                    <div class="dropdown">
                        <button class="dropdown-button">Menu</button>
                        <div class="dropdown-content">
                            <a href="/admin-login.html">Admin Login</a>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="now-playing-container">
            <div id="nowPlayingBox" class="now-playing">
                <div class="now-playing-sidebar">
                    <div class="sidebar-item">
                        <span>Channel:</span> <span id="channelName">Loading...</span>
                    </div>
                    <div class="sidebar-item">
                        <span>Views:</span> <span id="viewCount">Loading...</span>
                    </div>
                    <div class="sidebar-item">
                        <span>Likes:</span> <span id="likeCount">Loading...</span>
                    </div>
                    <div class="sidebar-item">
                        <span>Uploaded:</span> <span id="publishedDate">Loading...</span>
                    </div>
                    <div class="sidebar-item video-category">
                        <span>Category:</span> <span id="videoCategory">Loading...</span>
                    </div>
                </div>

                <div class="video-section" style="position: relative;">
                    <div class="video-title-container">
                        <h2>Currently Playing</h2>
                        <p id="videoTitle">Loading...</p>
                    </div>

                    <div class="thumbnail-container" style="position: relative;">
                        <video id="videoThumbnail" class="video-thumbnail" preload="metadata" controls style="width: 100%; height: auto; display: none;">
                            Your browser does not support the video tag.
                        </video>
                        <img id="videoThumbnailImage" src="" alt="Thumbnail" class="video-thumbnail" loading="lazy">
                    </div>

                    <div id="offline-indicator" class="offline-indicator">I’m not on YouTube at the moment, soz :(</div>

                    <div class="progress-bar-container">
                        <div id="progressBar" class="progress-bar"></div>
                    </div>

                    <div id="timeElapsedContainer" class="time-elapsed"><span id="timeElapsed">0s</span></div>

                    <button class="toggle-description" id="toggleDescriptionButton">Show Description</button>

                    <div id="loadingSpinner" class="loading-spinner"></div>
                </div>
            </div>
        </div>

        <div id="descriptionModal" class="modal">
            <div class="modal-content">
                <span class="close-button" id="closeDescriptionButton">&times;</span>
                <h2>Description</h2>
                <p id="videoDescription">Loading description...</p>
            </div>
        </div>

        <div class="widgets-container">
            <div class="live-clock box-container">
                <h3>My Current Time</h3>
                <div class="clock-container">
                    <div class="clock">
                        <p id="local-time">--:--:--</p>
                        <p id="current-date">24 Sep 2024</p>
                    </div>
                </div>
            </div>

            <div class="weather-widget box-container">
                <h3>My Current Weather</h3>
                <div class="weather-info">
                    <img id="weather-icon" src="" alt="Weather Icon" loading="lazy" style="display: none;">
                    <p id="weather-description">Loading...</p>
                    <p id="temperature">--°C</p>
                    <p id="humidity">Humidity: --%</p>
                    <p id="wind-speed">Wind: -- m/s</p>
                </div>
            </div>
        </div>

        <div class="content-wrapper">
            <div class="now-playing-about-wrapper">
                <div class="about box-container" id="aboutMe">
                    <h2>About Me</h2>
                    <p>Hey there, I'm Hystoriya, a 24-year-old developer. This is my personal website that I made for no apparent reason. If you find yourself here randomly, then hi :)</p>
                </div>
            </div>
        </div>

        <!-- Footer -->
        <footer class="footer">
            <div class="container">
                <p>&copy; 2024 MikuMiku. All rights reserved.</p>
                <button id="manageConsentFooter" class="manage-consent-button">Manage Cookie Preferences</button>
            </div>
        </footer>

        <div id="chat-box" class="chat-box">
            <div class="chat-header">
                <h3>Haru AI</h3>
                <button id="close-chat" class="close-chat">X</button>
            </div>
            <div id="chat-content" class="chat-content">
                <div class="message bot-message">Hi! I'm Haru, how can I help you today?</div>
            </div>
            <div class="chat-input-container">
                <input type="text" id="chat-input" class="chat-input" placeholder="Type your message..." />
                <button id="send-message" class="send-message">Send</button>
            </div>
        </div>

        <!-- Consent Modal -->
        <div id="consentModal" class="modal" aria-hidden="true" role="dialog" aria-labelledby="consentModalTitle" aria-describedby="consentModalDescription">
            <div class="modal-content">
                <span class="close-button" id="closeConsentModal">&times;</span>
                <h2 id="consentModalTitle">Cookie Consent</h2>
                <p id="consentModalDescription">
                    I use cookies stored in your browser to enhance your experience on my personal website. These cookies are essential for the website's functionality. By clicking "Accept," you consent to their use. You can also manage your cookie preferences in the "<a href="#" id="manageConsentModal" class="manage-consent-button">Manage Cookie Preferences</a>" section.
                </p>
                <div class="consent-buttons">
                    <button id="acceptConsent" class="consent-button">Accept</button>
                    <button id="declineConsent" class="consent-button">Decline</button>
                </div>
            </div>
        </div>

        <!-- Socket.io Client Library -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.1/socket.io.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.1/moment.min.js"></script>


        <!-- Import Haru AI script -->
        <script src="haru.js"></script>
            
        <script>
            // [Cookie Consent Script]
            (function () {
                'use strict';

                const CONFIG = {
                    consentCookieName: 'cookieConsent',
                    consentCookieExpiryDays: 365,
                    consentCookiePath: '/',
                    consentModalId: 'consentModal',
                    acceptButtonId: 'acceptConsent',
                    declineButtonId: 'declineConsent',
                    manageButtonIds: ['manageConsentModal', 'manageConsentFooter'],
                    closeButtonId: 'closeConsentModal',
                    cookieCategories: {
                        necessary: {
                            enabled: true,
                            description: 'Necessary cookies enable core functionalities and security features of the website.'
                        }
                    },
                    focusableSelectors: 'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])',
                };

                const consentModal = document.getElementById(CONFIG.consentModalId);
                const acceptButton = document.getElementById(CONFIG.acceptButtonId);
                const declineButton = document.getElementById(CONFIG.declineButtonId);
                const closeButton = document.getElementById(CONFIG.closeButtonId);
                const manageConsentButtons = CONFIG.manageButtonIds.map(id => document.getElementById(id));

                function setCookie(name, value, days, path = '/') {
                    let expires = "";
                    if (days) {
                        const date = new Date();
                        date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
                        expires = "; expires=" + date.toUTCString();
                    }
                    const secure = location.protocol === 'https:' ? "; Secure" : "";
                    const sameSite = "; SameSite=Lax";
                    document.cookie = name + "=" + (value || "") + expires + "; path=" + path + secure + sameSite;
                }

                function getCookie(name) {
                    const nameEQ = name + "=";
                    const ca = document.cookie.split(';');
                    for (let i = 0; i < ca.length; i++) {
                        let c = ca[i];
                        while (c.charAt(0) === ' ') c = c.substring(1, c.length);
                        if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
                    }
                    return null;
                }

                function eraseCookie(name, path = '/') {
                    document.cookie = name + '=; Max-Age=-99999999; path=' + path + ';';
                }

                function trapFocus(modal) {
                    const focusableElements = modal.querySelectorAll(CONFIG.focusableSelectors);
                    if (focusableElements.length === 0) return;
                    const firstFocusableElement = focusableElements[0];
                    const lastFocusableElement = focusableElements[focusableElements.length - 1];

                    function handleFocus(event) {
                        if (event.key === 'Tab') {
                            if (event.shiftKey) {
                                if (document.activeElement === firstFocusableElement) {
                                    event.preventDefault();
                                    lastFocusableElement.focus();
                                }
                            } else {
                                if (document.activeElement === lastFocusableElement) {
                                    event.preventDefault();
                                    firstFocusableElement.focus();
                                }
                            }
                        }
                        if (event.key === 'Escape') {
                            event.preventDefault();
                        }
                    }

                    modal.addEventListener('keydown', handleFocus);
                }

                function showModal() {
                    consentModal.classList.add('active');
                    document.body.classList.add('modal-active');
                    consentModal.setAttribute('aria-hidden', 'false');

                    const focusableElements = consentModal.querySelectorAll(CONFIG.focusableSelectors);
                    if (focusableElements.length) {
                        focusableElements[0].focus();
                    }

                    trapFocus(consentModal);
                }

                function hideModal() {
                    consentModal.classList.remove('active');
                    document.body.classList.remove('modal-active');
                    consentModal.setAttribute('aria-hidden', 'true');
                }

                function initConsentModal() {
                    const existingConsent = getCookie(CONFIG.consentCookieName);

                    if (!existingConsent) {
                        showModal();
                    } else {
                        applyConsent(existingConsent);
                    }

                    acceptButton.addEventListener('click', function () {
                        setCookie(CONFIG.consentCookieName, JSON.stringify({
                            necessary: true
                        }), CONFIG.consentCookieExpiryDays, CONFIG.consentCookiePath);
                        hideModal();
                        initializeCookies();
                    });

                    declineButton.addEventListener('click', function () {
                        setCookie(CONFIG.consentCookieName, JSON.stringify({
                            necessary: false
                        }), CONFIG.consentCookieExpiryDays, CONFIG.consentCookiePath);
                        hideModal();
                        disableCookies();
                    });

                    manageConsentButtons.forEach(button => {
                        if (button) {
                            button.addEventListener('click', function (event) {
                                event.preventDefault();
                                showModal();
                            });
                        }
                    });

                    closeButton.addEventListener('click', function () {
                        alert('Please make a choice regarding cookie usage.');
                    });

                    window.addEventListener('click', function (event) {
                        if (event.target === consentModal) {
                            alert('Please make a choice regarding cookie usage.');
                        }
                    });
                }

                function applyConsent(consentValue) {
                    try {
                        const consent = JSON.parse(consentValue);
                        if (consent.necessary) {
                            initializeCookies(consent);
                        } else {
                            disableCookies();
                        }
                    } catch (error) {
                        console.error('Error parsing consent cookie:', error);
                        showModal();
                    }
                }

                function initializeCookies(consent) {
                    console.log('Necessary cookies enabled.');
                }

                function disableCookies() {
                    console.log('Necessary cookies disabled.');
                }

                function areCookiesEnabled() {
                    const testCookie = 'test_cookie_consent';
                    setCookie(testCookie, 'test', 1);
                    const result = getCookie(testCookie) === 'test';
                    eraseCookie(testCookie);
                    return result;
                }

                function init() {
                    if (areCookiesEnabled()) {
                        initConsentModal();
                    } else {
                        console.warn('Cookies are disabled in this browser. Consent modal will not be displayed.');
                    }
                }

                document.addEventListener('DOMContentLoaded', init);
            })();
        </script>

        <script>
            // Now Playing Elements and Socket.IO Integration
            const socket = io("https://mikumiku.dev");
            let lastHeartbeatReceived = Date.now();
            let isSessionExpired = false;
            let browsingStartTime = null;
            let browsingInterval = null;

            const nowPlayingBox = document.getElementById("nowPlayingBox");
            const videoTitleElement = document.getElementById("videoTitle");
            const videoThumbnailImage = document.getElementById("videoThumbnailImage");
            const videoThumbnailElement = document.getElementById("videoThumbnail");
            const offlineIndicatorElement = document.getElementById("offline-indicator");
            const progressBarElement = document.getElementById("progressBar");
            const channelNameElement = document.getElementById("channelName");
            const viewCountElement = document.getElementById("viewCount");
            const likeCountElement = document.getElementById("likeCount");
            const publishedDateElement = document.getElementById("publishedDate");
            const videoCategoryElement = document.getElementById("videoCategory");
            const videoDescriptionElement = document.getElementById("videoDescription");
            const timeElapsedElement = document.getElementById("timeElapsed");

            function formatNumber(number) {
                if (typeof number === 'string') {
                    number = number.replace(/,/g, '');
                }
                const num = Number(number);
                return isNaN(num) ? "N/A" : num.toLocaleString();
            }

            function clearDisplay() {
                nowPlayingBox.classList.add("offline");
                offlineIndicatorElement.style.display = "block";
                videoTitleElement.textContent = "I’m not on YouTube at the moment, soz :(";
                videoThumbnailImage.src = "";
                videoThumbnailImage.style.display = "none";
                videoThumbnailElement.src = "";
                videoThumbnailElement.style.display = "none";
                channelNameElement.textContent = "";
                viewCountElement.textContent = "";
                likeCountElement.textContent = "";
                publishedDateElement.textContent = "";
                videoCategoryElement.textContent = "";
                progressBarElement.style.width = "0%";
                videoDescriptionElement.textContent = "";
                timeElapsedElement.style.display = "none";
            }

            function clearVideoPresence() {
                videoTitleElement.textContent = "";
                videoThumbnailImage.src = "";
                videoThumbnailImage.style.display = "none";
                videoThumbnailElement.src = "";
                videoThumbnailElement.style.display = "none";
                channelNameElement.textContent = "";
                viewCountElement.textContent = "";
                likeCountElement.textContent = "";
                publishedDateElement.textContent = "";
                videoCategoryElement.textContent = "";
                progressBarElement.style.width = "0%";
                videoDescriptionElement.textContent = "";
            }

            function reinitializeSession() {
                console.warn("[Client] Reinitializing session due to mismatch or timeout.");
                clearDisplay();
                isSessionExpired = true;
            }

            function formatTimeElapsed(seconds) {
                const hours = Math.floor(seconds / 3600);
                const minutes = Math.floor((seconds % 3600) / 60);
                const remainingSeconds = seconds % 60;

                if (hours > 0) {
                    return `${hours}h ${minutes}m ${remainingSeconds}s`;
                } else if (minutes > 0) {
                    return `${minutes}m ${remainingSeconds}s`;
                } else {
                    return `${remainingSeconds}s`;
                }
            }

            function displayVideoPresence(data) {
                lastHeartbeatReceived = Date.now();
                nowPlayingBox.classList.remove("offline");
                offlineIndicatorElement.style.display = "none";

                videoTitleElement.textContent = data.title || "Unknown Title";

                if (data.thumbnail) {
                    videoThumbnailImage.src = data.thumbnail;
                    videoThumbnailImage.style.display = "block";
                    videoThumbnailElement.style.display = "none";
                } else {
                    videoThumbnailImage.src = "";
                    videoThumbnailElement.style.display = "none";
                }

                channelNameElement.textContent = data.channelTitle || "Unknown Channel";
                viewCountElement.textContent = `Views: ${formatNumber(data.viewCount)}` || "Views: N/A";
                likeCountElement.textContent = `Likes: ${formatNumber(data.likeCount)}` || "Likes: N/A";

                if (data.publishedAt) {
                    const publishedDate = new Date(data.publishedAt);
                    publishedDateElement.textContent = `Published on: ${publishedDate.toLocaleDateString()}` || "Published on: N/A";
                } else {
                    publishedDateElement.textContent = "Published on: N/A";
                }

                videoCategoryElement.textContent = `Category: ${data.category}` || "Category: N/A";
                videoDescriptionElement.textContent = data.description || "No description available.";
                handleRealTimeProgress(data);
                timeElapsedElement.style.display = "none";

                if (data.videoSrc) {
                    videoThumbnailElement.src = data.videoSrc;
                    videoThumbnailElement.style.display = "block";
                    videoThumbnailImage.style.display = "none";
                } else {
                    videoThumbnailElement.style.display = "none";
                    videoThumbnailImage.style.display = "block";
                }
            }

            function handleRealTimeProgress(data) {
                if (data.duration && data.currentTime) {
                    const progressPercentage = (data.currentTime / data.duration) * 100;
                    progressBarElement.style.width = `${progressPercentage}%`;
                } else {
                    progressBarElement.style.width = "0%";
                }
            }

            function displayBrowsingPresence(data) {
                lastHeartbeatReceived = Date.now();
                nowPlayingBox.classList.remove("offline");
                offlineIndicatorElement.style.display = "none";

                clearVideoPresence();

                videoTitleElement.textContent = data.title || "Browsing YouTube";
                videoThumbnailImage.src = data.thumbnail || "https://i.postimg.cc/GpgNPv0R/custom-browsing-thumbnail.png";
                videoThumbnailImage.style.display = "block";
                videoThumbnailElement.style.display = "none";
                channelNameElement.textContent = "Browsing...";
                videoDescriptionElement.textContent = data.description || "Browsing videos on YouTube";
                progressBarElement.style.width = "0%";

                if (data.timeElapsed !== undefined) {
                    timeElapsedElement.textContent = `Time Elapsed: ${formatTimeElapsed(data.timeElapsed)}`;
                    timeElapsedElement.style.display = "block";
                }
            }

            function updateBrowsingPresence() {
                if (browsingStartTime !== null) {
                    const timeElapsed = Math.floor((Date.now() - browsingStartTime) / 1000);
                    timeElapsedElement.textContent = `Time Elapsed: ${formatTimeElapsed(timeElapsed)}`;
                    timeElapsedElement.style.display = "block";

                    const browsingData = {
                        title: 'YouTube',
                        description: 'Browsing videos',
                        thumbnail: 'https://i.postimg.cc/GpgNPv0R/custom-browsing-thumbnail.png',
                        timeElapsed: timeElapsed,
                        presenceType: 'browsing'
                    };
                    socket.emit('updateBrowsingPresence', browsingData);
                }
            }

            function startBrowsingPresence() {
                if (browsingStartTime === null) {
                    browsingStartTime = Date.now();
                }
                if (!browsingInterval) {
                    browsingInterval = setInterval(updateBrowsingPresence, 5000);
                }
            }

            function stopBrowsingPresence() {
                if (browsingInterval) {
                    clearInterval(browsingInterval);
                    browsingInterval = null;
                }
                browsingStartTime = null;
            }

            socket.on("connect", () => {
                console.log("[Socket.IO] Connected to server.");
                isSessionExpired = false;
                socket.emit('requestLatestData');
            });

            socket.on("presenceUpdate", (data) => {
                if (isSessionExpired) {
                    console.warn("[Client] Ignoring presenceUpdate due to expired session.");
                    return;
                }

                console.log("[Socket.IO] Received presenceUpdate:", data);
                lastHeartbeatReceived = Date.now();

                if (data.presenceType === 'video') {
                    stopBrowsingPresence();
                    displayVideoPresence(data);
                } else if (data.presenceType === 'browsing') {
                    displayBrowsingPresence(data);
                    startBrowsingPresence();
                } else {
                    clearDisplay();
                }
            });

            socket.on("reinitializeSession", (data) => {
                console.warn(`[Socket.IO] Received reinitializeSession: ${JSON.stringify(data)}`);
                reinitializeSession();
            });

            socket.on("sessionExpired", (data) => {
                console.warn(`[Socket.IO] Session expired for video ID: ${data.videoId}`);
                reinitializeSession();
            });

            socket.on("disconnect", () => {
                console.warn("[Socket.IO] Disconnected from server.");
                stopBrowsingPresence();
                clearDisplay();
            });

            setInterval(() => {
                if (Date.now() - lastHeartbeatReceived > 60000) {
                    console.warn("[Heartbeat] No heartbeat received in the last 60 seconds. Marking as offline.");
                    clearDisplay();
                }
            }, 5000);

            // Modal Toggle Logic
            const descriptionModal = document.getElementById("descriptionModal");
            const closeDescriptionButton = document.getElementById("closeDescriptionButton");
            const toggleDescriptionButton = document.getElementById("toggleDescriptionButton");

            toggleDescriptionButton.addEventListener("click", function () {
                if (descriptionModal.style.display === "block") {
                    descriptionModal.style.display = "none";
                    toggleDescriptionButton.textContent = "Show Description";
                } else {
                    descriptionModal.style.display = "block";
                    toggleDescriptionButton.textContent = "Hide Description";
                }
            });

            closeDescriptionButton.addEventListener("click", function () {
                descriptionModal.style.display = "none";
                toggleDescriptionButton.textContent = "Show Description";
            });

            window.addEventListener("click", function (event) {
                if (event.target === descriptionModal) {
                    descriptionModal.style.display = "none";
                    toggleDescriptionButton.textContent = "Show Description";
                }
            });

            // Clock Update Script
            function updateClocks() {
                const now = new Date();
                const localTime = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
                const localTimeElement = document.getElementById('local-time');
                if (localTimeElement) localTimeElement.textContent = localTime;
                const currentDate = now.toLocaleDateString(undefined, { day: '2-digit', month: 'short', year: 'numeric' });
                const currentDateElement = document.getElementById('current-date');
                if (currentDateElement) currentDateElement.textContent = currentDate;
            }

            setInterval(updateClocks, 1000);
            updateClocks();

            // Weather Update Script
            const CITY_NAME = 'Leeds';
            async function fetchWeather() {
                try {
                    const response = await fetch(`/api/weather?city=${encodeURIComponent(CITY_NAME)}`);
                    const data = await response.json();

                    if (data.error) {
                        throw new Error(data.error);
                    }

                    displayWeather(data);
                } catch (error) {
                    console.error('Error fetching weather data:', error);
                    const weatherIconElement = document.getElementById('weather-icon');
                    if (weatherIconElement) weatherIconElement.style.display = 'none';
                    document.getElementById('weather-description').innerText = 'Unable to fetch weather data.';
                }
            }

            function displayWeather(data) {
                const description = data.weather[0].description;
                const temperature = Math.round(data.main.temp);
                const humidity = data.main.humidity;
                const windSpeed = data.wind.speed;
                const iconCode = data.weather[0].icon;
                const iconUrl = `https://openweathermap.org/img/wn/${iconCode}@2x.png`;

                document.getElementById('weather-description').innerText = `Condition: ${description}`;
                document.getElementById('temperature').innerText = `Temperature: ${temperature}°C`;
                document.getElementById('humidity').innerText = `Humidity: ${humidity}%`;
                document.getElementById('wind-speed').innerText = `Wind: ${windSpeed} m/s`;

                const weatherIconElement = document.getElementById('weather-icon');
                if (weatherIconElement) {
                    weatherIconElement.src = iconUrl;
                    weatherIconElement.style.display = 'block';
                }
            }

            setInterval(fetchWeather, 3600000); // Update every hour
            fetchWeather();
        </script>
                
    
        <script type="module">
            import * as THREE from '/js/three.module.min.js';
            import { EffectComposer } from '/js/postprocessing/EffectComposer.js';
            import { RenderPass } from '/js/postprocessing/RenderPass.js';
            import { UnrealBloomPass } from '/js/postprocessing/UnrealBloomPass.js';
            import { FXAAShader } from '/js/shaders/FXAAShader.js';
            import { ShaderPass } from '/js/postprocessing/ShaderPass.js';
            
            // === Constants and Layer Definitions ===
            const SATELLITE_LAYER = 2; // Define Satellite Layer (Layer 2)
            const MAIN_LAYER = 0;       // Main Scene Layer (Layer 0)
            const COMET_LAYER = 1;      // Comet Effects Layer (Layer 1)
            // ==========================================
            
            // Custom Chromatic Aberration Shader
            const ChromaticAberrationShader = {
                uniforms: {
                    "tDiffuse": { value: null },
                    "offset": { value: new THREE.Vector2(0.00075, 0.00075) } // Reduced offset for subtler effect
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D tDiffuse;
                    uniform vec2 offset;
                    varying vec2 vUv;
            
                    void main() {
                        vec4 color = vec4(0.0);
                        vec2 redOffset = vUv + offset;
                        vec2 greenOffset = vUv;
                        vec2 blueOffset = vUv - offset;
            
                        color.r = texture2D(tDiffuse, redOffset).r;
                        color.g = texture2D(tDiffuse, greenOffset).g;
                        color.b = texture2D(tDiffuse, blueOffset).b;
                        color.a = texture2D(tDiffuse, vUv).a;
            
                        gl_FragColor = color;
                    }
                `
            };
            
            // Initialize Renderer
            const canvas = document.getElementById('techCanvas');
            const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.5; // Adjusted for a more balanced overall lighting effect
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            
            // Initialize Scene and Camera
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 20000);
            camera.position.set(0, 0, 3000);
            
            // Load Background Texture with Error Handling
            const textureLoader = new THREE.TextureLoader();
            textureLoader.load('/textures/pillar.webp', (texture) => {
                texture.colorSpace = THREE.SRGBColorSpace;
                texture.encoding = THREE.sRGBEncoding; // Ensure correct brightness
                scene.background = texture;
            }, undefined, (err) => {
                console.error('Error loading background texture:', err);
                scene.background = new THREE.Color(0x303030);
            });
            
            // Adding Ambient and Hemisphere Light for Overall Illumination
            const ambientLight = new THREE.AmbientLight(0x404040, 1.8);
            scene.add(ambientLight);
            
            const hemisphereLight = new THREE.HemisphereLight(0xddddff, 0x555555, 0.5);
            scene.add(hemisphereLight);
            
            // Set Camera to Render Specific Layers
            camera.layers.enable(MAIN_LAYER);  // Layer 0: Main Scene
            camera.layers.enable(COMET_LAYER); // Layer 1: Comet Effects
            
            // Load Star Textures
            const starTextures = [
                textureLoader.load('/textures/stars 001.png'),
                textureLoader.load('/textures/stars 002.png'),
                textureLoader.load('/textures/stars 003.png'),
                textureLoader.load('/textures/stars 004.png'),
                textureLoader.load('/textures/stars 005.png'),
                textureLoader.load('/textures/stars 006.png')
            ];
            
            // Function to Add Static Stars to the Background
            function createStaticStarField() {
                const starCount = 50; // Number of static stars in the field
            
                for (let i = 0; i < starCount; i++) {
                    const texture = starTextures[Math.floor(Math.random() * starTextures.length)];
                    const starMaterial = new THREE.SpriteMaterial({
                        map: texture,
                        blending: THREE.AdditiveBlending,
                        transparent: true,
                        opacity: 0.8  // Adjust opacity to blend into background
                    });
            
                    const star = new THREE.Sprite(starMaterial);
                    star.scale.set(200 + Math.random() * 150, 200 + Math.random() * 150, 1); // Randomize size
                    star.position.set(
                        Math.random() * window.innerWidth * 2 - window.innerWidth,  // Spread across X-axis
                        Math.random() * window.innerHeight * 2 - window.innerHeight, // Spread across Y-axis
                        -2000 + Math.random() * 1000                                // Spread behind the main scene
                    );
            
                    scene.add(star);
                }
            }
            
            // === Dynamic Twinkling Starfield Implementation ===
            
            // Number of Dynamic Stars
            const dynamicStarCount = 1000;
            
            // Arrays to Hold Star Attributes
            const dynamicPositions = [];
            const dynamicSizes = [];
            const dynamicPhases = [];
            
            // Generate Random Positions and Attributes for Each Dynamic Star
            for (let i = 0; i < dynamicStarCount; i++) {
                // Position stars randomly within a large cube to encompass the scene
                const x = Math.random() * window.innerWidth * 2 - window.innerWidth;
                const y = Math.random() * window.innerHeight * 2 - window.innerHeight;
                const z = Math.random() * 3000 - 1500;
                dynamicPositions.push(x, y, z);
        
                // Assign random sizes between 1 and 3
                dynamicSizes.push(1 + Math.random() * 2);
        
                // Assign random phases for twinkling
                dynamicPhases.push(Math.random() * Math.PI * 2);
            }
            
            // Create BufferGeometry for Dynamic Stars
            const dynamicStarsGeometry = new THREE.BufferGeometry();
            dynamicStarsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(dynamicPositions, 3));
            dynamicStarsGeometry.setAttribute('size', new THREE.Float32BufferAttribute(dynamicSizes, 1));
            dynamicStarsGeometry.setAttribute('phase', new THREE.Float32BufferAttribute(dynamicPhases, 1));
            
            // Define the Vertex Shader
            const starVertexShader = `
                uniform float time;
                attribute float size;
                attribute float phase;
                varying float vTwinkle;
            
                void main() {
                    // Calculate twinkle based on time and phase
                    vTwinkle = abs(sin(time + phase));
            
                    // Adjust the size based on twinkle
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    gl_PointSize = size * (1.0 + vTwinkle * 0.5);
                    
                    gl_Position = projectionMatrix * mvPosition;
                }
            `;
            
            // Define the Fragment Shader
            const starFragmentShader = `
                uniform vec3 starColor;
                varying float vTwinkle;
            
                void main() {
                    // Calculate distance from the center of the point
                    float dist = length(gl_PointCoord - vec2(0.5));
                    
                    // Smooth edges for the star
                    float alpha = 1.0 - smoothstep(0.4, 0.5, dist);
                    
                    // Adjust brightness based on twinkle
                    vec3 color = starColor * vTwinkle;
                    
                    gl_FragColor = vec4(color, alpha);
                }
            `;
            
            // Define the Uniforms
            const dynamicStarUniforms = {
                time: { value: 0.0 },
                starColor: { value: new THREE.Color(0xffffff) } // Brilliant white
            };
            
            // Create the ShaderMaterial for Dynamic Stars
            const dynamicStarsMaterial = new THREE.ShaderMaterial({
                uniforms: dynamicStarUniforms,
                vertexShader: starVertexShader,
                fragmentShader: starFragmentShader,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            // Create the Points Object for Dynamic Stars
            const dynamicStars = new THREE.Points(dynamicStarsGeometry, dynamicStarsMaterial);
            dynamicStars.layers.set(MAIN_LAYER); // Assign to Main Layer
            scene.add(dynamicStars);
            
            // === End of Dynamic Twinkling Starfield Implementation ===
            
            // === Comet Spawning Implementation ===
            
            // Comet Lifespan Constants (in seconds)
            const COMET_ACTIVE_DURATION = 7;  // Active for 7 seconds
            const COMET_FADE_DURATION = 1;    // Fade out over 1 second
            
            // Comet Variables
            const cometTexture = textureLoader.load('/textures/comet1.png');
            const cometCount = 8;
            const comets = [];
            
            // Particle Variables for Cosmic Dust
            const particles = [];
            const particleCount = 200;  // Number of cosmic dust particles
            const particleTexture = textureLoader.load('/textures/particle_clouds.png');
            
            // Burning Particles for Comet Fire Trail
            const burningParticles = [];
            const burningParticleTexture = textureLoader.load('/textures/particle_clouds.png'); // Reusing existing texture
            
            // Flag to Control Spawning
            let isSpawning = true;
            let spawnTimeout = null;
            
            // Function to Create a New Comet with Diverse Properties
            function createComet() {
                const cometMaterial = new THREE.SpriteMaterial({
                    map: cometTexture,
                    blending: THREE.AdditiveBlending,
                    transparent: true,
                    opacity: 0.9,
                    depthWrite: false,
                });
            
                const comet = new THREE.Sprite(cometMaterial);
                const cometSize = 150 + Math.random() * 200;
                comet.scale.set(cometSize, cometSize, 1);
                comet.color = new THREE.Color(0xffffff); // Keep comet white
                comet.material.color = comet.color;
            
                // Adding Bright Light to Comet
                const cometLight = new THREE.PointLight(comet.color, 4.0 + Math.random() * 3.0, 4000 + Math.random() * 2000, 2);
                cometLight.position.set(0, 0, 0);
                cometLight.castShadow = true;
                comet.add(cometLight);
            
                comet.light = cometLight;
            
                // Create a Spotlight for Lighting Up the Background
                const spotLight = new THREE.SpotLight(0xffffff, 1.0, 5000, Math.PI / 8, 0.5);
                spotLight.castShadow = true;
                spotLight.target = comet;
                scene.add(spotLight);
                comet.spotLight = spotLight;
            
                // Assign Comet, Light, and Spotlight to Comet Layer
                comet.layers.set(COMET_LAYER);
                cometLight.layers.set(COMET_LAYER);
                spotLight.layers.set(COMET_LAYER);
            
                resetComet(comet);
                comets.push(comet);
                scene.add(comet);
            }
            
            // Function to Create Cosmic Dust Particles in a 3D Volume
            function createParticle() {
                const particleMaterial = new THREE.SpriteMaterial({
                    map: particleTexture,
                    blending: THREE.AdditiveBlending,
                    transparent: true,
                    opacity: 0.5,  // Lower opacity for cosmic dust effect
                    depthWrite: false,
                });
            
                const particle = new THREE.Sprite(particleMaterial);
                const particleSize = 5 + Math.random() * 10;  // Smaller size to represent cosmic dust
                particle.scale.set(particleSize, particleSize, 1);
                
                // Position particles in a 3D space surrounding the scene
                particle.position.set(
                    Math.random() * window.innerWidth * 2 - window.innerWidth,
                    Math.random() * window.innerHeight * 2 - window.innerHeight,
                    Math.random() * 3000 - 1500  // Spread particles in a depth range in the scene
                );
            
                // Add a Very Soft Light to the Particle for a Subtle Glowing Effect
                const particleLight = new THREE.PointLight(0xffffff, 0.2, 200);
                particleLight.position.set(0, 0, 0);
                particle.add(particleLight);
            
                particle.light = particleLight;
                
                particle.layers.set(MAIN_LAYER); // Assign to Main Layer
                scene.add(particle);
                particles.push(particle);
            }
            
            // Function to Create Burning Flame Particles
            function createBurningParticle(comet) {
                const burningMaterial = new THREE.SpriteMaterial({
                    map: burningParticleTexture,
                    blending: THREE.AdditiveBlending,
                    transparent: true,
                    opacity: 1.0,
                    depthWrite: false,
                    color: new THREE.Color(0xff4500) // Fiery orange-red color
                });
            
                const burningParticle = new THREE.Sprite(burningMaterial);
                const size = 10 + Math.random() * 10;
                burningParticle.scale.set(size, size, 1);
            
                // Position the burning particle at the comet's current position
                burningParticle.position.copy(comet.position);
            
                // Assign a Random Velocity Away from the Comet to Simulate Dispersing Flames
                const angle = Math.random() * Math.PI * 2;
                const speed = 50 + Math.random() * 50;
                burningParticle.velocity = new THREE.Vector3(Math.cos(angle) * speed, Math.sin(angle) * speed, 0);
            
                burningParticle.lifespan = 2.0 + Math.random() * 1.0; // Lifespan in seconds
            
                burningParticle.layers.set(COMET_LAYER); // Assign to Comet Layer
                burningParticles.push(burningParticle);
                scene.add(burningParticle);
            }
            
            // Function to Reset Comet Properties
            function resetComet(comet) {
                // Adjusted Spawn Position
                comet.position.set(
                    Math.random() * window.innerWidth * 2 - window.innerWidth, // Spread comets across entire horizontal width
                    window.innerHeight + 500,  // Position comets above the visible area
                    Math.random() * 1000 - 500  // Add depth variation to the comets
                );
            
                // Fixed Angle for Diagonal Forward Movement
                // Centered around 225 degrees with a narrow range to ensure consistent diagonal movement
                const centerAngle = 5 * Math.PI / 4; // 225 degrees in radians
                const angleVariation = 5 * Math.PI / 180; // 5 degrees in radians
                const angle = centerAngle + (Math.random() * angleVariation * 2 - angleVariation); // 220 to 230 degrees
            
                const speed = 1000 + Math.random() * 200; // 1000 to 1200 units per second
            
                const velocityX = Math.cos(angle) * speed; // Negative X for leftward movement
                const velocityY = Math.sin(angle) * speed; // Negative Y for downward movement
            
                comet.velocity = new THREE.Vector3(velocityX, velocityY, 0);
            
                // Set Lifespan Properties
                comet.lifespan = COMET_ACTIVE_DURATION + COMET_FADE_DURATION; // Total lifespan
                comet.elapsed = 0; // Time since creation
            
                comet.burningOut = false;
            
                comet.light.intensity = 4.0 + Math.random() * 3.0;
            
                comet.material.opacity = 0.9;
                const cometSize = 150 + Math.random() * 200;
                comet.scale.set(cometSize, cometSize, 1);
                comet.rotation.z = Math.atan2(comet.velocity.y, comet.velocity.x);
            
                // Initialize Flashing Properties
                comet.flashPhase = 0; // Phase for sine wave
                comet.flashSpeed = Math.random() * 5 + 5; // Speed of flashing
                comet.flashAmplitude = 3.0; // Amplitude of light intensity fluctuation
            }
            
            // Function to Spawn Comets One by One with Random Delay
            function spawnCometWithDelay() {
                if (!isSpawning) return;
    
                if (comets.length < cometCount) {
                    createComet();
                    const randomDelay = 1500 + Math.random() * 2000; // 1.5 to 3.5 seconds
                    spawnTimeout = setTimeout(spawnCometWithDelay, randomDelay);
                }
            }
            
            // Function to Start Spawning Comets
            function startSpawningComets() {
                if (isSpawning && !spawnTimeout) {
                    spawnCometWithDelay();
                }
            }
            
            // Function to Stop Spawning Comets
            function stopSpawningComets() {
                isSpawning = false;
                if (spawnTimeout) {
                    clearTimeout(spawnTimeout);
                    spawnTimeout = null;
                }
            }
            
            // Event Listener for Page Visibility Change
            document.addEventListener('visibilitychange', () => {
                if (document.hidden) {
                    // Page is hidden, stop spawning comets
                    stopSpawningComets();
                } else {
                    // Page is visible, resume spawning comets
                    if (comets.length < cometCount) {
                        isSpawning = true;
                        spawnCometWithDelay();
                    }
                }
            });
            
            // === Satellite Implementation ===
            
            // Load Satellite Texture
            const satelliteTexture = textureLoader.load('/textures/voyager_1.png', () => {
                console.log('Satellite texture loaded successfully.');
            }, undefined, (err) => {
                console.error('Error loading satellite texture:', err);
            });
            
            // Adjust Texture Filtering for Crisp Appearance
            satelliteTexture.minFilter = THREE.LinearFilter;
            satelliteTexture.magFilter = THREE.LinearFilter;
            satelliteTexture.generateMipmaps = false;
            
            // Create Satellite Material
            const satelliteMaterial = new THREE.SpriteMaterial({
                map: satelliteTexture,
                transparent: true,
                blending: THREE.NormalBlending, // Changed from AdditiveBlending to NormalBlending
                depthWrite: false,
                opacity: 0.95 // Slightly reduced opacity for subtlety
            });
            
            // Create Satellite Sprite
            const satellite = new THREE.Sprite(satelliteMaterial);
            
            // Set Increased Scale
            satellite.scale.set(150, 150, 1); // Increased size from 100 to 150
            
            // Set Initial Position (e.g., far right, random Y and Z)
            satellite.position.set(
                window.innerWidth + 200, // Start off-screen to the right
                (Math.random() - 0.5) * window.innerHeight, // Random Y position
                Math.random() * 1000 - 500 // Random Z position for depth
            );
            
            // Assign Satellite to Its Own Layer
            satellite.layers.set(SATELLITE_LAYER);
            
            // Add Satellite to the Scene
            scene.add(satellite);
            
            // Satellite Movement Parameters
            const satelliteSpeed = 50; // Units per second
            const satelliteRotationSpeed = 0.5; // Radians per second
            
            // Function to Update the Satellite's Position and Rotation
            function updateSatellite(delta) {
                // Move the satellite to the left
                satellite.position.x -= satelliteSpeed * delta;
            
                // Rotate the satellite subtly
                satellite.rotation.z += satelliteRotationSpeed * delta;
            
                // If the satellite has moved off-screen to the left, reset its position to the right
                if (satellite.position.x < -window.innerWidth - 200) {
                    satellite.position.x = window.innerWidth + 200;
                    satellite.position.y = (Math.random() - 0.5) * window.innerHeight;
                    satellite.position.z = Math.random() * 1000 - 500;
                }
            }
            
            // === End of Satellite Implementation ===
            
            // Function to Update Dynamic Stars' Twinkling
            function updateDynamicStars(delta) {
                dynamicStarUniforms.time.value += delta;
            }
            
            // Function to Update Comets, Particles, Burning Particles, and Camera
            function updateComets(delta) {
                comets.forEach((comet, index) => {
                    comet.elapsed += delta;
            
                    if (comet.elapsed < COMET_ACTIVE_DURATION) {
                        // Active Phase: Fully visible, normal opacity and intensity
                        comet.material.opacity = 0.9;
                        comet.light.intensity = 4.0 + Math.random() * 3.0;
                    } else if (comet.elapsed < COMET_ACTIVE_DURATION + COMET_FADE_DURATION) {
                        // Fade-Out Phase
                        const fadeProgress = (comet.elapsed - COMET_ACTIVE_DURATION) / COMET_FADE_DURATION;
                        comet.material.opacity = THREE.MathUtils.lerp(0.9, 0.0, fadeProgress);
                        comet.light.intensity = THREE.MathUtils.lerp(comet.light.intensity, 0.0, fadeProgress);
            
                        // Special Fade-Out for the First Comet
                        if (index === 0) {
                            // Apply a more pronounced fade-out
                            comet.material.opacity = THREE.MathUtils.lerp(0.9, 0.2, fadeProgress);
                            comet.light.intensity = THREE.MathUtils.lerp(comet.light.intensity, 1.0, fadeProgress);
                        }
                    } else {
                        // Reset the Comet
                        resetComet(comet);
                    }
            
                    // Update Position
                    comet.position.add(comet.velocity.clone().multiplyScalar(delta));
            
                    // Rotate the Comet to Align with Its Direction of Travel
                    const angle = Math.atan2(comet.velocity.y, comet.velocity.x);
                    comet.rotation.z = angle;
            
                    // Move the Spotlight with the Comet to Simulate Background Lighting
                    if (comet.spotLight) {
                        comet.spotLight.position.copy(comet.position);
                        comet.spotLight.position.z += 500;
                        comet.spotLight.intensity = 1.0 + Math.sin(clock.getElapsedTime() * 2) * 0.5;
                    }
                });
            }
            
            // Function to Update Particle Positions for Subtle Movement and Reactive Effects
            function updateParticles(delta) {
                particles.forEach((particle) => {
                    // Add Subtle Random Movement to Each Particle to Simulate Floating
                    particle.position.x += (Math.random() - 0.5) * 0.5 * delta;
                    particle.position.y += (Math.random() - 0.5) * 0.5 * delta;
                    particle.position.z += (Math.random() - 0.5) * 0.2 * delta;
            
                    // Add Subtle Movement Based on Camera Position for Parallax Effect in 3D Space
                    particle.position.x += mouseX * 0.02 * delta;
                    particle.position.y += mouseY * 0.02 * delta;
                });
            }
            
            // Function to Update Burning Particles
            function updateBurningParticles(delta) {
                for (let i = burningParticles.length - 1; i >= 0; i--) {
                    const particle = burningParticles[i];
                    // Update Position Based on Velocity
                    particle.position.add(particle.velocity.clone().multiplyScalar(delta));
            
                    // Decrease Lifespan
                    particle.lifespan -= delta;
                    if (particle.lifespan <= 0) {
                        scene.remove(particle);
                        burningParticles.splice(i, 1);
                        continue;
                    }
            
                    // Fade Out Opacity Over Time
                    particle.material.opacity = Math.max(0, particle.lifespan / 2.0);
                }
            }
            
            // Function to Adjust Comet Light Intensity Based on Proximity to Particles
            function updateCometLightIntensity() {
                comets.forEach((comet) => {
                    let maxIntensity = 4.0;  // Default comet intensity
                    particles.forEach((particle) => {
                        const distance = comet.position.distanceTo(particle.position);
                        if (distance < 500) {  // Threshold for effect
                            maxIntensity = Math.max(maxIntensity, 4.0 + (500 - distance) / 100);  // Increase intensity closer to particle
                        }
                    });
            
                    // Apply the Intensity to the Comet's Light
                    comet.light.intensity = maxIntensity;
                });
            }
            
            // Interactive Camera Movement Based on Mouse Position
            let mouseX = 0;
            let mouseY = 0;
            document.addEventListener('mousemove', (event) => {
                mouseX = (event.clientX / window.innerWidth) * 2 - 1;
                mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
            });
            
            // Function to Update the Camera Position Based on Mouse Movement
            function updateCamera() {
                camera.position.x += (mouseX * 500 - camera.position.x) * 0.05;
                camera.position.y += (mouseY * 300 - camera.position.y) * 0.05;
            }
            
            // === Comet Spawning Implementation ===
            
            // Function to Spawn Comets One by One with Random Delay
            function spawnCometWithDelay() {
                if (!isSpawning) return;
        
                if (comets.length < cometCount) {
                    createComet();
                    const randomDelay = 1500 + Math.random() * 2000; // 1.5 to 3.5 seconds
                    spawnTimeout = setTimeout(spawnCometWithDelay, randomDelay);
                }
            }
            
            // Function to Start Spawning Comets
            function startSpawningComets() {
                if (isSpawning && !spawnTimeout) {
                    spawnCometWithDelay();
                }
            }
            
            // Function to Stop Spawning Comets
            function stopSpawningComets() {
                isSpawning = false;
                if (spawnTimeout) {
                    clearTimeout(spawnTimeout);
                    spawnTimeout = null;
                }
            }
            
            // Event Listener for Page Visibility Change
            document.addEventListener('visibilitychange', () => {
                if (document.hidden) {
                    // Page is hidden, stop spawning comets
                    stopSpawningComets();
                } else {
                    // Page is visible, resume spawning comets
                    if (comets.length < cometCount) {
                        isSpawning = true;
                        spawnCometWithDelay();
                    }
                }
            });
            
            // === End of Comet Spawning Implementation ===
            
            // === Satellite Implementation ===
            
            // Load Satellite Texture
            // Note: 'satelliteTexture' was already loaded above. Ensure no duplicate loading.
            // Remove any additional declarations if present.
            // satelliteTexture is already defined; no need to load again.
            // However, since 'satelliteTexture' is already defined, ensure that the variable is not re-declared.
            
            // Create Satellite Material
            // 'satelliteMaterial' was already defined above. Ensure no duplicate declarations.
            // Reuse the existing satelliteMaterial or create a new one if necessary.
            // To avoid duplication, we ensure that satelliteTexture is used only once.
            
            // Since 'satelliteTexture' and 'satelliteMaterial' are unique, we proceed.
            
            // Create Satellite Sprite
            // 'satellite' was already created above. Ensure no duplicate declarations.
            // If you have multiple satellites, consider naming them differently or encapsulating in functions.
            
            // No additional changes needed here as per the corrected script.
            
            // === End of Satellite Implementation ===
            
            // Function to Update Dynamic Stars' Twinkling
            function updateDynamicStars(delta) {
                dynamicStarUniforms.time.value += delta;
            }
            
            // Function to Update Comets, Particles, Burning Particles, and Camera
            function updateComets(delta) {
                comets.forEach((comet, index) => {
                    comet.elapsed += delta;
            
                    if (comet.elapsed < COMET_ACTIVE_DURATION) {
                        // Active Phase: Fully visible, normal opacity and intensity
                        comet.material.opacity = 0.9;
                        comet.light.intensity = 4.0 + Math.random() * 3.0;
                    } else if (comet.elapsed < COMET_ACTIVE_DURATION + COMET_FADE_DURATION) {
                        // Fade-Out Phase
                        const fadeProgress = (comet.elapsed - COMET_ACTIVE_DURATION) / COMET_FADE_DURATION;
                        comet.material.opacity = THREE.MathUtils.lerp(0.9, 0.0, fadeProgress);
                        comet.light.intensity = THREE.MathUtils.lerp(comet.light.intensity, 0.0, fadeProgress);
            
                        // Special Fade-Out for the First Comet
                        if (index === 0) {
                            // Apply a more pronounced fade-out
                            comet.material.opacity = THREE.MathUtils.lerp(0.9, 0.2, fadeProgress);
                            comet.light.intensity = THREE.MathUtils.lerp(comet.light.intensity, 1.0, fadeProgress);
                        }
                    } else {
                        // Reset the Comet
                        resetComet(comet);
                    }
            
                    // Update Position
                    comet.position.add(comet.velocity.clone().multiplyScalar(delta));
            
                    // Rotate the Comet to Align with Its Direction of Travel
                    const angle = Math.atan2(comet.velocity.y, comet.velocity.x);
                    comet.rotation.z = angle;
            
                    // Move the Spotlight with the Comet to Simulate Background Lighting
                    if (comet.spotLight) {
                        comet.spotLight.position.copy(comet.position);
                        comet.spotLight.position.z += 500;
                        comet.spotLight.intensity = 1.0 + Math.sin(clock.getElapsedTime() * 2) * 0.5;
                    }
                });
            }
            
            // Function to Update Particle Positions for Subtle Movement and Reactive Effects
            function updateParticles(delta) {
                particles.forEach((particle) => {
                    // Add Subtle Random Movement to Each Particle to Simulate Floating
                    particle.position.x += (Math.random() - 0.5) * 0.5 * delta;
                    particle.position.y += (Math.random() - 0.5) * 0.5 * delta;
                    particle.position.z += (Math.random() - 0.5) * 0.2 * delta;
            
                    // Add Subtle Movement Based on Camera Position for Parallax Effect in 3D Space
                    particle.position.x += mouseX * 0.02 * delta;
                    particle.position.y += mouseY * 0.02 * delta;
                });
            }
            
            // Function to Update Burning Particles
            function updateBurningParticles(delta) {
                for (let i = burningParticles.length - 1; i >= 0; i--) {
                    const particle = burningParticles[i];
                    // Update Position Based on Velocity
                    particle.position.add(particle.velocity.clone().multiplyScalar(delta));
            
                    // Decrease Lifespan
                    particle.lifespan -= delta;
                    if (particle.lifespan <= 0) {
                        scene.remove(particle);
                        burningParticles.splice(i, 1);
                        continue;
                    }
            
                    // Fade Out Opacity Over Time
                    particle.material.opacity = Math.max(0, particle.lifespan / 2.0);
                }
            }
            
            // Function to Adjust Comet Light Intensity Based on Proximity to Particles
            function updateCometLightIntensity() {
                comets.forEach((comet) => {
                    let maxIntensity = 4.0;  // Default comet intensity
                    particles.forEach((particle) => {
                        const distance = comet.position.distanceTo(particle.position);
                        if (distance < 500) {  // Threshold for effect
                            maxIntensity = Math.max(maxIntensity, 4.0 + (500 - distance) / 100);  // Increase intensity closer to particle
                        }
                    });
            
                    // Apply the Intensity to the Comet's Light
                    comet.light.intensity = maxIntensity;
                });
            }
            
            // Interactive Camera Movement Based on Mouse Position
            let mouseX = 0;
            let mouseY = 0;
            document.addEventListener('mousemove', (event) => {
                mouseX = (event.clientX / window.innerWidth) * 2 - 1;
                mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
            });
            
            // Function to Update the Camera Position Based on Mouse Movement
            function updateCamera() {
                camera.position.x += (mouseX * 500 - camera.position.x) * 0.05;
                camera.position.y += (mouseY * 300 - camera.position.y) * 0.05;
            }
            
            // Function to Update Comets, Particles, Burning Particles, and Camera
            // Note: Already defined above
            
            // === Initialize Comet Spawning ===
            createStaticStarField();
            startSpawningComets();
            for (let i = 0; i < particleCount; i++) {
                createParticle();
            }
            // === End Initialize Comet Spawning ===
            
            // === Postprocessing Setup ===
            
            // Initialize EffectComposer
            const composer = new EffectComposer(renderer);
            
            // Render Pass for Main and Comet Layers
            const renderPass = new RenderPass(scene, camera);
            renderPass.clear = true;
            composer.addPass(renderPass);
            
            // Bloom Pass Configuration
            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                1.5,  // Strength of bloom
                0.4,  // Bloom radius
                0.85  // Bloom threshold
            );
            bloomPass.renderToScreen = false; // Not the final render
            composer.addPass(bloomPass);
            
            // Chromatic Aberration Pass
            const chromaticAberrationPass = new ShaderPass(ChromaticAberrationShader);
            chromaticAberrationPass.uniforms['offset'].value = new THREE.Vector2(0.00075, 0.00075); // Reduced strength of the chromatic aberration
            composer.addPass(chromaticAberrationPass);
            
            // FXAA Pass for Anti-Aliasing
            const fxaaPass = new ShaderPass(FXAAShader);
            fxaaPass.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight);
            fxaaPass.renderToScreen = true; // Final render to screen
            composer.addPass(fxaaPass);
            
            // Handle Window Resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                composer.setSize(window.innerWidth, window.innerHeight);
                fxaaPass.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight);
            });
            
            const clock = new THREE.Clock();
            
            // Animation Function
            function animate() {
                requestAnimationFrame(animate);
            
                const delta = clock.getDelta();
            
                // Update Dynamic Stars' Twinkling
                updateDynamicStars(delta);
            
                // Update Comets, Particles, Burning Particles, and Camera
                updateComets(delta);
                updateParticles(delta);
                updateBurningParticles(delta); // Update burning particles
                updateCometLightIntensity();    // Update comet light intensity based on proximity to particles
                updateCamera();
            
                // Update Satellite
                updateSatellite(delta);
            
                // Render Postprocessed Scene (Main and Comet Layers)
                camera.layers.set(MAIN_LAYER | COMET_LAYER); // Render Main and Comet Layers
                composer.render();
            
                // Render Satellite Separately (Layer 2) Without Postprocessing
                renderer.autoClear = false; // Prevent clearing the canvas
                camera.layers.set(SATELLITE_LAYER); // Switch camera to Satellite Layer
                renderer.render(scene, camera);
                renderer.autoClear = true; // Reset autoClear to default
            }
            
            // Start Animation
            animate();
        </script>



















    </body>
</html>
